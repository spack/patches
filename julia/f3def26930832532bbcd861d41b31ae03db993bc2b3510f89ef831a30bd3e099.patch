diff --git a/clang/cmake/modules/AddClang.cmake b/clang/cmake/modules/AddClang.cmake
index 9bbbfc032b7df..6a3e9dbf4c2bb 100644
--- a/clang/cmake/modules/AddClang.cmake
+++ b/clang/cmake/modules/AddClang.cmake
@@ -160,7 +160,7 @@ macro(add_clang_tool name)
     get_target_export_arg(${name} Clang export_to_clangtargets)
     install(TARGETS ${name}
       ${export_to_clangtargets}
-      RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
+      RUNTIME DESTINATION ${LLVM_TOOLS_INSTALL_DIR}
       COMPONENT ${name})
 
     if(NOT LLVM_ENABLE_IDE)
diff --git a/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp b/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp
index 32b8f47ed6338..aba3240c532bd 100644
--- a/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp
+++ b/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp
@@ -217,7 +217,7 @@ namespace __sanitizer {
   unsigned struct_sockaddr_sz = sizeof(struct sockaddr);
 
   unsigned ucontext_t_sz(void *ctx) {
-#    if SANITIZER_GLIBC && SANITIZER_X64
+#    if SANITIZER_GLIBC && SANITIZER_X64 &&  __GLIBC_PREREQ (2, 27)
     // See kernel arch/x86/kernel/fpu/signal.c for details.
     const auto *fpregs = static_cast<ucontext_t *>(ctx)->uc_mcontext.fpregs;
     // The member names differ across header versions, but the actual layout
diff --git a/compiler-rt/lib/sanitizer_common/sanitizer_tls_get_addr.cpp b/compiler-rt/lib/sanitizer_common/sanitizer_tls_get_addr.cpp
index b13e2dc9e3327..45c52763cebfe 100644
--- a/compiler-rt/lib/sanitizer_common/sanitizer_tls_get_addr.cpp
+++ b/compiler-rt/lib/sanitizer_common/sanitizer_tls_get_addr.cpp
@@ -16,6 +16,10 @@
 #include "sanitizer_flags.h"
 #include "sanitizer_platform_interceptors.h"
 
+#if !defined(__APPLE__)
+#include <malloc.h>
+#endif
+
 namespace __sanitizer {
 #if SANITIZER_INTERCEPT_TLS_GET_ADDR
 
@@ -139,6 +143,8 @@ DTLS::DTV *DTLS_on_tls_get_addr(void *arg_void, void *res,
     tls_beg = header->start;
     VReport(2, "__tls_get_addr: glibc >=2.19 suspected; tls={0x%zx 0x%zx}\n",
             tls_beg, tls_size);
+  } else if (uptr size = malloc_usable_size((void *)tls_beg)) {
+    tls_size = size;
   } else {
     VReport(2, "__tls_get_addr: Can't guess glibc version\n");
     // This may happen inside the DTOR of main thread, so just ignore it.
diff --git a/compiler-rt/test/msan/Linux/signal_mcontext.cpp b/compiler-rt/test/msan/Linux/signal_mcontext.cpp
index b49451fbb730b..11ef74e7462bb 100644
--- a/compiler-rt/test/msan/Linux/signal_mcontext.cpp
+++ b/compiler-rt/test/msan/Linux/signal_mcontext.cpp
@@ -10,7 +10,7 @@
 
 void handler(int sig, siginfo_t *info, void *uctx) {
   __msan_check_mem_is_initialized(uctx, sizeof(ucontext_t));
-#if defined(__GLIBC__) && defined(__x86_64__)
+#if defined(__GLIBC__) && defined(__x86_64__) && __GLIBC_PREREQ(2, 27)
   auto *mctx = &static_cast<ucontext_t *>(uctx)->uc_mcontext;
   if (auto *fpregs = mctx->fpregs) {
     // The member names differ across header versions, but the actual layout
diff --git a/libunwind/src/CompactUnwinder.hpp b/libunwind/src/CompactUnwinder.hpp
index 0b2b5e111bfc2..ad0e042cb6ba1 100644
--- a/libunwind/src/CompactUnwinder.hpp
+++ b/libunwind/src/CompactUnwinder.hpp
@@ -310,6 +310,50 @@ int CompactUnwinder_x86_64<A>::stepWithCompactEncodingRBPFrame(
   uint32_t savedRegistersLocations =
       EXTRACT_BITS(compactEncoding, UNWIND_X86_64_RBP_FRAME_REGISTERS);
 
+  // If we have not stored EBP yet
+  if (functionStart == registers.getIP()) {
+    uint64_t rsp = registers.getSP();
+    // old esp is ebp less return address
+    registers.setSP(rsp+8);
+    // pop return address into eip
+    registers.setIP(addressSpace.get64(rsp));
+
+    return UNW_STEP_SUCCESS;
+  } else if (functionStart + 1 == registers.getIP()) {
+    uint64_t rsp = registers.getSP();
+    // old esp is ebp less return address
+    registers.setSP(rsp + 16);
+    // pop return address into eip
+    registers.setIP(addressSpace.get64(rsp + 8));
+
+    return UNW_STEP_SUCCESS;
+  }
+
+  // If we're about to return, we've already popped the base pointer
+  uint8_t b = addressSpace.get8(registers.getIP());
+
+  // This is a hack to detect VZEROUPPER but in between popq rbp and ret
+  // It's not pretty but it works
+  if (b == 0xC5) {
+    if ((b = addressSpace.get8(registers.getIP() + 1)) == 0xF8 &&
+        (b = addressSpace.get8(registers.getIP() + 2)) == 0x77)
+      b = addressSpace.get8(registers.getIP() + 3);
+    else
+      goto skip_ret;
+  }
+
+  if (b == 0xC3 || b == 0xCB || b == 0xC2 || b == 0xCA) {
+    uint64_t rbp = registers.getSP();
+    // old esp is ebp less return address
+    registers.setSP(rbp + 16);
+    // pop return address into eip
+    registers.setIP(addressSpace.get64(rbp + 8));
+
+    return UNW_STEP_SUCCESS;
+  }
+
+  skip_ret:
+
   uint64_t savedRegisters = registers.getRBP() - 8 * savedRegistersOffset;
   for (int i = 0; i < 5; ++i) {
     switch (savedRegistersLocations & 0x7) {
@@ -430,6 +474,118 @@ int CompactUnwinder_x86_64<A>::stepWithCompactEncodingFrameless(
       }
     }
   }
+
+  // Note that the order of these registers is so that
+  // registersSaved[0] is the one that will be pushed onto the stack last.
+  // Thus, if we want to walk this from the top, we need to go in reverse.
+  assert(regCount <= 6);
+
+  // check whether we are still in the prologue
+  uint64_t curAddr = functionStart;
+  if (regCount > 0) {
+    for (int8_t i = (int8_t)(regCount) - 1; i >= 0; --i) {
+      if (registers.getIP() == curAddr) {
+        // None of the registers have been modified yet, so we don't need to reload them
+        framelessUnwind(addressSpace, registers.getSP() + 8 * (regCount - (uint64_t)(i + 1)), registers);
+        return UNW_STEP_SUCCESS;
+      } else {
+        assert(curAddr < registers.getIP());
+      }
+
+
+      // pushq %rbp and pushq %rbx is 1 byte. Everything else 2
+      if ((UNWIND_X86_64_REG_RBP == registersSaved[i]) ||
+          (UNWIND_X86_64_REG_RBX == registersSaved[i]))
+        curAddr += 1;
+      else
+        curAddr += 2;
+    }
+  }
+  if (registers.getIP() == curAddr) {
+    // None of the registers have been modified yet, so we don't need to reload them
+    framelessUnwind(addressSpace, registers.getSP() + 8*regCount, registers);
+    return UNW_STEP_SUCCESS;
+  } else {
+    assert(curAddr < registers.getIP());
+  }
+
+
+  // And now for the epilogue
+  {
+    uint8_t  i  = 0;
+    uint64_t p  = registers.getIP();
+    uint8_t  b  = 0;
+
+    while (true) {
+      b = addressSpace.get8(p++);
+      // This is a hack to detect VZEROUPPER but in between the popq's and ret
+      // It's not pretty but it works
+      if (b == 0xC5) {
+        if ((b = addressSpace.get8(p++)) == 0xF8 && (b = addressSpace.get8(p++)) == 0x77)
+          b = addressSpace.get8(p++);
+        else
+          break;
+      }
+      //  popq %rbx    popq %rbp
+      if (b == 0x5B || b == 0x5D) {
+        i++;
+      } else if (b == 0x41) {
+        b = addressSpace.get8(p++);
+        if (b == 0x5C || b == 0x5D || b == 0x5E || b == 0x5F)
+          i++;
+        else
+          break;
+      } else if (b == 0xC3 || b == 0xCB || b == 0xC2 || b == 0xCA) {
+        // i pop's haven't happened yet
+        uint64_t savedRegisters = registers.getSP() + 8 * i;
+        if (regCount > 0) {
+          for (int8_t j = (int8_t)(regCount) - 1; j >= (int8_t)(regCount) - i; --j) {
+            uint64_t addr = savedRegisters - 8 * (regCount - (uint64_t)(j));
+            switch (registersSaved[j]) {
+              case UNWIND_X86_64_REG_RBX:
+                registers.setRBX(addressSpace.get64(addr));
+                break;
+              case UNWIND_X86_64_REG_R12:
+                registers.setR12(addressSpace.get64(addr));
+                break;
+              case UNWIND_X86_64_REG_R13:
+                registers.setR13(addressSpace.get64(addr));
+                break;
+              case UNWIND_X86_64_REG_R14:
+                registers.setR14(addressSpace.get64(addr));
+                break;
+              case UNWIND_X86_64_REG_R15:
+                registers.setR15(addressSpace.get64(addr));
+                break;
+              case UNWIND_X86_64_REG_RBP:
+                registers.setRBP(addressSpace.get64(addr));
+                break;
+              default:
+                _LIBUNWIND_DEBUG_LOG("bad register for frameless, encoding=%08X for "
+                             "function starting at 0x%llX",
+                              encoding, functionStart);
+                _LIBUNWIND_ABORT("invalid compact unwind encoding");
+            }
+          }
+        }
+        framelessUnwind(addressSpace, savedRegisters, registers);
+        return UNW_STEP_SUCCESS;
+      } else {
+        break;
+      }
+    }
+  }
+
+  /*
+   0x10fe2733a:  5b                             popq   %rbx
+   0x10fe2733b:  41 5c                          popq   %r12
+   0x10fe2733d:  41 5d                          popq   %r13
+   0x10fe2733f:  41 5e                          popq   %r14
+   0x10fe27341:  41 5f                          popq   %r15
+   0x10fe27343:  5d                             popq   %rbp
+   */
+
+
   uint64_t savedRegisters = registers.getSP() + stackSize - 8 - 8 * regCount;
   for (uint32_t i = 0; i < regCount; ++i) {
     switch (registersSaved[i]) {
diff --git a/lld/Common/CommonLinkerContext.cpp b/lld/Common/CommonLinkerContext.cpp
index 50ccbb37c7966..12f56bc10ec96 100644
--- a/lld/Common/CommonLinkerContext.cpp
+++ b/lld/Common/CommonLinkerContext.cpp
@@ -10,6 +10,8 @@
 #include "lld/Common/ErrorHandler.h"
 #include "lld/Common/Memory.h"
 
+#include "llvm/CodeGen/CommandFlags.h"
+
 using namespace llvm;
 using namespace lld;
 
@@ -20,7 +22,11 @@ using namespace lld;
 // state.
 static CommonLinkerContext *lctx;
 
-CommonLinkerContext::CommonLinkerContext() { lctx = this; }
+CommonLinkerContext::CommonLinkerContext() {
+  lctx = this;
+  // Fire off the static initializations in CGF's constructor.
+  codegen::RegisterCodeGenFlags CGF;
+}
 
 CommonLinkerContext::~CommonLinkerContext() {
   assert(lctx);
diff --git a/lld/Common/ErrorHandler.cpp b/lld/Common/ErrorHandler.cpp
index e557e533dedce..f661139549a3f 100644
--- a/lld/Common/ErrorHandler.cpp
+++ b/lld/Common/ErrorHandler.cpp
@@ -230,6 +230,9 @@ void ErrorHandler::warn(const Twine &msg) {
     return;
   }
 
+  if (suppressWarnings)
+    return;
+
   std::lock_guard<std::mutex> lock(mu);
   reportDiagnostic(getLocation(msg), Colors::MAGENTA, "warning", msg);
   sep = getSeparator(msg);
diff --git a/lld/ELF/Writer.cpp b/lld/ELF/Writer.cpp
index 5794f048c9909..0d67de575d641 100644
--- a/lld/ELF/Writer.cpp
+++ b/lld/ELF/Writer.cpp
@@ -25,6 +25,7 @@
 #include "lld/Common/Strings.h"
 #include "llvm/ADT/StringMap.h"
 #include "llvm/ADT/StringSwitch.h"
+#include "llvm/Support/MD5.h"
 #include "llvm/Support/Parallel.h"
 #include "llvm/Support/RandomNumberGenerator.h"
 #include "llvm/Support/SHA1.h"
diff --git a/lld/MachO/Arch/ARM.cpp b/lld/MachO/Arch/ARM.cpp
index 4dda94d7b0f38..7de0837fcf38a 100644
--- a/lld/MachO/Arch/ARM.cpp
+++ b/lld/MachO/Arch/ARM.cpp
@@ -34,7 +34,7 @@ struct ARM : TargetInfo {
 
   void writeStub(uint8_t *buf, const Symbol &) const override;
   void writeStubHelperHeader(uint8_t *buf) const override;
-  void writeStubHelperEntry(uint8_t *buf, const DylibSymbol &,
+  void writeStubHelperEntry(uint8_t *buf, const Symbol &,
                             uint64_t entryAddr) const override;
 
   void relaxGotLoad(uint8_t *loc, uint8_t type) const override;
@@ -148,7 +148,7 @@ void ARM::writeStubHelperHeader(uint8_t *buf) const {
   fatal("TODO: implement this");
 }
 
-void ARM::writeStubHelperEntry(uint8_t *buf, const DylibSymbol &sym,
+void ARM::writeStubHelperEntry(uint8_t *buf, const Symbol &sym,
                                uint64_t entryAddr) const {
   fatal("TODO: implement this");
 }
diff --git a/lld/MachO/Arch/ARM64.cpp b/lld/MachO/Arch/ARM64.cpp
index 001e112ae3ad2..e5b8a1b722f66 100644
--- a/lld/MachO/Arch/ARM64.cpp
+++ b/lld/MachO/Arch/ARM64.cpp
@@ -13,6 +13,7 @@
 #include "Target.h"
 
 #include "lld/Common/ErrorHandler.h"
+#include "mach-o/compact_unwind_encoding.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringRef.h"
 #include "llvm/BinaryFormat/MachO.h"
@@ -31,7 +32,7 @@ struct ARM64 : ARM64Common {
   ARM64();
   void writeStub(uint8_t *buf, const Symbol &) const override;
   void writeStubHelperHeader(uint8_t *buf) const override;
-  void writeStubHelperEntry(uint8_t *buf, const DylibSymbol &,
+  void writeStubHelperEntry(uint8_t *buf, const Symbol &,
                             uint64_t entryAddr) const override;
   const RelocAttrs &getRelocAttrs(uint8_t type) const override;
   void populateThunk(InputSection *thunk, Symbol *funcSym) override;
@@ -100,7 +101,7 @@ static constexpr uint32_t stubHelperEntryCode[] = {
     0x00000000, // 08: l0: .long 0
 };
 
-void ARM64::writeStubHelperEntry(uint8_t *buf8, const DylibSymbol &sym,
+void ARM64::writeStubHelperEntry(uint8_t *buf8, const Symbol &sym,
                                  uint64_t entryVA) const {
   ::writeStubHelperEntry(buf8, stubHelperEntryCode, sym, entryVA);
 }
@@ -141,6 +142,10 @@ ARM64::ARM64() : ARM64Common(LP64()) {
   backwardBranchRange = 128 * 1024 * 1024;
   forwardBranchRange = backwardBranchRange - 4;
 
+  modeDwarfEncoding = UNWIND_ARM64_MODE_DWARF;
+  subtractorRelocType = ARM64_RELOC_SUBTRACTOR;
+  unsignedRelocType = ARM64_RELOC_UNSIGNED;
+
   stubHelperHeaderSize = sizeof(stubHelperHeaderCode);
   stubHelperEntrySize = sizeof(stubHelperEntryCode);
 }
diff --git a/lld/MachO/Arch/ARM64Common.cpp b/lld/MachO/Arch/ARM64Common.cpp
index 67e7292fd6fdb..f55258ce8ec9f 100644
--- a/lld/MachO/Arch/ARM64Common.cpp
+++ b/lld/MachO/Arch/ARM64Common.cpp
@@ -38,56 +38,57 @@ int64_t ARM64Common::getEmbeddedAddend(MemoryBufferRef mb, uint64_t offset,
   }
 }
 
+static void writeValue(uint8_t *loc, const Reloc &r, uint64_t value) {
+  switch (r.length) {
+  case 2:
+    checkInt(loc, r, value, 32);
+    write32le(loc, value);
+    break;
+  case 3:
+    write64le(loc, value);
+    break;
+  default:
+    llvm_unreachable("invalid r_length");
+  }
+}
+
 // For instruction relocations (load, store, add), the base
 // instruction is pre-populated in the text section. A pre-populated
 // instruction has opcode & register-operand bits set, with immediate
 // operands zeroed. We read it from text, OR-in the immediate
 // operands, then write-back the completed instruction.
-
 void ARM64Common::relocateOne(uint8_t *loc, const Reloc &r, uint64_t value,
                               uint64_t pc) const {
+  auto loc32 = reinterpret_cast<uint32_t *>(loc);
   uint32_t base = ((r.length == 2) ? read32le(loc) : 0);
   switch (r.type) {
   case ARM64_RELOC_BRANCH26:
-    value = encodeBranch26(r, base, value - pc);
+    encodeBranch26(loc32, r, base, value - pc);
     break;
   case ARM64_RELOC_SUBTRACTOR:
   case ARM64_RELOC_UNSIGNED:
-    if (r.length == 2)
-      checkInt(r, value, 32);
+    writeValue(loc, r, value);
     break;
   case ARM64_RELOC_POINTER_TO_GOT:
     if (r.pcrel)
       value -= pc;
-    checkInt(r, value, 32);
+    writeValue(loc, r, value);
     break;
   case ARM64_RELOC_PAGE21:
   case ARM64_RELOC_GOT_LOAD_PAGE21:
-  case ARM64_RELOC_TLVP_LOAD_PAGE21: {
+  case ARM64_RELOC_TLVP_LOAD_PAGE21:
     assert(r.pcrel);
-    value = encodePage21(r, base, pageBits(value) - pageBits(pc));
+    encodePage21(loc32, r, base, pageBits(value) - pageBits(pc));
     break;
-  }
   case ARM64_RELOC_PAGEOFF12:
   case ARM64_RELOC_GOT_LOAD_PAGEOFF12:
   case ARM64_RELOC_TLVP_LOAD_PAGEOFF12:
     assert(!r.pcrel);
-    value = encodePageOff12(base, value);
+    encodePageOff12(loc32, base, value);
     break;
   default:
     llvm_unreachable("unexpected relocation type");
   }
-
-  switch (r.length) {
-  case 2:
-    write32le(loc, value);
-    break;
-  case 3:
-    write64le(loc, value);
-    break;
-  default:
-    llvm_unreachable("invalid r_length");
-  }
 }
 
 void ARM64Common::relaxGotLoad(uint8_t *loc, uint8_t type) const {
diff --git a/lld/MachO/Arch/ARM64Common.h b/lld/MachO/Arch/ARM64Common.h
index 934101caefb99..54f94ee76c06b 100644
--- a/lld/MachO/Arch/ARM64Common.h
+++ b/lld/MachO/Arch/ARM64Common.h
@@ -40,16 +40,18 @@ inline uint64_t bitField(uint64_t value, int right, int width, int left) {
 // |           |                       imm26                       |
 // +-----------+---------------------------------------------------+
 
-inline uint64_t encodeBranch26(const Reloc &r, uint64_t base, uint64_t va) {
-  checkInt(r, va, 28);
+inline void encodeBranch26(uint32_t *loc, const Reloc &r, uint32_t base,
+                           uint64_t va) {
+  checkInt(loc, r, va, 28);
   // Since branch destinations are 4-byte aligned, the 2 least-
   // significant bits are 0. They are right shifted off the end.
-  return (base | bitField(va, 2, 26, 0));
+  llvm::support::endian::write32le(loc, base | bitField(va, 2, 26, 0));
 }
 
-inline uint64_t encodeBranch26(SymbolDiagnostic d, uint64_t base, uint64_t va) {
-  checkInt(d, va, 28);
-  return (base | bitField(va, 2, 26, 0));
+inline void encodeBranch26(uint32_t *loc, SymbolDiagnostic d, uint32_t base,
+                           uint64_t va) {
+  checkInt(loc, d, va, 28);
+  llvm::support::endian::write32le(loc, base | bitField(va, 2, 26, 0));
 }
 
 //   30 29          23                                  5
@@ -57,14 +59,18 @@ inline uint64_t encodeBranch26(SymbolDiagnostic d, uint64_t base, uint64_t va) {
 // | |ilo|         |                immhi                |         |
 // +-+---+---------+-------------------------------------+---------+
 
-inline uint64_t encodePage21(const Reloc &r, uint64_t base, uint64_t va) {
-  checkInt(r, va, 35);
-  return (base | bitField(va, 12, 2, 29) | bitField(va, 14, 19, 5));
+inline void encodePage21(uint32_t *loc, const Reloc &r, uint32_t base,
+                         uint64_t va) {
+  checkInt(loc, r, va, 35);
+  llvm::support::endian::write32le(loc, base | bitField(va, 12, 2, 29) |
+                                            bitField(va, 14, 19, 5));
 }
 
-inline uint64_t encodePage21(SymbolDiagnostic d, uint64_t base, uint64_t va) {
-  checkInt(d, va, 35);
-  return (base | bitField(va, 12, 2, 29) | bitField(va, 14, 19, 5));
+inline void encodePage21(uint32_t *loc, SymbolDiagnostic d, uint32_t base,
+                         uint64_t va) {
+  checkInt(loc, d, va, 35);
+  llvm::support::endian::write32le(loc, base | bitField(va, 12, 2, 29) |
+                                            bitField(va, 14, 19, 5));
 }
 
 //                      21                   10
@@ -72,7 +78,7 @@ inline uint64_t encodePage21(SymbolDiagnostic d, uint64_t base, uint64_t va) {
 // |                   |         imm12         |                   |
 // +-------------------+-----------------------+-------------------+
 
-inline uint64_t encodePageOff12(uint32_t base, uint64_t va) {
+inline void encodePageOff12(uint32_t *loc, uint32_t base, uint64_t va) {
   int scale = 0;
   if ((base & 0x3b00'0000) == 0x3900'0000) { // load/store
     scale = base >> 30;
@@ -82,7 +88,8 @@ inline uint64_t encodePageOff12(uint32_t base, uint64_t va) {
 
   // TODO(gkm): extract embedded addend and warn if != 0
   // uint64_t addend = ((base & 0x003FFC00) >> 10);
-  return (base | bitField(va, scale, 12 - scale, 10));
+  llvm::support::endian::write32le(loc,
+                                   base | bitField(va, scale, 12 - scale, 10));
 }
 
 inline uint64_t pageBits(uint64_t address) {
@@ -99,9 +106,9 @@ inline void writeStub(uint8_t *buf8, const uint32_t stubCode[3],
       pageBits(in.stubs->addr + sym.stubsIndex * stubCodeSize);
   uint64_t lazyPointerVA =
       in.lazyPointers->addr + sym.stubsIndex * LP::wordSize;
-  buf32[0] = encodePage21({&sym, "stub"}, stubCode[0],
-                          pageBits(lazyPointerVA) - pcPageBits);
-  buf32[1] = encodePageOff12(stubCode[1], lazyPointerVA);
+  encodePage21(&buf32[0], {&sym, "stub"}, stubCode[0],
+               pageBits(lazyPointerVA) - pcPageBits);
+  encodePageOff12(&buf32[1], stubCode[1], lazyPointerVA);
   buf32[2] = stubCode[2];
 }
 
@@ -114,27 +121,27 @@ inline void writeStubHelperHeader(uint8_t *buf8,
   };
   uint64_t loaderVA = in.imageLoaderCache->getVA();
   SymbolDiagnostic d = {nullptr, "stub header helper"};
-  buf32[0] = encodePage21(d, stubHelperHeaderCode[0],
-                          pageBits(loaderVA) - pcPageBits(0));
-  buf32[1] = encodePageOff12(stubHelperHeaderCode[1], loaderVA);
+  encodePage21(&buf32[0], d, stubHelperHeaderCode[0],
+               pageBits(loaderVA) - pcPageBits(0));
+  encodePageOff12(&buf32[1], stubHelperHeaderCode[1], loaderVA);
   buf32[2] = stubHelperHeaderCode[2];
   uint64_t binderVA =
       in.got->addr + in.stubHelper->stubBinder->gotIndex * LP::wordSize;
-  buf32[3] = encodePage21(d, stubHelperHeaderCode[3],
-                          pageBits(binderVA) - pcPageBits(3));
-  buf32[4] = encodePageOff12(stubHelperHeaderCode[4], binderVA);
+  encodePage21(&buf32[3], d, stubHelperHeaderCode[3],
+               pageBits(binderVA) - pcPageBits(3));
+  encodePageOff12(&buf32[4], stubHelperHeaderCode[4], binderVA);
   buf32[5] = stubHelperHeaderCode[5];
 }
 
 inline void writeStubHelperEntry(uint8_t *buf8,
                                  const uint32_t stubHelperEntryCode[3],
-                                 const DylibSymbol &sym, uint64_t entryVA) {
+                                 const Symbol &sym, uint64_t entryVA) {
   auto *buf32 = reinterpret_cast<uint32_t *>(buf8);
   auto pcVA = [entryVA](int i) { return entryVA + i * sizeof(uint32_t); };
   uint64_t stubHelperHeaderVA = in.stubHelper->addr;
   buf32[0] = stubHelperEntryCode[0];
-  buf32[1] = encodeBranch26({&sym, "stub helper"}, stubHelperEntryCode[1],
-                            stubHelperHeaderVA - pcVA(1));
+  encodeBranch26(&buf32[1], {&sym, "stub helper"}, stubHelperEntryCode[1],
+                 stubHelperHeaderVA - pcVA(1));
   buf32[2] = sym.lazyBindOffset;
 }
 
diff --git a/lld/MachO/Arch/ARM64_32.cpp b/lld/MachO/Arch/ARM64_32.cpp
index f7b1439b8930a..5be411e403420 100644
--- a/lld/MachO/Arch/ARM64_32.cpp
+++ b/lld/MachO/Arch/ARM64_32.cpp
@@ -31,7 +31,7 @@ struct ARM64_32 : ARM64Common {
   ARM64_32();
   void writeStub(uint8_t *buf, const Symbol &) const override;
   void writeStubHelperHeader(uint8_t *buf) const override;
-  void writeStubHelperEntry(uint8_t *buf, const DylibSymbol &,
+  void writeStubHelperEntry(uint8_t *buf, const Symbol &,
                             uint64_t entryAddr) const override;
   const RelocAttrs &getRelocAttrs(uint8_t type) const override;
 };
@@ -96,7 +96,7 @@ static constexpr uint32_t stubHelperEntryCode[] = {
     0x00000000, // 08: l0: .long 0
 };
 
-void ARM64_32::writeStubHelperEntry(uint8_t *buf8, const DylibSymbol &sym,
+void ARM64_32::writeStubHelperEntry(uint8_t *buf8, const Symbol &sym,
                                     uint64_t entryVA) const {
   ::writeStubHelperEntry(buf8, stubHelperEntryCode, sym, entryVA);
 }
@@ -105,6 +105,10 @@ ARM64_32::ARM64_32() : ARM64Common(ILP32()) {
   cpuType = CPU_TYPE_ARM64_32;
   cpuSubtype = CPU_SUBTYPE_ARM64_V8;
 
+  modeDwarfEncoding = 0x04000000;              // UNWIND_ARM_MODE_DWARF
+  subtractorRelocType = GENERIC_RELOC_INVALID; // FIXME
+  unsignedRelocType = GENERIC_RELOC_INVALID;   // FIXME
+
   stubSize = sizeof(stubCode);
   stubHelperHeaderSize = sizeof(stubHelperHeaderCode);
   stubHelperEntrySize = sizeof(stubHelperEntryCode);
diff --git a/lld/MachO/Arch/X86_64.cpp b/lld/MachO/Arch/X86_64.cpp
index 7e2155801fc2f..d675356b9ffb9 100644
--- a/lld/MachO/Arch/X86_64.cpp
+++ b/lld/MachO/Arch/X86_64.cpp
@@ -12,6 +12,7 @@
 #include "Target.h"
 
 #include "lld/Common/ErrorHandler.h"
+#include "mach-o/compact_unwind_encoding.h"
 #include "llvm/BinaryFormat/MachO.h"
 #include "llvm/Support/Endian.h"
 
@@ -32,7 +33,7 @@ struct X86_64 : TargetInfo {
 
   void writeStub(uint8_t *buf, const Symbol &) const override;
   void writeStubHelperHeader(uint8_t *buf) const override;
-  void writeStubHelperEntry(uint8_t *buf, const DylibSymbol &,
+  void writeStubHelperEntry(uint8_t *buf, const Symbol &,
                             uint64_t entryAddr) const override;
 
   void relaxGotLoad(uint8_t *loc, uint8_t type) const override;
@@ -102,9 +103,9 @@ void X86_64::relocateOne(uint8_t *loc, const Reloc &r, uint64_t value,
   switch (r.length) {
   case 2:
     if (r.type == X86_64_RELOC_UNSIGNED)
-      checkUInt(r, value, 32);
+      checkUInt(loc, r, value, 32);
     else
-      checkInt(r, value, 32);
+      checkInt(loc, r, value, 32);
     write32le(loc, value);
     break;
   case 3:
@@ -127,7 +128,7 @@ void X86_64::relocateOne(uint8_t *loc, const Reloc &r, uint64_t value,
 static void writeRipRelative(SymbolDiagnostic d, uint8_t *buf, uint64_t bufAddr,
                              uint64_t bufOff, uint64_t destAddr) {
   uint64_t rip = bufAddr + bufOff;
-  checkInt(d, destAddr - rip, 32);
+  checkInt(buf, d, destAddr - rip, 32);
   // For the instructions we care about, the RIP-relative address is always
   // stored in the last 4 bytes of the instruction.
   write32le(buf + bufOff - 4, destAddr - rip);
@@ -166,7 +167,7 @@ static constexpr uint8_t stubHelperEntry[] = {
     0xe9, 0, 0, 0, 0, // 0x5: jmp <__stub_helper>
 };
 
-void X86_64::writeStubHelperEntry(uint8_t *buf, const DylibSymbol &sym,
+void X86_64::writeStubHelperEntry(uint8_t *buf, const Symbol &sym,
                                   uint64_t entryAddr) const {
   memcpy(buf, stubHelperEntry, sizeof(stubHelperEntry));
   write32le(buf + 1, sym.lazyBindOffset);
@@ -185,6 +186,10 @@ X86_64::X86_64() : TargetInfo(LP64()) {
   cpuType = CPU_TYPE_X86_64;
   cpuSubtype = CPU_SUBTYPE_X86_64_ALL;
 
+  modeDwarfEncoding = UNWIND_X86_MODE_DWARF;
+  subtractorRelocType = X86_64_RELOC_SUBTRACTOR;
+  unsignedRelocType = X86_64_RELOC_UNSIGNED;
+
   stubSize = sizeof(stub);
   stubHelperHeaderSize = sizeof(stubHelperHeader);
   stubHelperEntrySize = sizeof(stubHelperEntry);
diff --git a/lld/MachO/CMakeLists.txt b/lld/MachO/CMakeLists.txt
index 4bd0816bca66f..f8b1d45c489a3 100644
--- a/lld/MachO/CMakeLists.txt
+++ b/lld/MachO/CMakeLists.txt
@@ -14,6 +14,7 @@ add_lld_library(lldMachO
   Driver.cpp
   DriverUtils.cpp
   Dwarf.cpp
+  EhFrame.cpp
   ExportTrie.cpp
   ICF.cpp
   InputFiles.cpp
diff --git a/lld/MachO/ConcatOutputSection.cpp b/lld/MachO/ConcatOutputSection.cpp
index 4fae93469b5ff..ed709a30ade4d 100644
--- a/lld/MachO/ConcatOutputSection.cpp
+++ b/lld/MachO/ConcatOutputSection.cpp
@@ -57,14 +57,14 @@ void ConcatOutputSection::addInput(ConcatInputSection *input) {
 // implement thunks. TODO: Adding support for branch islands!
 //
 // Internally -- as expressed in LLD's data structures -- a
-// branch-range-extension thunk comprises ...
+// branch-range-extension thunk consists of:
 //
-// (1) new Defined privateExtern symbol for the thunk named
+// (1) new Defined symbol for the thunk named
 //     <FUNCTION>.thunk.<SEQUENCE>, which references ...
 // (2) new InputSection, which contains ...
 // (3.1) new data for the instructions to load & branch to the far address +
 // (3.2) new Relocs on instructions to load the far address, which reference ...
-// (4.1) existing Defined extern symbol for the real function in __text, or
+// (4.1) existing Defined symbol for the real function in __text, or
 // (4.2) existing DylibSymbol for the real function in a dylib
 //
 // Nearly-optimal thunk-placement algorithm features:
@@ -84,15 +84,17 @@ void ConcatOutputSection::addInput(ConcatInputSection *input) {
 //   distant call sites might be unable to reach the same thunk, so multiple
 //   thunks are necessary to serve all call sites in a very large program. A
 //   thunkInfo stores state for all thunks associated with a particular
-//   function: (a) thunk symbol, (b) input section containing stub code, and
-//   (c) sequence number for the active thunk incarnation. When an old thunk
-//   goes out of range, we increment the sequence number and create a new
-//   thunk named <FUNCTION>.thunk.<SEQUENCE>.
+//   function:
+//     (a) thunk symbol
+//     (b) input section containing stub code, and
+//     (c) sequence number for the active thunk incarnation.
+//   When an old thunk goes out of range, we increment the sequence number and
+//   create a new thunk named <FUNCTION>.thunk.<SEQUENCE>.
 //
-// * A thunk incarnation comprises (a) private-extern Defined symbol pointing
-//   to (b) an InputSection holding machine instructions (similar to a MachO
-//   stub), and (c) Reloc(s) that reference the real function for fixing-up
-//   the stub code.
+// * A thunk consists of
+//     (a) a Defined symbol pointing to
+//     (b) an InputSection holding machine code (similar to a MachO stub), and
+//     (c) relocs referencing the real function for fixing up the stub code.
 //
 // * std::vector<InputSection *> MergedInputSection::thunks: A vector parallel
 //   to the inputs vector. We store new thunks via cheap vector append, rather
@@ -119,7 +121,7 @@ DenseMap<Symbol *, ThunkInfo> lld::macho::thunkMap;
 // instructions, whereas CISC (i.e., x86) generally doesn't. RISC only needs
 // thunks for programs so large that branch source & destination addresses
 // might differ more than the range of branch instruction(s).
-bool ConcatOutputSection::needsThunks() const {
+bool TextOutputSection::needsThunks() const {
   if (!target->usesThunks())
     return false;
   uint64_t isecAddr = addr;
@@ -136,7 +138,7 @@ bool ConcatOutputSection::needsThunks() const {
       auto *sym = r.referent.get<Symbol *>();
       // Pre-populate the thunkMap and memoize call site counts for every
       // InputSection and ThunkInfo. We do this for the benefit of
-      // ConcatOutputSection::estimateStubsInRangeVA()
+      // estimateStubsInRangeVA().
       ThunkInfo &thunkInfo = thunkMap[sym];
       // Knowing ThunkInfo call site count will help us know whether or not we
       // might need to create more for this referent at the time we are
@@ -152,7 +154,7 @@ bool ConcatOutputSection::needsThunks() const {
 // Since __stubs is placed after __text, we must estimate the address
 // beyond which stubs are within range of a simple forward branch.
 // This is called exactly once, when the last input section has been finalized.
-uint64_t ConcatOutputSection::estimateStubsInRangeVA(size_t callIdx) const {
+uint64_t TextOutputSection::estimateStubsInRangeVA(size_t callIdx) const {
   // Tally the functions which still have call sites remaining to process,
   // which yields the maximum number of thunks we might yet place.
   size_t maxPotentialThunks = 0;
@@ -191,23 +193,24 @@ uint64_t ConcatOutputSection::estimateStubsInRangeVA(size_t callIdx) const {
   return stubsInRangeVA;
 }
 
-void ConcatOutputSection::finalize() {
-  uint64_t isecAddr = addr;
-  uint64_t isecFileOff = fileOff;
-  auto finalizeOne = [&](ConcatInputSection *isec) {
-    isecAddr = alignTo(isecAddr, isec->align);
-    isecFileOff = alignTo(isecFileOff, isec->align);
-    isec->outSecOff = isecAddr - addr;
-    isec->isFinal = true;
-    isecAddr += isec->getSize();
-    isecFileOff += isec->getFileSize();
-  };
+void ConcatOutputSection::finalizeOne(ConcatInputSection *isec) {
+  size = alignTo(size, isec->align);
+  fileSize = alignTo(fileSize, isec->align);
+  isec->outSecOff = size;
+  isec->isFinal = true;
+  size += isec->getSize();
+  fileSize += isec->getFileSize();
+}
+
+void ConcatOutputSection::finalizeContents() {
+  for (ConcatInputSection *isec : inputs)
+    finalizeOne(isec);
+}
 
+void TextOutputSection::finalize() {
   if (!needsThunks()) {
     for (ConcatInputSection *isec : inputs)
       finalizeOne(isec);
-    size = isecAddr - addr;
-    fileSize = isecFileOff - fileOff;
     return;
   }
 
@@ -223,7 +226,7 @@ void ConcatOutputSection::finalize() {
   // Walk all sections in order. Finalize all sections that are less than
   // forwardBranchRange in front of it.
   // isecVA is the address of the current section.
-  // isecAddr is the start address of the first non-finalized section.
+  // addr + size is the start address of the first non-finalized section.
 
   // inputs[finalIdx] is for finalization (address-assignment)
   size_t finalIdx = 0;
@@ -244,7 +247,7 @@ void ConcatOutputSection::finalize() {
     // from the current position to the position where the thunks are inserted
     // grows. So leave room for a bunch of thunks.
     unsigned slop = 256 * thunkSize;
-    while (finalIdx < endIdx && isecAddr + inputs[finalIdx]->getSize() <
+    while (finalIdx < endIdx && addr + size + inputs[finalIdx]->getSize() <
                                     isecVA + forwardBranchRange - slop)
       finalizeOne(inputs[finalIdx++]);
 
@@ -305,7 +308,7 @@ void ConcatOutputSection::finalize() {
         }
       }
       // ... otherwise, create a new thunk.
-      if (isecAddr > highVA) {
+      if (addr + size > highVA) {
         // There were too many consecutive branch instructions for `slop`
         // above. If you hit this: For the current algorithm, just bumping up
         // slop above and trying again is probably simplest. (See also PR51578
@@ -313,7 +316,7 @@ void ConcatOutputSection::finalize() {
         fatal(Twine(__FUNCTION__) + ": FIXME: thunk range overrun");
       }
       thunkInfo.isec =
-          make<ConcatInputSection>(isec->getSegName(), isec->getName());
+          makeSyntheticInputSection(isec->getSegName(), isec->getName());
       thunkInfo.isec->parent = this;
 
       // This code runs after dead code removal. Need to set the `live` bit
@@ -323,11 +326,20 @@ void ConcatOutputSection::finalize() {
 
       StringRef thunkName = saver().save(funcSym->getName() + ".thunk." +
                                          std::to_string(thunkInfo.sequence++));
-      r.referent = thunkInfo.sym = symtab->addDefined(
-          thunkName, /*file=*/nullptr, thunkInfo.isec, /*value=*/0,
-          /*size=*/thunkSize, /*isWeakDef=*/false, /*isPrivateExtern=*/true,
-          /*isThumb=*/false, /*isReferencedDynamically=*/false,
-          /*noDeadStrip=*/false, /*isWeakDefCanBeHidden=*/false);
+      if (!isa<Defined>(funcSym) || cast<Defined>(funcSym)->isExternal()) {
+        r.referent = thunkInfo.sym = symtab->addDefined(
+            thunkName, /*file=*/nullptr, thunkInfo.isec, /*value=*/0, thunkSize,
+            /*isWeakDef=*/false, /*isPrivateExtern=*/true,
+            /*isThumb=*/false, /*isReferencedDynamically=*/false,
+            /*noDeadStrip=*/false, /*isWeakDefCanBeHidden=*/false);
+      } else {
+        r.referent = thunkInfo.sym = make<Defined>(
+            thunkName, /*file=*/nullptr, thunkInfo.isec, /*value=*/0, thunkSize,
+            /*isWeakDef=*/false, /*isExternal=*/false, /*isPrivateExtern=*/true,
+            /*includeInSymtab=*/true, /*isThumb=*/false,
+            /*isReferencedDynamically=*/false, /*noDeadStrip=*/false,
+            /*isWeakDefCanBeHidden=*/false);
+      }
       thunkInfo.sym->used = true;
       target->populateThunk(thunkInfo.isec, funcSym);
       finalizeOne(thunkInfo.isec);
@@ -335,8 +347,6 @@ void ConcatOutputSection::finalize() {
       ++thunkCount;
     }
   }
-  size = isecAddr - addr;
-  fileSize = isecFileOff - fileOff;
 
   log("thunks for " + parent->name + "," + name +
       ": funcs = " + std::to_string(thunkMap.size()) +
@@ -347,6 +357,11 @@ void ConcatOutputSection::finalize() {
 }
 
 void ConcatOutputSection::writeTo(uint8_t *buf) const {
+  for (ConcatInputSection *isec : inputs)
+    isec->writeTo(buf + isec->outSecOff);
+}
+
+void TextOutputSection::writeTo(uint8_t *buf) const {
   // Merge input sections from thunk & ordinary vectors
   size_t i = 0, ie = inputs.size();
   size_t t = 0, te = thunks.size();
@@ -391,8 +406,14 @@ ConcatOutputSection *
 ConcatOutputSection::getOrCreateForInput(const InputSection *isec) {
   NamePair names = maybeRenameSection({isec->getSegName(), isec->getName()});
   ConcatOutputSection *&osec = concatOutputSections[names];
-  if (!osec)
-    osec = make<ConcatOutputSection>(names.second);
+  if (!osec) {
+    if (isec->getSegName() == segment_names::text &&
+        isec->getName() != section_names::gccExceptTab &&
+        isec->getName() != section_names::ehFrame)
+      osec = make<TextOutputSection>(names.second);
+    else
+      osec = make<ConcatOutputSection>(names.second);
+  }
   return osec;
 }
 
diff --git a/lld/MachO/ConcatOutputSection.h b/lld/MachO/ConcatOutputSection.h
index ec3d6bfbc344c..c7404f48e27a3 100644
--- a/lld/MachO/ConcatOutputSection.h
+++ b/lld/MachO/ConcatOutputSection.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLD_MACHO_MERGED_OUTPUT_SECTION_H
-#define LLD_MACHO_MERGED_OUTPUT_SECTION_H
+#ifndef LLD_MACHO_CONCAT_OUTPUT_SECTION_H
+#define LLD_MACHO_CONCAT_OUTPUT_SECTION_H
 
 #include "InputSection.h"
 #include "OutputSection.h"
@@ -24,7 +24,7 @@ class Defined;
 // files that are labeled with the same segment and section name. This class
 // contains all such sections and writes the data from each section sequentially
 // in the final binary.
-class ConcatOutputSection final : public OutputSection {
+class ConcatOutputSection : public OutputSection {
 public:
   explicit ConcatOutputSection(StringRef name)
       : OutputSection(ConcatKind, name) {}
@@ -37,27 +37,46 @@ class ConcatOutputSection final : public OutputSection {
   uint64_t getSize() const override { return size; }
   uint64_t getFileSize() const override { return fileSize; }
 
-  void addInput(ConcatInputSection *input);
-  void finalize() override;
-  bool needsThunks() const;
-  uint64_t estimateStubsInRangeVA(size_t callIdx) const;
+  // Assign values to InputSection::outSecOff. In contrast to TextOutputSection,
+  // which does this in its implementation of `finalize()`, we can do this
+  // without `finalize()`'s sequential guarantees detailed in the block comment
+  // of `OutputSection::finalize()`.
+  virtual void finalizeContents();
 
+  void addInput(ConcatInputSection *input);
   void writeTo(uint8_t *buf) const override;
 
-  std::vector<ConcatInputSection *> inputs;
-  std::vector<ConcatInputSection *> thunks;
-
   static bool classof(const OutputSection *sec) {
     return sec->kind() == ConcatKind;
   }
 
   static ConcatOutputSection *getOrCreateForInput(const InputSection *);
 
-private:
-  void finalizeFlags(InputSection *input);
+  std::vector<ConcatInputSection *> inputs;
 
+protected:
   size_t size = 0;
   uint64_t fileSize = 0;
+  void finalizeOne(ConcatInputSection *);
+
+private:
+  void finalizeFlags(InputSection *input);
+};
+
+// ConcatOutputSections that contain code (text) require special handling to
+// support thunk insertion.
+class TextOutputSection : public ConcatOutputSection {
+public:
+  explicit TextOutputSection(StringRef name) : ConcatOutputSection(name) {}
+  void finalizeContents() override {}
+  void finalize() override;
+  bool needsThunks() const;
+  void writeTo(uint8_t *buf) const override;
+
+private:
+  uint64_t estimateStubsInRangeVA(size_t callIdx) const;
+
+  std::vector<ConcatInputSection *> thunks;
 };
 
 // We maintain one ThunkInfo per real function.
diff --git a/lld/MachO/Config.h b/lld/MachO/Config.h
index e6849a39d03ad..d1c9011051e85 100644
--- a/lld/MachO/Config.h
+++ b/lld/MachO/Config.h
@@ -30,7 +30,6 @@ namespace macho {
 
 class InputSection;
 class Symbol;
-struct SymbolPriorityEntry;
 
 using NamePair = std::pair<llvm::StringRef, llvm::StringRef>;
 using SectionRenameMap = llvm::DenseMap<NamePair, NamePair>;
@@ -95,6 +94,13 @@ class SymbolPatterns {
   bool match(llvm::StringRef symbolName) const;
 };
 
+enum class SymtabPresence {
+  All,
+  None,
+  SelectivelyIncluded,
+  SelectivelyExcluded,
+};
+
 struct Configuration {
   Symbol *entry = nullptr;
   bool hasReexports = false;
@@ -125,6 +131,7 @@ struct Configuration {
   bool dedupLiterals = true;
   bool omitDebugInfo = false;
   bool warnDylibInstallName = false;
+  bool ignoreOptimizationHints = false;
   uint32_t headerPad;
   uint32_t dylibCompatibilityVersion = 0;
   uint32_t dylibCurrentVersion = 0;
@@ -153,6 +160,7 @@ struct Configuration {
   bool deadStrip = false;
   bool errorForArchMismatch = false;
   PlatformInfo platformInfo;
+  llvm::Optional<PlatformInfo> secondaryPlatformInfo;
   NamespaceKind namespaceKind = NamespaceKind::twolevel;
   UndefinedSymbolTreatment undefinedSymbolTreatment =
       UndefinedSymbolTreatment::error;
@@ -170,10 +178,6 @@ struct Configuration {
   std::vector<SectionAlign> sectionAlignments;
   std::vector<SegmentProtection> segmentProtections;
 
-  llvm::DenseMap<llvm::StringRef, SymbolPriorityEntry> priorities;
-  llvm::MapVector<std::pair<const InputSection *, const InputSection *>,
-                  uint64_t>
-      callGraphProfile;
   bool callGraphProfileSort = false;
   llvm::StringRef printSymbolOrder;
 
@@ -182,6 +186,10 @@ struct Configuration {
 
   SymbolPatterns exportedSymbols;
   SymbolPatterns unexportedSymbols;
+  SymbolPatterns whyLive;
+
+  SymtabPresence localSymbolsPresence = SymtabPresence::All;
+  SymbolPatterns localSymbolPatterns;
 
   bool zeroModTime = false;
 
@@ -194,20 +202,6 @@ struct Configuration {
   }
 };
 
-// The symbol with the highest priority should be ordered first in the output
-// section (modulo input section contiguity constraints). Using priority
-// (highest first) instead of order (lowest first) has the convenient property
-// that the default-constructed zero priority -- for symbols/sections without a
-// user-defined order -- naturally ends up putting them at the end of the
-// output.
-struct SymbolPriorityEntry {
-  // The priority given to a matching symbol, regardless of which object file
-  // it originated from.
-  size_t anyObjectFile = 0;
-  // The priority given to a matching symbol from a particular object file.
-  llvm::DenseMap<llvm::StringRef, size_t> objectFiles;
-};
-
 // Whether to force-load an archive.
 enum class ForceLoad {
   Default, // Apply -all_load or -ObjC behaviors if those flags are enabled
diff --git a/lld/MachO/Driver.cpp b/lld/MachO/Driver.cpp
index f0cddab94f557..6522a16fcc7f1 100644
--- a/lld/MachO/Driver.cpp
+++ b/lld/MachO/Driver.cpp
@@ -267,8 +267,9 @@ static InputFile *addFile(StringRef path, ForceLoad forceLoadArchive,
     // We don't take a reference to cachedFile here because the
     // loadArchiveMember() call below may recursively call addFile() and
     // invalidate this reference.
-    if (ArchiveFile *cachedFile = loadedArchives[path])
-      return cachedFile;
+    auto entry = loadedArchives.find(path);
+    if (entry != loadedArchives.end())
+      return entry->second;
 
     std::unique_ptr<object::Archive> archive = CHECK(
         object::Archive::create(mbref), path + ": failed to parse archive");
@@ -326,11 +327,9 @@ static InputFile *addFile(StringRef path, ForceLoad forceLoadArchive,
   case file_magic::macho_dynamically_linked_shared_lib:
   case file_magic::macho_dynamically_linked_shared_lib_stub:
   case file_magic::tapi_file:
-    if (DylibFile *dylibFile = loadDylib(mbref)) {
-      if (isExplicit)
-        dylibFile->explicitlyLinked = true;
+    if (DylibFile *dylibFile =
+            loadDylib(mbref, nullptr, /*isBundleLoader=*/false, isExplicit))
       newFile = dylibFile;
-    }
     break;
   case file_magic::bitcode:
     newFile = make<BitcodeFile>(mbref, "", 0, isLazy);
@@ -388,12 +387,17 @@ static void addLibrary(StringRef name, bool isNeeded, bool isWeak,
   error("library not found for -l" + name);
 }
 
+static DenseSet<StringRef> loadedObjectFrameworks;
 static void addFramework(StringRef name, bool isNeeded, bool isWeak,
                          bool isReexport, bool isExplicit,
                          ForceLoad forceLoadArchive) {
   if (Optional<StringRef> path = findFramework(name)) {
-    if (auto *dylibFile = dyn_cast_or_null<DylibFile>(
-            addFile(*path, forceLoadArchive, /*isLazy=*/false, isExplicit))) {
+    if (loadedObjectFrameworks.contains(*path))
+      return;
+
+    InputFile *file =
+        addFile(*path, forceLoadArchive, /*isLazy=*/false, isExplicit);
+    if (auto *dylibFile = dyn_cast_or_null<DylibFile>(file)) {
       if (isNeeded)
         dylibFile->forceNeeded = true;
       if (isWeak)
@@ -402,6 +406,14 @@ static void addFramework(StringRef name, bool isNeeded, bool isWeak,
         config->hasReexports = true;
         dylibFile->reexport = true;
       }
+    } else if (isa_and_nonnull<ObjFile>(file) ||
+               isa_and_nonnull<BitcodeFile>(file)) {
+      // Cache frameworks containing object or bitcode files to avoid duplicate
+      // symbols. Frameworks containing static archives are cached separately
+      // in addFile() to share caching with libraries, and frameworks
+      // containing dylibs should allow overwriting of attributes such as
+      // forceNeeded by subsequent loads
+      loadedObjectFrameworks.insert(*path);
     }
     return;
   }
@@ -447,20 +459,6 @@ static void addFileList(StringRef path, bool isLazy) {
     addFile(rerootPath(path), ForceLoad::Default, isLazy);
 }
 
-// An order file has one entry per line, in the following format:
-//
-//   <cpu>:<object file>:<symbol name>
-//
-// <cpu> and <object file> are optional. If not specified, then that entry
-// matches any symbol of that name. Parsing this format is not quite
-// straightforward because the symbol name itself can contain colons, so when
-// encountering a colon, we consider the preceding characters to decide if it
-// can be a valid CPU type or file path.
-//
-// If a symbol is matched by multiple entries, then it takes the lowest-ordered
-// entry (the one nearest to the front of the list.)
-//
-// The file can also have line comments that start with '#'.
 // We expect sub-library names of the form "libfoo", which will match a dylib
 // with a path of .*/libfoo.{dylib, tbd}.
 // XXX ld64 seems to ignore the extension entirely when matching sub-libraries;
@@ -492,14 +490,6 @@ static void initLLVM() {
 }
 
 static void compileBitcodeFiles() {
-  // FIXME: Remove this once LTO.cpp honors config->exportDynamic.
-  if (config->exportDynamic)
-    for (InputFile *file : inputFiles)
-      if (isa<BitcodeFile>(file)) {
-        warn("the effect of -export_dynamic on LTO is not yet implemented");
-        break;
-      }
-
   TimeTraceScope timeScope("LTO");
   auto *lto = make<BitcodeCompiler>();
   for (InputFile *file : inputFiles)
@@ -527,9 +517,11 @@ static void replaceCommonSymbols() {
     // but it's not really worth supporting the linking of 64-bit programs on
     // 32-bit archs.
     ArrayRef<uint8_t> data = {nullptr, static_cast<size_t>(common->size)};
-    auto *isec = make<ConcatInputSection>(
-        segment_names::data, section_names::common, common->getFile(), data,
-        common->align, S_ZEROFILL);
+    // FIXME avoid creating one Section per symbol?
+    auto *section =
+        make<Section>(common->getFile(), segment_names::data,
+                      section_names::common, S_ZEROFILL, /*addr=*/0);
+    auto *isec = make<ConcatInputSection>(*section, data, common->align);
     if (!osec)
       osec = ConcatOutputSection::getOrCreateForInput(isec);
     isec->parent = osec;
@@ -537,14 +529,11 @@ static void replaceCommonSymbols() {
 
     // FIXME: CommonSymbol should store isReferencedDynamically, noDeadStrip
     // and pass them on here.
-    replaceSymbol<Defined>(sym, sym->getName(), isec->getFile(), isec,
-                           /*value=*/0,
-                           /*size=*/0,
-                           /*isWeakDef=*/false,
-                           /*isExternal=*/true, common->privateExtern,
-                           /*isThumb=*/false,
-                           /*isReferencedDynamically=*/false,
-                           /*noDeadStrip=*/false);
+    replaceSymbol<Defined>(
+        sym, sym->getName(), common->getFile(), isec, /*value=*/0, /*size=*/0,
+        /*isWeakDef=*/false, /*isExternal=*/true, common->privateExtern,
+        /*includeInSymtab=*/true, /*isThumb=*/false,
+        /*isReferencedDynamically=*/false, /*noDeadStrip=*/false);
   }
 }
 
@@ -588,20 +577,22 @@ static std::string lowerDash(StringRef s) {
                      map_iterator(s.end(), toLowerDash));
 }
 
-// Has the side-effect of setting Config::platformInfo.
-static PlatformType parsePlatformVersion(const ArgList &args) {
-  const Arg *arg = args.getLastArg(OPT_platform_version);
-  if (!arg) {
-    error("must specify -platform_version");
-    return PLATFORM_UNKNOWN;
-  }
+struct PlatformVersion {
+  PlatformType platform = PLATFORM_UNKNOWN;
+  llvm::VersionTuple minimum;
+  llvm::VersionTuple sdk;
+};
 
+static PlatformVersion parsePlatformVersion(const Arg *arg) {
+  assert(arg->getOption().getID() == OPT_platform_version);
   StringRef platformStr = arg->getValue(0);
   StringRef minVersionStr = arg->getValue(1);
   StringRef sdkVersionStr = arg->getValue(2);
 
+  PlatformVersion platformVersion;
+
   // TODO(compnerd) see if we can generate this case list via XMACROS
-  PlatformType platform =
+  platformVersion.platform =
       StringSwitch<PlatformType>(lowerDash(platformStr))
           .Cases("macos", "1", PLATFORM_MACOS)
           .Cases("ios", "2", PLATFORM_IOS)
@@ -614,17 +605,67 @@ static PlatformType parsePlatformVersion(const ArgList &args) {
           .Cases("watchos-simulator", "9", PLATFORM_WATCHOSSIMULATOR)
           .Cases("driverkit", "10", PLATFORM_DRIVERKIT)
           .Default(PLATFORM_UNKNOWN);
-  if (platform == PLATFORM_UNKNOWN)
+  if (platformVersion.platform == PLATFORM_UNKNOWN)
     error(Twine("malformed platform: ") + platformStr);
   // TODO: check validity of version strings, which varies by platform
   // NOTE: ld64 accepts version strings with 5 components
   // llvm::VersionTuple accepts no more than 4 components
   // Has Apple ever published version strings with 5 components?
-  if (config->platformInfo.minimum.tryParse(minVersionStr))
+  if (platformVersion.minimum.tryParse(minVersionStr))
     error(Twine("malformed minimum version: ") + minVersionStr);
-  if (config->platformInfo.sdk.tryParse(sdkVersionStr))
+  if (platformVersion.sdk.tryParse(sdkVersionStr))
     error(Twine("malformed sdk version: ") + sdkVersionStr);
-  return platform;
+  return platformVersion;
+}
+
+// Has the side-effect of setting Config::platformInfo.
+static PlatformType parsePlatformVersions(const ArgList &args) {
+  std::map<PlatformType, PlatformVersion> platformVersions;
+  const PlatformVersion *lastVersionInfo = nullptr;
+  for (const Arg *arg : args.filtered(OPT_platform_version)) {
+    PlatformVersion version = parsePlatformVersion(arg);
+
+    // For each platform, the last flag wins:
+    // `-platform_version macos 2 3 -platform_version macos 4 5` has the same
+    // effect as just passing `-platform_version macos 4 5`.
+    // FIXME: ld64 warns on multiple flags for one platform. Should we?
+    platformVersions[version.platform] = version;
+    lastVersionInfo = &platformVersions[version.platform];
+  }
+
+  if (platformVersions.empty()) {
+    error("must specify -platform_version");
+    return PLATFORM_UNKNOWN;
+  }
+  if (platformVersions.size() > 2) {
+    error("must specify -platform_version at most twice");
+    return PLATFORM_UNKNOWN;
+  }
+  if (platformVersions.size() == 2) {
+    bool isZipperedCatalyst = platformVersions.count(PLATFORM_MACOS) &&
+                              platformVersions.count(PLATFORM_MACCATALYST);
+
+    if (!isZipperedCatalyst) {
+      error("lld supports writing zippered outputs only for "
+            "macos and mac-catalyst");
+    } else if (config->outputType != MH_DYLIB &&
+               config->outputType != MH_BUNDLE) {
+      error("writing zippered outputs only valid for -dylib and -bundle");
+    } else {
+      config->platformInfo.minimum = platformVersions[PLATFORM_MACOS].minimum;
+      config->platformInfo.sdk = platformVersions[PLATFORM_MACOS].sdk;
+      config->secondaryPlatformInfo = PlatformInfo{};
+      config->secondaryPlatformInfo->minimum =
+          platformVersions[PLATFORM_MACCATALYST].minimum;
+      config->secondaryPlatformInfo->sdk =
+          platformVersions[PLATFORM_MACCATALYST].sdk;
+    }
+    return PLATFORM_MACOS;
+  }
+
+  config->platformInfo.minimum = lastVersionInfo->minimum;
+  config->platformInfo.sdk = lastVersionInfo->sdk;
+  return lastVersionInfo->platform;
 }
 
 // Has the side-effect of setting Config::target.
@@ -635,9 +676,13 @@ static TargetInfo *createTargetInfo(InputArgList &args) {
     return nullptr;
   }
 
-  PlatformType platform = parsePlatformVersion(args);
+  PlatformType platform = parsePlatformVersions(args);
   config->platformInfo.target =
       MachO::Target(getArchitectureFromName(archName), platform);
+  if (config->secondaryPlatformInfo) {
+    config->secondaryPlatformInfo->target =
+        MachO::Target(getArchitectureFromName(archName), PLATFORM_MACCATALYST);
+  }
 
   uint32_t cpuType;
   uint32_t cpuSubtype;
@@ -695,9 +740,6 @@ static ICFLevel getICFLevel(const ArgList &args) {
     warn(Twine("unknown --icf=OPTION `") + icfLevelStr +
          "', defaulting to `none'");
     icfLevel = ICFLevel::none;
-  } else if (icfLevel == ICFLevel::safe) {
-    warn(Twine("`--icf=safe' is not yet implemented, reverting to `none'"));
-    icfLevel = ICFLevel::none;
   }
   return icfLevel;
 }
@@ -896,26 +938,30 @@ bool SymbolPatterns::match(StringRef symbolName) const {
   return matchLiteral(symbolName) || matchGlob(symbolName);
 }
 
+static void parseSymbolPatternsFile(const Arg *arg,
+                                    SymbolPatterns &symbolPatterns) {
+  StringRef path = arg->getValue();
+  Optional<MemoryBufferRef> buffer = readFile(path);
+  if (!buffer) {
+    error("Could not read symbol file: " + path);
+    return;
+  }
+  MemoryBufferRef mbref = *buffer;
+  for (StringRef line : args::getLines(mbref)) {
+    line = line.take_until([](char c) { return c == '#'; }).trim();
+    if (!line.empty())
+      symbolPatterns.insert(line);
+  }
+}
+
 static void handleSymbolPatterns(InputArgList &args,
                                  SymbolPatterns &symbolPatterns,
                                  unsigned singleOptionCode,
                                  unsigned listFileOptionCode) {
   for (const Arg *arg : args.filtered(singleOptionCode))
     symbolPatterns.insert(arg->getValue());
-  for (const Arg *arg : args.filtered(listFileOptionCode)) {
-    StringRef path = arg->getValue();
-    Optional<MemoryBufferRef> buffer = readFile(path);
-    if (!buffer) {
-      error("Could not read symbol file: " + path);
-      continue;
-    }
-    MemoryBufferRef mbref = *buffer;
-    for (StringRef line : args::getLines(mbref)) {
-      line = line.take_until([](char c) { return c == '#'; }).trim();
-      if (!line.empty())
-        symbolPatterns.insert(line);
-    }
-  }
+  for (const Arg *arg : args.filtered(listFileOptionCode))
+    parseSymbolPatternsFile(arg, symbolPatterns);
 }
 
 static void createFiles(const InputArgList &args) {
@@ -992,15 +1038,13 @@ static void gatherInputSections() {
   TimeTraceScope timeScope("Gathering input sections");
   int inputOrder = 0;
   for (const InputFile *file : inputFiles) {
-    for (const Section &section : file->sections) {
-      const Subsections &subsections = section.subsections;
-      if (subsections.empty())
-        continue;
-      if (subsections[0].isec->getName() == section_names::compactUnwind)
-        // Compact unwind entries require special handling elsewhere.
+    for (const Section *section : file->sections) {
+      // Compact unwind entries require special handling elsewhere. (In
+      // contrast, EH frames are handled like regular ConcatInputSections.)
+      if (section->name == section_names::compactUnwind)
         continue;
       ConcatOutputSection *osec = nullptr;
-      for (const Subsection &subsection : subsections) {
+      for (const Subsection &subsection : section->subsections) {
         if (auto *isec = dyn_cast<ConcatInputSection>(subsection.isec)) {
           if (isec->isCoalescedWeak())
             continue;
@@ -1069,6 +1113,7 @@ bool macho::link(ArrayRef<const char *> argsArr, llvm::raw_ostream &stdoutOS,
     inputFiles.clear();
     inputSections.clear();
     loadedArchives.clear();
+    loadedObjectFrameworks.clear();
     syntheticSections.clear();
     thunkMap.clear();
 
@@ -1107,12 +1152,34 @@ bool macho::link(ArrayRef<const char *> argsArr, llvm::raw_ostream &stdoutOS,
 
   config = std::make_unique<Configuration>();
   symtab = std::make_unique<SymbolTable>();
+  config->outputType = getOutputType(args);
   target = createTargetInfo(args);
   depTracker = std::make_unique<DependencyTracker>(
       args.getLastArgValue(OPT_dependency_info));
   if (errorCount())
     return false;
 
+  if (args.hasArg(OPT_pagezero_size)) {
+    uint64_t pagezeroSize = args::getHex(args, OPT_pagezero_size, 0);
+
+    // ld64 does something really weird. It attempts to realign the value to the
+    // page size, but assumes the the page size is 4K. This doesn't work with
+    // most of Apple's ARM64 devices, which use a page size of 16K. This means
+    // that it will first 4K align it by rounding down, then round up to 16K.
+    // This probably only happened because no one using this arg with anything
+    // other then 0, so no one checked if it did what is what it says it does.
+
+    // So we are not copying this weird behavior and doing the it in a logical
+    // way, by always rounding down to page size.
+    if (!isAligned(Align(target->getPageSize()), pagezeroSize)) {
+      pagezeroSize -= pagezeroSize % target->getPageSize();
+      warn("__PAGEZERO size is not page aligned, rounding down to 0x" +
+           Twine::utohexstr(pagezeroSize));
+    }
+
+    target->pageZeroSize = pagezeroSize;
+  }
+
   config->osoPrefix = args.getLastArgValue(OPT_oso_prefix);
   if (!config->osoPrefix.empty()) {
     // Expand special characters, such as ".", "..", or  "~", if present.
@@ -1192,7 +1259,6 @@ bool macho::link(ArrayRef<const char *> argsArr, llvm::raw_ostream &stdoutOS,
   config->printEachFile = args.hasArg(OPT_t);
   config->printWhyLoad = args.hasArg(OPT_why_load);
   config->omitDebugInfo = args.hasArg(OPT_S);
-  config->outputType = getOutputType(args);
   config->errorForArchMismatch = args.hasArg(OPT_arch_errors_fatal);
   if (const Arg *arg = args.getLastArg(OPT_bundle_loader)) {
     if (config->outputType != MH_BUNDLE)
@@ -1348,13 +1414,61 @@ bool macho::link(ArrayRef<const char *> argsArr, llvm::raw_ostream &stdoutOS,
           ">>> ignoring unexports");
     config->unexportedSymbols.clear();
   }
+
+  // Imitating LD64's:
+  // -non_global_symbols_no_strip_list and -non_global_symbols_strip_list can't
+  // both be present.
+  // But -x can be used with either of these two, in which case, the last arg
+  // takes effect.
+  // (TODO: This is kind of confusing - considering disallowing using them
+  // together for a more straightforward behaviour)
+  {
+    bool includeLocal = false;
+    bool excludeLocal = false;
+    for (const Arg *arg :
+         args.filtered(OPT_x, OPT_non_global_symbols_no_strip_list,
+                       OPT_non_global_symbols_strip_list)) {
+      switch (arg->getOption().getID()) {
+      case OPT_x:
+        config->localSymbolsPresence = SymtabPresence::None;
+        break;
+      case OPT_non_global_symbols_no_strip_list:
+        if (excludeLocal) {
+          error("cannot use both -non_global_symbols_no_strip_list and "
+                "-non_global_symbols_strip_list");
+        } else {
+          includeLocal = true;
+          config->localSymbolsPresence = SymtabPresence::SelectivelyIncluded;
+          parseSymbolPatternsFile(arg, config->localSymbolPatterns);
+        }
+        break;
+      case OPT_non_global_symbols_strip_list:
+        if (includeLocal) {
+          error("cannot use both -non_global_symbols_no_strip_list and "
+                "-non_global_symbols_strip_list");
+        } else {
+          excludeLocal = true;
+          config->localSymbolsPresence = SymtabPresence::SelectivelyExcluded;
+          parseSymbolPatternsFile(arg, config->localSymbolPatterns);
+        }
+        break;
+      default:
+        llvm_unreachable("unexpected option");
+      }
+    }
+  }
   // Explicitly-exported literal symbols must be defined, but might
-  // languish in an archive if unreferenced elsewhere. Light a fire
-  // under those lazy symbols!
+  // languish in an archive if unreferenced elsewhere or if they are in the
+  // non-global strip list. Light a fire under those lazy symbols!
   for (const CachedHashStringRef &cachedName : config->exportedSymbols.literals)
     symtab->addUndefined(cachedName.val(), /*file=*/nullptr,
                          /*isWeakRef=*/false);
 
+  for (const Arg *arg : args.filtered(OPT_why_live))
+    config->whyLive.insert(arg->getValue());
+  if (!config->whyLive.empty() && !config->deadStrip)
+    warn("-why_live has no effect without -dead_strip, ignoring");
+
   config->saveTemps = args.hasArg(OPT_save_temps);
 
   config->adhocCodesign = args.hasFlag(
@@ -1432,10 +1546,8 @@ bool macho::link(ArrayRef<const char *> argsArr, llvm::raw_ostream &stdoutOS,
     replaceCommonSymbols();
 
     StringRef orderFile = args.getLastArgValue(OPT_order_file);
-    if (!orderFile.empty()) {
-      parseOrderFile(orderFile);
-      config->callGraphProfileSort = false;
-    }
+    if (!orderFile.empty())
+      priorityBuilder.parseOrderFile(orderFile);
 
     referenceStubBinder();
 
@@ -1458,7 +1570,7 @@ bool macho::link(ArrayRef<const char *> argsArr, llvm::raw_ostream &stdoutOS,
                 // The former can be exported but the latter cannot.
                 defined->privateExtern = false;
               } else {
-                warn("cannot export hidden symbol " + symbolName +
+                warn("cannot export hidden symbol " + toString(*defined) +
                      "\n>>> defined in " + toString(defined->getFile()));
               }
             }
@@ -1492,7 +1604,7 @@ bool macho::link(ArrayRef<const char *> argsArr, llvm::raw_ostream &stdoutOS,
 
     gatherInputSections();
     if (config->callGraphProfileSort)
-      extractCallGraphProfile();
+      priorityBuilder.extractCallGraphProfile();
 
     if (config->deadStrip)
       markLive();
@@ -1500,8 +1612,11 @@ bool macho::link(ArrayRef<const char *> argsArr, llvm::raw_ostream &stdoutOS,
     // ICF assumes that all literals have been folded already, so we must run
     // foldIdenticalLiterals before foldIdenticalSections.
     foldIdenticalLiterals();
-    if (config->icfLevel != ICFLevel::none)
+    if (config->icfLevel != ICFLevel::none) {
+      if (config->icfLevel == ICFLevel::safe)
+        markAddrSigSymbols();
       foldIdenticalSections();
+    }
 
     // Write to an output file.
     if (target->wordSize == 8)
diff --git a/lld/MachO/Driver.h b/lld/MachO/Driver.h
index dbfc05a0497cf..355816272f87d 100644
--- a/lld/MachO/Driver.h
+++ b/lld/MachO/Driver.h
@@ -49,7 +49,8 @@ std::string createResponseFile(const llvm::opt::InputArgList &args);
 llvm::Optional<StringRef> resolveDylibPath(llvm::StringRef path);
 
 DylibFile *loadDylib(llvm::MemoryBufferRef mbref, DylibFile *umbrella = nullptr,
-                     bool isBundleLoader = false);
+                     bool isBundleLoader = false,
+                     bool explicitlyLinked = false);
 void resetLoadedDylibs();
 
 // Search for all possible combinations of `{root}/{name}.{extension}`.
diff --git a/lld/MachO/DriverUtils.cpp b/lld/MachO/DriverUtils.cpp
index 83940b54486ff..b52d5e851c62d 100644
--- a/lld/MachO/DriverUtils.cpp
+++ b/lld/MachO/DriverUtils.cpp
@@ -87,6 +87,7 @@ InputArgList MachOOptTable::parse(ArrayRef<const char *> argv) {
   // Handle -fatal_warnings early since it converts missing argument warnings
   // to errors.
   errorHandler().fatalWarnings = args.hasArg(OPT_fatal_warnings);
+  errorHandler().suppressWarnings = args.hasArg(OPT_w);
 
   if (missingCount)
     error(Twine(args.getArgString(missingIndex)) + ": missing argument");
@@ -204,11 +205,14 @@ Optional<StringRef> macho::resolveDylibPath(StringRef dylibPath) {
 static DenseMap<CachedHashStringRef, DylibFile *> loadedDylibs;
 
 DylibFile *macho::loadDylib(MemoryBufferRef mbref, DylibFile *umbrella,
-                            bool isBundleLoader) {
+                            bool isBundleLoader, bool explicitlyLinked) {
   CachedHashStringRef path(mbref.getBufferIdentifier());
   DylibFile *&file = loadedDylibs[path];
-  if (file)
+  if (file) {
+    if (explicitlyLinked)
+      file->explicitlyLinked = explicitlyLinked;
     return file;
+  }
 
   DylibFile *newFile;
   file_magic magic = identify_magic(mbref.getBuffer());
@@ -219,7 +223,8 @@ DylibFile *macho::loadDylib(MemoryBufferRef mbref, DylibFile *umbrella,
             ": " + toString(result.takeError()));
       return nullptr;
     }
-    file = make<DylibFile>(**result, umbrella, isBundleLoader);
+    file =
+        make<DylibFile>(**result, umbrella, isBundleLoader, explicitlyLinked);
 
     // parseReexports() can recursively call loadDylib(). That's fine since
     // we wrote the DylibFile we just loaded to the loadDylib cache via the
@@ -234,7 +239,7 @@ DylibFile *macho::loadDylib(MemoryBufferRef mbref, DylibFile *umbrella,
            magic == file_magic::macho_dynamically_linked_shared_lib_stub ||
            magic == file_magic::macho_executable ||
            magic == file_magic::macho_bundle);
-    file = make<DylibFile>(mbref, umbrella, isBundleLoader);
+    file = make<DylibFile>(mbref, umbrella, isBundleLoader, explicitlyLinked);
 
     // parseLoadCommands() can also recursively call loadDylib(). See comment
     // in previous block for why this means we must copy `file` here.
diff --git a/lld/MachO/EhFrame.cpp b/lld/MachO/EhFrame.cpp
new file mode 100644
index 0000000000000..55a85f316cdd7
--- /dev/null
+++ b/lld/MachO/EhFrame.cpp
@@ -0,0 +1,140 @@
+//===- EhFrame.cpp --------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "EhFrame.h"
+#include "InputFiles.h"
+
+#include "lld/Common/ErrorHandler.h"
+#include "llvm/BinaryFormat/Dwarf.h"
+#include "llvm/Support/Endian.h"
+
+using namespace llvm;
+using namespace lld;
+using namespace lld::macho;
+using namespace llvm::support::endian;
+
+uint64_t EhReader::readLength(size_t *off) const {
+  const size_t errOff = *off;
+  if (*off + 4 > data.size())
+    failOn(errOff, "CIE/FDE too small");
+  uint64_t len = read32le(data.data() + *off);
+  *off += 4;
+  if (len == dwarf::DW_LENGTH_DWARF64) {
+    // FIXME: test this DWARF64 code path
+    if (*off + 8 > data.size())
+      failOn(errOff, "CIE/FDE too small");
+    len = read64le(data.data() + *off);
+    *off += 8;
+  }
+  if (*off + len > data.size())
+    failOn(errOff, "CIE/FDE extends past the end of the section");
+  return len;
+}
+
+void EhReader::skipValidLength(size_t *off) const {
+  uint32_t len = read32le(data.data() + *off);
+  *off += 4;
+  if (len == dwarf::DW_LENGTH_DWARF64)
+    *off += 8;
+}
+
+// Read a byte and advance off by one byte.
+uint8_t EhReader::readByte(size_t *off) const {
+  if (*off + 1 > data.size())
+    failOn(*off, "unexpected end of CIE/FDE");
+  return data[(*off)++];
+}
+
+uint32_t EhReader::readU32(size_t *off) const {
+  if (*off + 4 > data.size())
+    failOn(*off, "unexpected end of CIE/FDE");
+  uint32_t v = read32le(data.data() + *off);
+  *off += 4;
+  return v;
+}
+
+uint64_t EhReader::readPointer(size_t *off, uint8_t size) const {
+  if (*off + size > data.size())
+    failOn(*off, "unexpected end of CIE/FDE");
+  uint64_t v;
+  if (size == 8)
+    v = read64le(data.data() + *off);
+  else {
+    assert(size == 4);
+    v = read32le(data.data() + *off);
+  }
+  *off += size;
+  return v;
+}
+
+// Read a null-terminated string.
+StringRef EhReader::readString(size_t *off) const {
+  if (*off > data.size())
+    failOn(*off, "corrupted CIE (failed to read string)");
+  const size_t maxlen = data.size() - *off;
+  auto *c = reinterpret_cast<const char *>(data.data() + *off);
+  size_t len = strnlen(c, maxlen);
+  if (len == maxlen) // we failed to find the null terminator
+    failOn(*off, "corrupted CIE (failed to read string)");
+  *off += len + 1; // skip the null byte too
+  return StringRef(c, len);
+}
+
+void EhReader::skipLeb128(size_t *off) const {
+  const size_t errOff = *off;
+  while (*off < data.size()) {
+    uint8_t val = data[(*off)++];
+    if ((val & 0x80) == 0)
+      return;
+  }
+  failOn(errOff, "corrupted CIE (failed to read LEB128)");
+}
+
+void EhReader::failOn(size_t errOff, const Twine &msg) const {
+  fatal(toString(file) + ":(__eh_frame+0x" +
+        Twine::utohexstr(dataOff + errOff) + "): " + msg);
+}
+
+/*
+ * Create a pair of relocs to write the value of:
+ *   `b - (offset + a)` if Invert == false
+ *   `(a + offset) - b` if Invert == true
+ */
+template <bool Invert = false>
+static void createSubtraction(PointerUnion<Symbol *, InputSection *> a,
+                              PointerUnion<Symbol *, InputSection *> b,
+                              uint64_t off, uint8_t length,
+                              SmallVectorImpl<Reloc> *newRelocs) {
+  auto subtrahend = a;
+  auto minuend = b;
+  if (Invert)
+    std::swap(subtrahend, minuend);
+  assert(subtrahend.is<Symbol *>());
+  Reloc subtrahendReloc(target->subtractorRelocType, /*pcrel=*/false, length,
+                        off, /*addend=*/0, subtrahend);
+  Reloc minuendReloc(target->unsignedRelocType, /*pcrel=*/false, length, off,
+                     (Invert ? 1 : -1) * off, minuend);
+  newRelocs->push_back(subtrahendReloc);
+  newRelocs->push_back(minuendReloc);
+}
+
+void EhRelocator::makePcRel(uint64_t off,
+                            PointerUnion<Symbol *, InputSection *> target,
+                            uint8_t length) {
+  createSubtraction(isec->symbols[0], target, off, length, &newRelocs);
+}
+
+void EhRelocator::makeNegativePcRel(
+    uint64_t off, PointerUnion<Symbol *, InputSection *> target,
+    uint8_t length) {
+  createSubtraction</*Invert=*/true>(isec, target, off, length, &newRelocs);
+}
+
+void EhRelocator::commit() {
+  isec->relocs.insert(isec->relocs.end(), newRelocs.begin(), newRelocs.end());
+}
diff --git a/lld/MachO/EhFrame.h b/lld/MachO/EhFrame.h
new file mode 100644
index 0000000000000..609a3bb8b1fe3
--- /dev/null
+++ b/lld/MachO/EhFrame.h
@@ -0,0 +1,118 @@
+//===- EhFrame.h ------------------------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLD_MACHO_EH_FRAME_H
+#define LLD_MACHO_EH_FRAME_H
+
+#include "InputSection.h"
+#include "Relocations.h"
+
+#include "lld/Common/LLVM.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/PointerUnion.h"
+#include "llvm/ADT/SmallVector.h"
+
+/*
+ * NOTE: The main bulk of the EH frame parsing logic is in InputFiles.cpp as it
+ * is closely coupled with other file parsing logic; EhFrame.h just contains a
+ * few helpers.
+ */
+
+/*
+ * === The EH frame format ===
+ *
+ * EH frames can either be Common Information Entries (CIEs) or Frame
+ * Description Entries (FDEs). CIEs contain information that is common amongst
+ * several FDEs. Each FDE contains a pointer to its CIE. Thus all the EH frame
+ * entries together form a forest of two-level trees, with CIEs as the roots
+ * and FDEs as the leaves. Note that a CIE must precede the FDEs which point
+ * to it.
+ *
+ * A CIE comprises the following fields in order:
+ * 1.   Length of the entry (4 or 12 bytes)
+ * 2.   CIE offset (4 bytes; always 0 for CIEs)
+ * 3.   CIE version (byte)
+ * 4.   Null-terminated augmentation string
+ * 5-8. LEB128 values that we don't care about
+ * 9.   Augmentation data, to be interpreted using the aug string
+ * 10.  DWARF instructions (ignored by LLD)
+ *
+ * An FDE comprises of the following:
+ * 1. Length of the entry (4 or 12 bytes)
+ * 2. CIE offset (4 bytes pcrel offset that points backwards to this FDE's CIE)
+ * 3. Function address (pointer-sized pcrel offset)
+ * 4. (Optional) Augmentation data length
+ * 5. (Optional) LSDA address (pointer-sized pcrel offset)
+ * 6. DWARF instructions (ignored by LLD)
+ */
+namespace lld {
+namespace macho {
+
+class EhReader {
+public:
+  EhReader(const ObjFile *file, ArrayRef<uint8_t> data, size_t dataOff)
+      : file(file), data(data), dataOff(dataOff) {}
+  size_t size() const { return data.size(); }
+  // Read and validate the length field.
+  uint64_t readLength(size_t *off) const;
+  // Skip the length field without doing validation.
+  void skipValidLength(size_t *off) const;
+  uint8_t readByte(size_t *off) const;
+  uint32_t readU32(size_t *off) const;
+  uint64_t readPointer(size_t *off, uint8_t size) const;
+  StringRef readString(size_t *off) const;
+  void skipLeb128(size_t *off) const;
+  void failOn(size_t errOff, const Twine &msg) const;
+
+private:
+  const ObjFile *file;
+  ArrayRef<uint8_t> data;
+  // The offset of the data array within its section. Used only for error
+  // reporting.
+  const size_t dataOff;
+};
+
+// The EH frame format, when emitted by llvm-mc, consists of a number of
+// "abs-ified" relocations, i.e. relocations that are implicitly encoded as
+// pcrel offsets in the section data. The offsets refer to the locations of
+// symbols in the input object file. When we ingest these EH frames, we convert
+// these implicit relocations into explicit Relocs.
+//
+// These pcrel relocations are semantically similar to X86_64_RELOC_SIGNED_4.
+// However, we need this operation to be cross-platform, and ARM does not have a
+// similar relocation that is applicable. We therefore use the more verbose (but
+// more generic) subtractor relocation to encode these pcrel values. ld64
+// appears to do something similar -- its `-r` output contains these explicit
+// subtractor relocations.
+class EhRelocator {
+public:
+  EhRelocator(InputSection *isec) : isec(isec) {}
+
+  // For the next two methods, let `PC` denote `isec address + off`.
+  // Create relocs writing the value of target - PC to PC.
+  void makePcRel(uint64_t off,
+                 llvm::PointerUnion<Symbol *, InputSection *> target,
+                 uint8_t length);
+  // Create relocs writing the value of PC - target to PC.
+  void makeNegativePcRel(uint64_t off,
+                         llvm::PointerUnion<Symbol *, InputSection *> target,
+                         uint8_t length);
+  // Insert the new relocations into isec->relocs.
+  void commit();
+
+private:
+  InputSection *isec;
+  // Insert new relocs here so that we don't invalidate iterators into the
+  // existing relocs vector.
+  SmallVector<Reloc, 6> newRelocs;
+};
+
+} // namespace macho
+} // namespace lld
+
+#endif
diff --git a/lld/MachO/ExportTrie.cpp b/lld/MachO/ExportTrie.cpp
index 372690a20df67..b95ad9be009e3 100644
--- a/lld/MachO/ExportTrie.cpp
+++ b/lld/MachO/ExportTrie.cpp
@@ -145,8 +145,13 @@ void TrieNode::writeTo(uint8_t *buf) const {
   }
 }
 
+TrieBuilder::~TrieBuilder() {
+  for (TrieNode *node : nodes)
+    delete node;
+}
+
 TrieNode *TrieBuilder::makeNode() {
-  auto *node = make<TrieNode>();
+  auto *node = new TrieNode();
   nodes.emplace_back(node);
   return node;
 }
diff --git a/lld/MachO/ExportTrie.h b/lld/MachO/ExportTrie.h
index a43f4f2cce98b..0675d8257a2a6 100644
--- a/lld/MachO/ExportTrie.h
+++ b/lld/MachO/ExportTrie.h
@@ -22,6 +22,7 @@ class Symbol;
 
 class TrieBuilder {
 public:
+  ~TrieBuilder();
   void setImageBase(uint64_t addr) { imageBase = addr; }
   void addSymbol(const Symbol &sym) { exported.push_back(&sym); }
   // Returns the size in bytes of the serialized trie.
diff --git a/lld/MachO/ICF.cpp b/lld/MachO/ICF.cpp
index f9dea4b861ac3..6d10262826e54 100644
--- a/lld/MachO/ICF.cpp
+++ b/lld/MachO/ICF.cpp
@@ -8,12 +8,17 @@
 
 #include "ICF.h"
 #include "ConcatOutputSection.h"
+#include "Config.h"
 #include "InputSection.h"
+#include "SymbolTable.h"
 #include "Symbols.h"
 #include "UnwindInfoSection.h"
 
+#include "lld/Common/CommonLinkerContext.h"
+#include "llvm/Support/LEB128.h"
 #include "llvm/Support/Parallel.h"
 #include "llvm/Support/TimeProfiler.h"
+#include "llvm/Support/xxhash.h"
 
 #include <atomic>
 
@@ -21,23 +26,34 @@ using namespace llvm;
 using namespace lld;
 using namespace lld::macho;
 
+static constexpr bool verboseDiagnostics = false;
+
 class ICF {
 public:
   ICF(std::vector<ConcatInputSection *> &inputs);
-
   void run();
-  void segregate(size_t begin, size_t end,
-                 std::function<bool(const ConcatInputSection *,
-                                    const ConcatInputSection *)>
-                     equals);
+
+  using EqualsFn = bool (ICF::*)(const ConcatInputSection *,
+                                 const ConcatInputSection *);
+  void segregate(size_t begin, size_t end, EqualsFn);
   size_t findBoundary(size_t begin, size_t end);
   void forEachClassRange(size_t begin, size_t end,
-                         std::function<void(size_t, size_t)> func);
-  void forEachClass(std::function<void(size_t, size_t)> func);
+                         llvm::function_ref<void(size_t, size_t)> func);
+  void forEachClass(llvm::function_ref<void(size_t, size_t)> func);
+
+  bool equalsConstant(const ConcatInputSection *ia,
+                      const ConcatInputSection *ib);
+  bool equalsVariable(const ConcatInputSection *ia,
+                      const ConcatInputSection *ib);
 
   // ICF needs a copy of the inputs vector because its equivalence-class
   // segregation algorithm destroys the proper sequence.
   std::vector<ConcatInputSection *> icfInputs;
+
+  unsigned icfPass = 0;
+  std::atomic<bool> icfRepeat{false};
+  std::atomic<uint64_t> equalsConstantCount{0};
+  std::atomic<uint64_t> equalsVariableCount{0};
 };
 
 ICF::ICF(std::vector<ConcatInputSection *> &inputs) {
@@ -74,13 +90,12 @@ ICF::ICF(std::vector<ConcatInputSection *> &inputs) {
 // FIXME(gkm): implement keep-unique attributes
 // FIXME(gkm): implement address-significance tables for MachO object files
 
-static unsigned icfPass = 0;
-static std::atomic<bool> icfRepeat{false};
-
 // Compare "non-moving" parts of two ConcatInputSections, namely everything
 // except references to other ConcatInputSections.
-static bool equalsConstant(const ConcatInputSection *ia,
-                           const ConcatInputSection *ib) {
+bool ICF::equalsConstant(const ConcatInputSection *ia,
+                         const ConcatInputSection *ib) {
+  if (verboseDiagnostics)
+    ++equalsConstantCount;
   // We can only fold within the same OutputSection.
   if (ia->parent != ib->parent)
     return false;
@@ -99,8 +114,6 @@ static bool equalsConstant(const ConcatInputSection *ia,
       return false;
     if (ra.offset != rb.offset)
       return false;
-    if (ra.addend != rb.addend)
-      return false;
     if (ra.referent.is<Symbol *>() != rb.referent.is<Symbol *>())
       return false;
 
@@ -113,16 +126,16 @@ static bool equalsConstant(const ConcatInputSection *ia,
       const auto *sb = rb.referent.get<Symbol *>();
       if (sa->kind() != sb->kind())
         return false;
-      if (!isa<Defined>(sa)) {
-        // ICF runs before Undefineds are reported.
-        assert(isa<DylibSymbol>(sa) || isa<Undefined>(sa));
-        return sa == sb;
-      }
+      // ICF runs before Undefineds are treated (and potentially converted into
+      // DylibSymbols).
+      if (isa<DylibSymbol>(sa) || isa<Undefined>(sa))
+        return sa == sb && ra.addend == rb.addend;
+      assert(isa<Defined>(sa));
       const auto *da = cast<Defined>(sa);
       const auto *db = cast<Defined>(sb);
       if (!da->isec || !db->isec) {
         assert(da->isAbsolute() && db->isAbsolute());
-        return da->value == db->value;
+        return da->value + ra.addend == db->value + rb.addend;
       }
       isecA = da->isec;
       valueA = da->value;
@@ -139,11 +152,20 @@ static bool equalsConstant(const ConcatInputSection *ia,
     assert(isecA->kind() == isecB->kind());
     // We will compare ConcatInputSection contents in equalsVariable.
     if (isa<ConcatInputSection>(isecA))
-      return true;
+      return ra.addend == rb.addend;
     // Else we have two literal sections. References to them are equal iff their
     // offsets in the output section are equal.
-    return isecA->getOffset(valueA + ra.addend) ==
-           isecB->getOffset(valueB + rb.addend);
+    if (ra.referent.is<Symbol *>())
+      // For symbol relocs, we compare the contents at the symbol address. We
+      // don't do `getOffset(value + addend)` because value + addend may not be
+      // a valid offset in the literal section.
+      return isecA->getOffset(valueA) == isecB->getOffset(valueB) &&
+             ra.addend == rb.addend;
+    else {
+      assert(valueA == 0 && valueB == 0);
+      // For section relocs, we compare the content at the section offset.
+      return isecA->getOffset(ra.addend) == isecB->getOffset(rb.addend);
+    }
   };
   return std::equal(ia->relocs.begin(), ia->relocs.end(), ib->relocs.begin(),
                     f);
@@ -151,10 +173,12 @@ static bool equalsConstant(const ConcatInputSection *ia,
 
 // Compare the "moving" parts of two ConcatInputSections -- i.e. everything not
 // handled by equalsConstant().
-static bool equalsVariable(const ConcatInputSection *ia,
-                           const ConcatInputSection *ib) {
+bool ICF::equalsVariable(const ConcatInputSection *ia,
+                         const ConcatInputSection *ib) {
+  if (verboseDiagnostics)
+    ++equalsVariableCount;
   assert(ia->relocs.size() == ib->relocs.size());
-  auto f = [](const Reloc &ra, const Reloc &rb) {
+  auto f = [this](const Reloc &ra, const Reloc &rb) {
     // We already filtered out mismatching values/addends in equalsConstant.
     if (ra.referent == rb.referent)
       return true;
@@ -188,9 +212,9 @@ static bool equalsVariable(const ConcatInputSection *ia,
   // info matches. For simplicity, we only handle the case where there are only
   // symbols at offset zero within the section (which is typically the case with
   // .subsections_via_symbols.)
-  auto hasCU = [](Defined *d) { return d->unwindEntry != nullptr; };
-  auto itA = std::find_if(ia->symbols.begin(), ia->symbols.end(), hasCU);
-  auto itB = std::find_if(ib->symbols.begin(), ib->symbols.end(), hasCU);
+  auto hasUnwind = [](Defined *d) { return d->unwindEntry != nullptr; };
+  auto itA = std::find_if(ia->symbols.begin(), ia->symbols.end(), hasUnwind);
+  auto itB = std::find_if(ib->symbols.begin(), ib->symbols.end(), hasUnwind);
   if (itA == ia->symbols.end())
     return itB == ib->symbols.end();
   if (itB == ib->symbols.end())
@@ -219,7 +243,7 @@ size_t ICF::findBoundary(size_t begin, size_t end) {
 
 // Invoke FUNC on subranges with matching equivalence class
 void ICF::forEachClassRange(size_t begin, size_t end,
-                            std::function<void(size_t, size_t)> func) {
+                            llvm::function_ref<void(size_t, size_t)> func) {
   while (begin < end) {
     size_t mid = findBoundary(begin, end);
     func(begin, mid);
@@ -229,7 +253,7 @@ void ICF::forEachClassRange(size_t begin, size_t end,
 
 // Split icfInputs into shards, then parallelize invocation of FUNC on subranges
 // with matching equivalence class
-void ICF::forEachClass(std::function<void(size_t, size_t)> func) {
+void ICF::forEachClass(llvm::function_ref<void(size_t, size_t)> func) {
   // Only use threads when the benefits outweigh the overhead.
   const size_t threadingThreshold = 1024;
   if (icfInputs.size() < threadingThreshold) {
@@ -261,27 +285,28 @@ void ICF::run() {
   // Into each origin-section hash, combine all reloc referent section hashes.
   for (icfPass = 0; icfPass < 2; ++icfPass) {
     parallelForEach(icfInputs, [&](ConcatInputSection *isec) {
-      uint64_t hash = isec->icfEqClass[icfPass % 2];
+      uint32_t hash = isec->icfEqClass[icfPass % 2];
       for (const Reloc &r : isec->relocs) {
         if (auto *sym = r.referent.dyn_cast<Symbol *>()) {
-          if (auto *dylibSym = dyn_cast<DylibSymbol>(sym))
-            hash += dylibSym->stubsHelperIndex;
-          else if (auto *defined = dyn_cast<Defined>(sym)) {
+          if (auto *defined = dyn_cast<Defined>(sym)) {
             if (defined->isec) {
-              if (auto isec = dyn_cast<ConcatInputSection>(defined->isec))
-                hash += defined->value + isec->icfEqClass[icfPass % 2];
+              if (auto referentIsec =
+                      dyn_cast<ConcatInputSection>(defined->isec))
+                hash += defined->value + referentIsec->icfEqClass[icfPass % 2];
               else
                 hash += defined->isec->kind() +
                         defined->isec->getOffset(defined->value);
             } else {
               hash += defined->value;
             }
-          } else if (!isa<Undefined>(sym)) // ICF runs before Undefined diags.
-            llvm_unreachable("foldIdenticalSections symbol kind");
+          } else {
+            // ICF runs before Undefined diags
+            assert(isa<Undefined>(sym) || isa<DylibSymbol>(sym));
+          }
         }
       }
       // Set MSB to 1 to avoid collisions with non-hashed classes.
-      isec->icfEqClass[(icfPass + 1) % 2] = hash | (1ull << 63);
+      isec->icfEqClass[(icfPass + 1) % 2] = hash | (1ull << 31);
     });
   }
 
@@ -289,17 +314,22 @@ void ICF::run() {
       icfInputs, [](const ConcatInputSection *a, const ConcatInputSection *b) {
         return a->icfEqClass[0] < b->icfEqClass[0];
       });
-  forEachClass(
-      [&](size_t begin, size_t end) { segregate(begin, end, equalsConstant); });
+  forEachClass([&](size_t begin, size_t end) {
+    segregate(begin, end, &ICF::equalsConstant);
+  });
 
   // Split equivalence groups by comparing relocations until convergence
   do {
     icfRepeat = false;
     forEachClass([&](size_t begin, size_t end) {
-      segregate(begin, end, equalsVariable);
+      segregate(begin, end, &ICF::equalsVariable);
     });
   } while (icfRepeat);
   log("ICF needed " + Twine(icfPass) + " iterations");
+  if (verboseDiagnostics) {
+    log("equalsConstant() called " + Twine(equalsConstantCount) + " times");
+    log("equalsVariable() called " + Twine(equalsVariableCount) + " times");
+  }
 
   // Fold sections within equivalence classes
   forEachClass([&](size_t begin, size_t end) {
@@ -312,18 +342,15 @@ void ICF::run() {
 }
 
 // Split an equivalence class into smaller classes.
-void ICF::segregate(
-    size_t begin, size_t end,
-    std::function<bool(const ConcatInputSection *, const ConcatInputSection *)>
-        equals) {
+void ICF::segregate(size_t begin, size_t end, EqualsFn equals) {
   while (begin < end) {
     // Divide [begin, end) into two. Let mid be the start index of the
     // second group.
-    auto bound = std::stable_partition(icfInputs.begin() + begin + 1,
-                                       icfInputs.begin() + end,
-                                       [&](ConcatInputSection *isec) {
-                                         return equals(icfInputs[begin], isec);
-                                       });
+    auto bound = std::stable_partition(
+        icfInputs.begin() + begin + 1, icfInputs.begin() + end,
+        [&](ConcatInputSection *isec) {
+          return (this->*equals)(icfInputs[begin], isec);
+        });
     size_t mid = bound - icfInputs.begin();
 
     // Split [begin, end) into [begin, mid) and [mid, end). We use mid as an
@@ -339,6 +366,39 @@ void ICF::segregate(
   }
 }
 
+void macho::markSymAsAddrSig(Symbol *s) {
+  if (auto *d = dyn_cast_or_null<Defined>(s))
+    if (d->isec)
+      d->isec->keepUnique = true;
+}
+
+void macho::markAddrSigSymbols() {
+  for (InputFile *file : inputFiles) {
+    ObjFile *obj = dyn_cast<ObjFile>(file);
+    if (!obj)
+      continue;
+
+    Section *addrSigSection = obj->addrSigSection;
+    if (!addrSigSection)
+      continue;
+    assert(addrSigSection->subsections.size() == 1);
+
+    Subsection *subSection = &addrSigSection->subsections[0];
+    ArrayRef<unsigned char> &contents = subSection->isec->data;
+
+    const uint8_t *pData = contents.begin();
+    while (pData != contents.end()) {
+      unsigned size;
+      const char *err;
+      uint32_t symIndex = decodeULEB128(pData, &size, contents.end(), &err);
+      if (err)
+        fatal(toString(file) + ": could not decode addrsig section: " + err);
+      markSymAsAddrSig(obj->symbols[symIndex]);
+      pData += size;
+    }
+  }
+}
+
 void macho::foldIdenticalSections() {
   TimeTraceScope timeScope("Fold Identical Code Sections");
   // The ICF equivalence-class segregation algorithm relies on pre-computed
@@ -359,19 +419,42 @@ void macho::foldIdenticalSections() {
   uint64_t icfUniqueID = inputSections.size();
   for (ConcatInputSection *isec : inputSections) {
     // FIXME: consider non-code __text sections as hashable?
-    bool isHashable = (isCodeSection(isec) || isCfStringSection(isec)) &&
-                      !isec->shouldOmitFromOutput() && isec->isHashableForICF();
+    bool isHashable = (isCodeSection(isec) || isCfStringSection(isec) ||
+                       isClassRefsSection(isec)) &&
+                      !isec->keepUnique && !isec->shouldOmitFromOutput() &&
+                      sectionType(isec->getFlags()) == MachO::S_REGULAR;
     if (isHashable) {
       hashable.push_back(isec);
       for (Defined *d : isec->symbols)
         if (d->unwindEntry)
           hashable.push_back(d->unwindEntry);
-    } else {
+
+      // __cfstring has embedded addends that foil ICF's hashing / equality
+      // checks. (We can ignore embedded addends when doing ICF because the same
+      // information gets recorded in our Reloc structs.) We therefore create a
+      // mutable copy of the CFString and zero out the embedded addends before
+      // performing any hashing / equality checks.
+      if (isCfStringSection(isec) || isClassRefsSection(isec)) {
+        // We have to do this copying serially as the BumpPtrAllocator is not
+        // thread-safe. FIXME: Make a thread-safe allocator.
+        MutableArrayRef<uint8_t> copy = isec->data.copy(bAlloc());
+        for (const Reloc &r : isec->relocs)
+          target->relocateOne(copy.data() + r.offset, r, /*va=*/0,
+                              /*relocVA=*/0);
+        isec->data = copy;
+      }
+    } else if (!isEhFrameSection(isec)) {
+      // EH frames are gathered as hashables from unwindEntry above; give a
+      // unique ID to everything else.
       isec->icfEqClass[0] = ++icfUniqueID;
     }
   }
-  parallelForEach(hashable,
-                  [](ConcatInputSection *isec) { isec->hashForICF(); });
+  parallelForEach(hashable, [](ConcatInputSection *isec) {
+    assert(isec->icfEqClass[0] == 0); // don't overwrite a unique ID!
+    // Turn-on the top bit to guarantee that valid hashes have no collisions
+    // with the small-integer unique IDs for ICF-ineligible sections
+    isec->icfEqClass[0] = xxHash64(isec->data) | (1ull << 31);
+  });
   // Now that every input section is either hashed or marked as unique, run the
   // segregation algorithm to detect foldable subsections.
   ICF(hashable).run();
diff --git a/lld/MachO/ICF.h b/lld/MachO/ICF.h
index 9500a946601ea..a287692d7ffa0 100644
--- a/lld/MachO/ICF.h
+++ b/lld/MachO/ICF.h
@@ -9,12 +9,16 @@
 #ifndef LLD_MACHO_ICF_H
 #define LLD_MACHO_ICF_H
 
+#include "InputFiles.h"
 #include "lld/Common/LLVM.h"
 #include <vector>
 
 namespace lld {
 namespace macho {
+class Symbol;
 
+void markAddrSigSymbols();
+void markSymAsAddrSig(Symbol *s);
 void foldIdenticalSections();
 
 } // namespace macho
diff --git a/lld/MachO/InputFiles.cpp b/lld/MachO/InputFiles.cpp
index bbeb2dc09bf0f..41dd1482250d5 100644
--- a/lld/MachO/InputFiles.cpp
+++ b/lld/MachO/InputFiles.cpp
@@ -45,6 +45,7 @@
 #include "Config.h"
 #include "Driver.h"
 #include "Dwarf.h"
+#include "EhFrame.h"
 #include "ExportTrie.h"
 #include "InputSection.h"
 #include "MachOStructs.h"
@@ -95,6 +96,10 @@ std::string lld::toString(const InputFile *f) {
   return (f->archiveName + "(" + path::filename(f->getName()) + ")").str();
 }
 
+std::string lld::toString(const Section &sec) {
+  return (toString(sec.file) + ":(" + sec.name + ")").str();
+}
+
 SetVector<InputFile *> macho::inputFiles;
 std::unique_ptr<TarWriter> macho::tar;
 int InputFile::idCount = 0;
@@ -112,6 +117,7 @@ static std::vector<PlatformInfo> getPlatformInfos(const InputFile *input) {
 
   const char *hdr = input->mb.getBufferStart();
 
+  // "Zippered" object files can have multiple LC_BUILD_VERSION load commands.
   std::vector<PlatformInfo> platformInfos;
   for (auto *cmd : findCommands<build_version_command>(hdr, LC_BUILD_VERSION)) {
     PlatformInfo info;
@@ -252,16 +258,38 @@ InputFile::InputFile(Kind kind, const InterfaceFile &interface)
 // Note that "record" is a term I came up with. In contrast, "literal" is a term
 // used by the Mach-O format.
 static Optional<size_t> getRecordSize(StringRef segname, StringRef name) {
-  if (name == section_names::cfString) {
-    if (config->icfLevel != ICFLevel::none && segname == segment_names::data)
-      return target->wordSize == 8 ? 32 : 16;
-  } else if (name == section_names::compactUnwind) {
+  if (name == section_names::compactUnwind) {
     if (segname == segment_names::ld)
       return target->wordSize == 8 ? 32 : 20;
   }
+  if (config->icfLevel == ICFLevel::none)
+    return {};
+
+  if (name == section_names::cfString && segname == segment_names::data)
+    return target->wordSize == 8 ? 32 : 16;
+  if (name == section_names::objcClassRefs && segname == segment_names::data)
+    return target->wordSize;
   return {};
 }
 
+static Error parseCallGraph(ArrayRef<uint8_t> data,
+                            std::vector<CallGraphEntry> &callGraph) {
+  TimeTraceScope timeScope("Parsing call graph section");
+  BinaryStreamReader reader(data, support::little);
+  while (!reader.empty()) {
+    uint32_t fromIndex, toIndex;
+    uint64_t count;
+    if (Error err = reader.readInteger(fromIndex))
+      return err;
+    if (Error err = reader.readInteger(toIndex))
+      return err;
+    if (Error err = reader.readInteger(count))
+      return err;
+    callGraph.emplace_back(fromIndex, toIndex, count);
+  }
+  return Error::success();
+}
+
 // Parse the sequence of sections within a single LC_SEGMENT(_64).
 // Split each section into subsections.
 template <class SectionHeader>
@@ -274,33 +302,29 @@ void ObjFile::parseSections(ArrayRef<SectionHeader> sectionHeaders) {
         StringRef(sec.sectname, strnlen(sec.sectname, sizeof(sec.sectname)));
     StringRef segname =
         StringRef(sec.segname, strnlen(sec.segname, sizeof(sec.segname)));
-    ArrayRef<uint8_t> data = {isZeroFill(sec.flags) ? nullptr
-                                                    : buf + sec.offset,
-                              static_cast<size_t>(sec.size)};
+    sections.push_back(make<Section>(this, segname, name, sec.flags, sec.addr));
     if (sec.align >= 32) {
       error("alignment " + std::to_string(sec.align) + " of section " + name +
             " is too large");
-      sections.push_back(sec.addr);
       continue;
     }
+    Section &section = *sections.back();
     uint32_t align = 1 << sec.align;
-    uint32_t flags = sec.flags;
+    ArrayRef<uint8_t> data = {isZeroFill(sec.flags) ? nullptr
+                                                    : buf + sec.offset,
+                              static_cast<size_t>(sec.size)};
 
     auto splitRecords = [&](int recordSize) -> void {
-      sections.push_back(sec.addr);
       if (data.empty())
         return;
-      Subsections &subsections = sections.back().subsections;
+      Subsections &subsections = section.subsections;
       subsections.reserve(data.size() / recordSize);
-      auto *isec = make<ConcatInputSection>(
-          segname, name, this, data.slice(0, recordSize), align, flags);
-      subsections.push_back({0, isec});
-      for (uint64_t off = recordSize; off < data.size(); off += recordSize) {
-        // Copying requires less memory than constructing a fresh InputSection.
-        auto *copy = make<ConcatInputSection>(*isec);
-        copy->data = data.slice(off, recordSize);
-        subsections.push_back({off, copy});
+      for (uint64_t off = 0; off < data.size(); off += recordSize) {
+        auto *isec = make<ConcatInputSection>(
+            section, data.slice(off, recordSize), align);
+        subsections.push_back({off, isec});
       }
+      section.doneSplitting = true;
     };
 
     if (sectionType(sec.flags) == S_CSTRING_LITERALS ||
@@ -313,66 +337,84 @@ void ObjFile::parseSections(ArrayRef<SectionHeader> sectionHeaders) {
 
       InputSection *isec;
       if (sectionType(sec.flags) == S_CSTRING_LITERALS) {
-        isec =
-            make<CStringInputSection>(segname, name, this, data, align, flags);
+        isec = make<CStringInputSection>(section, data, align);
         // FIXME: parallelize this?
         cast<CStringInputSection>(isec)->splitIntoPieces();
       } else {
-        isec = make<WordLiteralInputSection>(segname, name, this, data, align,
-                                             flags);
+        isec = make<WordLiteralInputSection>(section, data, align);
       }
-      sections.push_back(sec.addr);
-      sections.back().subsections.push_back({0, isec});
+      section.subsections.push_back({0, isec});
     } else if (auto recordSize = getRecordSize(segname, name)) {
       splitRecords(*recordSize);
-      if (name == section_names::compactUnwind)
-        compactUnwindSection = &sections.back();
+    } else if (name == section_names::ehFrame &&
+               segname == segment_names::text) {
+      splitEhFrames(data, *sections.back());
     } else if (segname == segment_names::llvm) {
-      if (name == "__cg_profile" && config->callGraphProfileSort) {
-        TimeTraceScope timeScope("Parsing call graph section");
-        BinaryStreamReader reader(data, support::little);
-        while (!reader.empty()) {
-          uint32_t fromIndex, toIndex;
-          uint64_t count;
-          if (Error err = reader.readInteger(fromIndex))
-            fatal(toString(this) + ": Expected 32-bit integer");
-          if (Error err = reader.readInteger(toIndex))
-            fatal(toString(this) + ": Expected 32-bit integer");
-          if (Error err = reader.readInteger(count))
-            fatal(toString(this) + ": Expected 64-bit integer");
-          callGraph.emplace_back();
-          CallGraphEntry &entry = callGraph.back();
-          entry.fromIndex = fromIndex;
-          entry.toIndex = toIndex;
-          entry.count = count;
-        }
-      }
+      if (config->callGraphProfileSort && name == section_names::cgProfile)
+        checkError(parseCallGraph(data, callGraph));
       // ld64 does not appear to emit contents from sections within the __LLVM
       // segment. Symbols within those sections point to bitcode metadata
       // instead of actual symbols. Global symbols within those sections could
-      // have the same name without causing duplicate symbol errors. Push an
-      // empty entry to ensure indices line up for the remaining sections.
+      // have the same name without causing duplicate symbol errors. To avoid
+      // spurious duplicate symbol errors, we do not parse these sections.
       // TODO: Evaluate whether the bitcode metadata is needed.
-      sections.push_back(sec.addr);
     } else {
-      auto *isec =
-          make<ConcatInputSection>(segname, name, this, data, align, flags);
+      if (name == section_names::addrSig)
+        addrSigSection = sections.back();
+
+      auto *isec = make<ConcatInputSection>(section, data, align);
       if (isDebugSection(isec->getFlags()) &&
           isec->getSegName() == segment_names::dwarf) {
         // Instead of emitting DWARF sections, we emit STABS symbols to the
         // object files that contain them. We filter them out early to avoid
-        // parsing their relocations unnecessarily. But we must still push an
-        // empty entry to ensure the indices line up for the remaining sections.
-        sections.push_back(sec.addr);
+        // parsing their relocations unnecessarily.
         debugSections.push_back(isec);
       } else {
-        sections.push_back(sec.addr);
-        sections.back().subsections.push_back({0, isec});
+        section.subsections.push_back({0, isec});
       }
     }
   }
 }
 
+void ObjFile::splitEhFrames(ArrayRef<uint8_t> data, Section &ehFrameSection) {
+  EhReader reader(this, data, /*dataOff=*/0);
+  size_t off = 0;
+  while (off < reader.size()) {
+    uint64_t frameOff = off;
+    uint64_t length = reader.readLength(&off);
+    if (length == 0)
+      break;
+    uint64_t fullLength = length + (off - frameOff);
+    off += length;
+    // We hard-code an alignment of 1 here because we don't actually want our
+    // EH frames to be aligned to the section alignment. EH frame decoders don't
+    // expect this alignment. Moreover, each EH frame must start where the
+    // previous one ends, and where it ends is indicated by the length field.
+    // Unless we update the length field (troublesome), we should keep the
+    // alignment to 1.
+    // Note that we still want to preserve the alignment of the overall section,
+    // just not of the individual EH frames.
+    ehFrameSection.subsections.push_back(
+        {frameOff, make<ConcatInputSection>(ehFrameSection,
+                                            data.slice(frameOff, fullLength),
+                                            /*align=*/1)});
+  }
+  ehFrameSection.doneSplitting = true;
+}
+
+template <class T>
+static Section *findContainingSection(const std::vector<Section *> &sections,
+                                      T *offset) {
+  static_assert(std::is_same<uint64_t, T>::value ||
+                    std::is_same<uint32_t, T>::value,
+                "unexpected type for offset");
+  auto it = std::prev(llvm::upper_bound(
+      sections, *offset,
+      [](uint64_t value, const Section *sec) { return value < sec->addr; }));
+  *offset -= (*it)->addr;
+  return *it;
+}
+
 // Find the subsection corresponding to the greatest section offset that is <=
 // that of the given offset.
 //
@@ -381,18 +423,32 @@ void ObjFile::parseSections(ArrayRef<SectionHeader> sectionHeaders) {
 // same location as an offset relative to the start of the containing
 // subsection.
 template <class T>
-static InputSection *findContainingSubsection(const Subsections &subsections,
+static InputSection *findContainingSubsection(const Section &section,
                                               T *offset) {
   static_assert(std::is_same<uint64_t, T>::value ||
                     std::is_same<uint32_t, T>::value,
                 "unexpected type for offset");
   auto it = std::prev(llvm::upper_bound(
-      subsections, *offset,
+      section.subsections, *offset,
       [](uint64_t value, Subsection subsec) { return value < subsec.offset; }));
   *offset -= it->offset;
   return it->isec;
 }
 
+// Find a symbol at offset `off` within `isec`.
+static Defined *findSymbolAtOffset(const ConcatInputSection *isec,
+                                   uint64_t off) {
+  auto it = llvm::lower_bound(isec->symbols, off, [](Defined *d, uint64_t off) {
+    return d->value < off;
+  });
+  // The offset should point at the exact address of a symbol (with no addend.)
+  if (it == isec->symbols.end() || (*it)->value != off) {
+    assert(isec->wasCoalesced);
+    return nullptr;
+  }
+  return *it;
+}
+
 template <class SectionHeader>
 static bool validateRelocationInfo(InputFile *file, const SectionHeader &sec,
                                    relocation_info rel) {
@@ -427,12 +483,12 @@ static bool validateRelocationInfo(InputFile *file, const SectionHeader &sec,
 
 template <class SectionHeader>
 void ObjFile::parseRelocations(ArrayRef<SectionHeader> sectionHeaders,
-                               const SectionHeader &sec,
-                               Subsections &subsections) {
+                               const SectionHeader &sec, Section &section) {
   auto *buf = reinterpret_cast<const uint8_t *>(mb.getBufferStart());
   ArrayRef<relocation_info> relInfos(
       reinterpret_cast<const relocation_info *>(buf + sec.reloff), sec.nreloc);
 
+  Subsections &subsections = section.subsections;
   auto subsecIt = subsections.rbegin();
   for (size_t i = 0; i < relInfos.size(); i++) {
     // Paired relocations serve as Mach-O's method for attaching a
@@ -463,13 +519,6 @@ void ObjFile::parseRelocations(ArrayRef<SectionHeader> sectionHeaders,
     relocation_info relInfo = relInfos[i];
     bool isSubtrahend =
         target->hasAttr(relInfo.r_type, RelocAttrBits::SUBTRAHEND);
-    if (isSubtrahend && StringRef(sec.sectname) == section_names::ehFrame) {
-      // __TEXT,__eh_frame only has symbols and SUBTRACTOR relocs when ld64 -r
-      // adds local "EH_Frame1" and "func.eh". Ignore them because they have
-      // gone unused by Mac OS since Snow Leopard (10.6), vintage 2009.
-      ++i;
-      continue;
-    }
     int64_t pairedAddend = 0;
     if (target->hasAttr(relInfo.r_type, RelocAttrBits::ADDEND)) {
       pairedAddend = SignExtend64<24>(relInfo.r_symbolnum);
@@ -511,10 +560,8 @@ void ObjFile::parseRelocations(ArrayRef<SectionHeader> sectionHeaders,
         // The addend for a non-pcrel relocation is its absolute address.
         referentOffset = totalAddend - referentSecHead.addr;
       }
-      Subsections &referentSubsections =
-          sections[relInfo.r_symbolnum - 1].subsections;
-      r.referent =
-          findContainingSubsection(referentSubsections, &referentOffset);
+      r.referent = findContainingSubsection(*sections[relInfo.r_symbolnum - 1],
+                                            &referentOffset);
       r.addend = referentOffset;
     }
 
@@ -528,7 +575,7 @@ void ObjFile::parseRelocations(ArrayRef<SectionHeader> sectionHeaders,
       ++subsecIt;
     if (subsecIt == subsections.rend() ||
         subsecIt->offset + subsecIt->isec->getSize() <= r.offset) {
-      subsec = findContainingSubsection(subsections, &r.offset);
+      subsec = findContainingSubsection(section, &r.offset);
       // Now that we know the relocs are unsorted, avoid trying the 'fast path'
       // for the other relocations.
       subsecIt = subsections.rend();
@@ -552,10 +599,8 @@ void ObjFile::parseRelocations(ArrayRef<SectionHeader> sectionHeaders,
       } else {
         uint64_t referentOffset =
             totalAddend - sectionHeaders[minuendInfo.r_symbolnum - 1].addr;
-        Subsections &referentSubsectVec =
-            sections[minuendInfo.r_symbolnum - 1].subsections;
-        p.referent =
-            findContainingSubsection(referentSubsectVec, &referentOffset);
+        p.referent = findContainingSubsection(
+            *sections[minuendInfo.r_symbolnum - 1], &referentOffset);
         p.addend = referentOffset;
       }
       subsec->relocs.push_back(p);
@@ -629,9 +674,11 @@ static macho::Symbol *createDefined(const NList &sym, StringRef name,
   }
   assert(!isWeakDefCanBeHidden &&
          "weak_def_can_be_hidden on already-hidden symbol?");
+  bool includeInSymtab =
+      !name.startswith("l") && !name.startswith("L") && !isEhFrameSection(isec);
   return make<Defined>(
       name, isec->getFile(), isec, value, size, sym.n_desc & N_WEAK_DEF,
-      /*isExternal=*/false, /*isPrivateExtern=*/false,
+      /*isExternal=*/false, /*isPrivateExtern=*/false, includeInSymtab,
       sym.n_desc & N_ARM_THUMB_DEF, sym.n_desc & REFERENCED_DYNAMICALLY,
       sym.n_desc & N_NO_DEAD_STRIP);
 }
@@ -651,7 +698,7 @@ static macho::Symbol *createAbsolute(const NList &sym, InputFile *file,
   return make<Defined>(name, file, nullptr, sym.n_value, /*size=*/0,
                        /*isWeakDef=*/false,
                        /*isExternal=*/false, /*isPrivateExtern=*/false,
-                       sym.n_desc & N_ARM_THUMB_DEF,
+                       /*includeInSymtab=*/true, sym.n_desc & N_ARM_THUMB_DEF,
                        /*isReferencedDynamically=*/false,
                        sym.n_desc & N_NO_DEAD_STRIP);
 }
@@ -705,7 +752,7 @@ void ObjFile::parseSymbols(ArrayRef<typename LP::section> sectionHeaders,
 
     StringRef name = strtab + sym.n_strx;
     if ((sym.n_type & N_TYPE) == N_SECT) {
-      Subsections &subsections = sections[sym.n_sect - 1].subsections;
+      Subsections &subsections = sections[sym.n_sect - 1]->subsections;
       // parseSections() may have chosen not to parse this section.
       if (subsections.empty())
         continue;
@@ -718,33 +765,26 @@ void ObjFile::parseSymbols(ArrayRef<typename LP::section> sectionHeaders,
   }
 
   for (size_t i = 0; i < sections.size(); ++i) {
-    Subsections &subsections = sections[i].subsections;
+    Subsections &subsections = sections[i]->subsections;
     if (subsections.empty())
       continue;
-    InputSection *lastIsec = subsections.back().isec;
-    if (lastIsec->getName() == section_names::ehFrame) {
-      // __TEXT,__eh_frame only has symbols and SUBTRACTOR relocs when ld64 -r
-      // adds local "EH_Frame1" and "func.eh". Ignore them because they have
-      // gone unused by Mac OS since Snow Leopard (10.6), vintage 2009.
-      continue;
-    }
     std::vector<uint32_t> &symbolIndices = symbolsBySection[i];
     uint64_t sectionAddr = sectionHeaders[i].addr;
     uint32_t sectionAlign = 1u << sectionHeaders[i].align;
 
-    // Record-based sections have already been split into subsections during
+    // Some sections have already been split into subsections during
     // parseSections(), so we simply need to match Symbols to the corresponding
     // subsection here.
-    if (getRecordSize(lastIsec->getSegName(), lastIsec->getName())) {
+    if (sections[i]->doneSplitting) {
       for (size_t j = 0; j < symbolIndices.size(); ++j) {
         uint32_t symIndex = symbolIndices[j];
         const NList &sym = nList[symIndex];
         StringRef name = strtab + sym.n_strx;
         uint64_t symbolOffset = sym.n_value - sectionAddr;
         InputSection *isec =
-            findContainingSubsection(subsections, &symbolOffset);
+            findContainingSubsection(*sections[i], &symbolOffset);
         if (symbolOffset != 0) {
-          error(toString(lastIsec) + ":  symbol " + name +
+          error(toString(*sections[i]) + ":  symbol " + name +
                 " at misaligned offset");
           continue;
         }
@@ -752,6 +792,7 @@ void ObjFile::parseSymbols(ArrayRef<typename LP::section> sectionHeaders,
       }
       continue;
     }
+    sections[i]->doneSplitting = true;
 
     // Calculate symbol sizes and create subsections by splitting the sections
     // along symbol boundaries.
@@ -829,12 +870,13 @@ OpaqueFile::OpaqueFile(MemoryBufferRef mb, StringRef segName,
     : InputFile(OpaqueKind, mb) {
   const auto *buf = reinterpret_cast<const uint8_t *>(mb.getBufferStart());
   ArrayRef<uint8_t> data = {buf, mb.getBufferSize()};
-  ConcatInputSection *isec =
-      make<ConcatInputSection>(segName.take_front(16), sectName.take_front(16),
-                               /*file=*/this, data);
+  sections.push_back(make<Section>(/*file=*/this, segName.take_front(16),
+                                   sectName.take_front(16),
+                                   /*flags=*/0, /*addr=*/0));
+  Section &section = *sections.back();
+  ConcatInputSection *isec = make<ConcatInputSection>(section, data);
   isec->live = true;
-  sections.push_back(0);
-  sections.back().subsections.push_back({0, isec});
+  section.subsections.push_back({0, isec});
 }
 
 ObjFile::ObjFile(MemoryBufferRef mb, uint32_t modTime, StringRef archiveName,
@@ -904,13 +946,25 @@ template <class LP> void ObjFile::parse() {
   // The relocations may refer to the symbols, so we parse them after we have
   // parsed all the symbols.
   for (size_t i = 0, n = sections.size(); i < n; ++i)
-    if (!sections[i].subsections.empty())
-      parseRelocations(sectionHeaders, sectionHeaders[i],
-                       sections[i].subsections);
+    if (!sections[i]->subsections.empty())
+      parseRelocations(sectionHeaders, sectionHeaders[i], *sections[i]);
 
   parseDebugInfo();
+
+  Section *ehFrameSection = nullptr;
+  Section *compactUnwindSection = nullptr;
+  for (Section *sec : sections) {
+    Section **s = StringSwitch<Section **>(sec->name)
+                      .Case(section_names::compactUnwind, &compactUnwindSection)
+                      .Case(section_names::ehFrame, &ehFrameSection)
+                      .Default(nullptr);
+    if (s)
+      *s = sec;
+  }
   if (compactUnwindSection)
-    registerCompactUnwind();
+    registerCompactUnwind(*compactUnwindSection);
+  if (ehFrameSection)
+    registerEhFrames(*ehFrameSection);
 }
 
 template <class LP> void ObjFile::parseLazy() {
@@ -973,8 +1027,8 @@ ArrayRef<data_in_code_entry> ObjFile::getDataInCode() const {
 }
 
 // Create pointers from symbols to their associated compact unwind entries.
-void ObjFile::registerCompactUnwind() {
-  for (const Subsection &subsection : compactUnwindSection->subsections) {
+void ObjFile::registerCompactUnwind(Section &compactUnwindSection) {
+  for (const Subsection &subsection : compactUnwindSection.subsections) {
     ConcatInputSection *isec = cast<ConcatInputSection>(subsection.isec);
     // Hack!! Since each CUE contains a different function address, if ICF
     // operated naively and compared the entire contents of each CUE, entries
@@ -984,6 +1038,12 @@ void ObjFile::registerCompactUnwind() {
     // of the corresponding relocations.) We rely on `relocateCompactUnwind()`
     // to correctly handle these truncated input sections.
     isec->data = isec->data.slice(target->wordSize);
+    uint32_t encoding = read32le(isec->data.data() + sizeof(uint32_t));
+    // llvm-mc omits CU entries for functions that need DWARF encoding, but
+    // `ld -r` doesn't. We can ignore them because we will re-synthesize these
+    // CU entries from the DWARF info during the output phase.
+    if ((encoding & target->modeDwarfEncoding) == target->modeDwarfEncoding)
+      continue;
 
     ConcatInputSection *referentIsec;
     for (auto it = isec->relocs.begin(); it != isec->relocs.end();) {
@@ -1007,23 +1067,23 @@ void ObjFile::registerCompactUnwind() {
         referentIsec =
             cast<ConcatInputSection>(r.referent.dyn_cast<InputSection *>());
       }
+      // Unwind info lives in __DATA, and finalization of __TEXT will occur
+      // before finalization of __DATA. Moreover, the finalization of unwind
+      // info depends on the exact addresses that it references. So it is safe
+      // for compact unwind to reference addresses in __TEXT, but not addresses
+      // in any other segment.
       if (referentIsec->getSegName() != segment_names::text)
-        error("compact unwind references address in " + toString(referentIsec) +
-              " which is not in segment __TEXT");
+        error(isec->getLocation(r.offset) + " references section " +
+              referentIsec->getName() + " which is not in segment __TEXT");
       // The functionAddress relocations are typically section relocations.
       // However, unwind info operates on a per-symbol basis, so we search for
       // the function symbol here.
-      auto symIt = llvm::lower_bound(
-          referentIsec->symbols, add,
-          [](Defined *d, uint64_t add) { return d->value < add; });
-      // The relocation should point at the exact address of a symbol (with no
-      // addend).
-      if (symIt == referentIsec->symbols.end() || (*symIt)->value != add) {
-        assert(referentIsec->wasCoalesced);
+      Defined *d = findSymbolAtOffset(referentIsec, add);
+      if (!d) {
         ++it;
         continue;
       }
-      (*symIt)->unwindEntry = isec;
+      d->unwindEntry = isec;
       // Since we've sliced away the functionAddress, we should remove the
       // corresponding relocation too. Given that clang emits relocations in
       // reverse order of address, this relocation should be at the end of the
@@ -1034,6 +1094,315 @@ void ObjFile::registerCompactUnwind() {
   }
 }
 
+struct CIE {
+  macho::Symbol *personalitySymbol = nullptr;
+  bool fdesHaveAug = false;
+  uint8_t lsdaPtrSize = 0; // 0 => no LSDA
+  uint8_t funcPtrSize = 0;
+};
+
+static uint8_t pointerEncodingToSize(uint8_t enc) {
+  switch (enc & 0xf) {
+  case dwarf::DW_EH_PE_absptr:
+    return target->wordSize;
+  case dwarf::DW_EH_PE_sdata4:
+    return 4;
+  case dwarf::DW_EH_PE_sdata8:
+    // ld64 doesn't actually support sdata8, but this seems simple enough...
+    return 8;
+  default:
+    return 0;
+  };
+}
+
+static CIE parseCIE(const InputSection *isec, const EhReader &reader,
+                    size_t off) {
+  // Handling the full generality of possible DWARF encodings would be a major
+  // pain. We instead take advantage of our knowledge of how llvm-mc encodes
+  // DWARF and handle just that.
+  constexpr uint8_t expectedPersonalityEnc =
+      dwarf::DW_EH_PE_pcrel | dwarf::DW_EH_PE_indirect | dwarf::DW_EH_PE_sdata4;
+
+  CIE cie;
+  uint8_t version = reader.readByte(&off);
+  if (version != 1 && version != 3)
+    fatal("Expected CIE version of 1 or 3, got " + Twine(version));
+  StringRef aug = reader.readString(&off);
+  reader.skipLeb128(&off); // skip code alignment
+  reader.skipLeb128(&off); // skip data alignment
+  reader.skipLeb128(&off); // skip return address register
+  reader.skipLeb128(&off); // skip aug data length
+  uint64_t personalityAddrOff = 0;
+  for (char c : aug) {
+    switch (c) {
+    case 'z':
+      cie.fdesHaveAug = true;
+      break;
+    case 'P': {
+      uint8_t personalityEnc = reader.readByte(&off);
+      if (personalityEnc != expectedPersonalityEnc)
+        reader.failOn(off, "unexpected personality encoding 0x" +
+                               Twine::utohexstr(personalityEnc));
+      personalityAddrOff = off;
+      off += 4;
+      break;
+    }
+    case 'L': {
+      uint8_t lsdaEnc = reader.readByte(&off);
+      cie.lsdaPtrSize = pointerEncodingToSize(lsdaEnc);
+      if (cie.lsdaPtrSize == 0)
+        reader.failOn(off, "unexpected LSDA encoding 0x" +
+                               Twine::utohexstr(lsdaEnc));
+      break;
+    }
+    case 'R': {
+      uint8_t pointerEnc = reader.readByte(&off);
+      cie.funcPtrSize = pointerEncodingToSize(pointerEnc);
+      if (cie.funcPtrSize == 0 || !(pointerEnc & dwarf::DW_EH_PE_pcrel))
+        reader.failOn(off, "unexpected pointer encoding 0x" +
+                               Twine::utohexstr(pointerEnc));
+      break;
+    }
+    default:
+      break;
+    }
+  }
+  if (personalityAddrOff != 0) {
+    auto personalityRelocIt =
+        llvm::find_if(isec->relocs, [=](const macho::Reloc &r) {
+          return r.offset == personalityAddrOff;
+        });
+    if (personalityRelocIt == isec->relocs.end())
+      reader.failOn(off, "Failed to locate relocation for personality symbol");
+    cie.personalitySymbol = personalityRelocIt->referent.get<macho::Symbol *>();
+  }
+  return cie;
+}
+
+// EH frame target addresses may be encoded as pcrel offsets. However, instead
+// of using an actual pcrel reloc, ld64 emits subtractor relocations instead.
+// This function recovers the target address from the subtractors, essentially
+// performing the inverse operation of EhRelocator.
+//
+// Concretely, we expect our relocations to write the value of `PC -
+// target_addr` to `PC`. `PC` itself is denoted by a minuend relocation that
+// points to a symbol plus an addend.
+//
+// It is important that the minuend relocation point to a symbol within the
+// same section as the fixup value, since sections may get moved around.
+//
+// For example, for arm64, llvm-mc emits relocations for the target function
+// address like so:
+//
+//   ltmp:
+//     <CIE start>
+//     ...
+//     <CIE end>
+//     ... multiple FDEs ...
+//     <FDE start>
+//     <target function address - (ltmp + pcrel offset)>
+//     ...
+//
+// If any of the FDEs in `multiple FDEs` get dead-stripped, then `FDE start`
+// will move to an earlier address, and `ltmp + pcrel offset` will no longer
+// reflect an accurate pcrel value. To avoid this problem, we "canonicalize"
+// our relocation by adding an `EH_Frame` symbol at `FDE start`, and updating
+// the reloc to be `target function address - (EH_Frame + new pcrel offset)`.
+//
+// If `Invert` is set, then we instead expect `target_addr - PC` to be written
+// to `PC`.
+template <bool Invert = false>
+Defined *
+targetSymFromCanonicalSubtractor(const InputSection *isec,
+                                 std::vector<macho::Reloc>::iterator relocIt) {
+  macho::Reloc &subtrahend = *relocIt;
+  macho::Reloc &minuend = *std::next(relocIt);
+  assert(target->hasAttr(subtrahend.type, RelocAttrBits::SUBTRAHEND));
+  assert(target->hasAttr(minuend.type, RelocAttrBits::UNSIGNED));
+  // Note: pcSym may *not* be exactly at the PC; there's usually a non-zero
+  // addend.
+  auto *pcSym = cast<Defined>(subtrahend.referent.get<macho::Symbol *>());
+  Defined *target =
+      cast_or_null<Defined>(minuend.referent.dyn_cast<macho::Symbol *>());
+  if (!pcSym) {
+    auto *targetIsec =
+        cast<ConcatInputSection>(minuend.referent.get<InputSection *>());
+    target = findSymbolAtOffset(targetIsec, minuend.addend);
+  }
+  if (Invert)
+    std::swap(pcSym, target);
+  if (pcSym->isec == isec) {
+    if (pcSym->value - (Invert ? -1 : 1) * minuend.addend != subtrahend.offset)
+      fatal("invalid FDE relocation in __eh_frame");
+  } else {
+    // Ensure the pcReloc points to a symbol within the current EH frame.
+    // HACK: we should really verify that the original relocation's semantics
+    // are preserved. In particular, we should have
+    // `oldSym->value + oldOffset == newSym + newOffset`. However, we don't
+    // have an easy way to access the offsets from this point in the code; some
+    // refactoring is needed for that.
+    macho::Reloc &pcReloc = Invert ? minuend : subtrahend;
+    pcReloc.referent = isec->symbols[0];
+    assert(isec->symbols[0]->value == 0);
+    minuend.addend = pcReloc.offset * (Invert ? 1LL : -1LL);
+  }
+  return target;
+}
+
+Defined *findSymbolAtAddress(const std::vector<Section *> &sections,
+                             uint64_t addr) {
+  Section *sec = findContainingSection(sections, &addr);
+  auto *isec = cast<ConcatInputSection>(findContainingSubsection(*sec, &addr));
+  return findSymbolAtOffset(isec, addr);
+}
+
+// For symbols that don't have compact unwind info, associate them with the more
+// general-purpose (and verbose) DWARF unwind info found in __eh_frame.
+//
+// This requires us to parse the contents of __eh_frame. See EhFrame.h for a
+// description of its format.
+//
+// While parsing, we also look for what MC calls "abs-ified" relocations -- they
+// are relocations which are implicitly encoded as offsets in the section data.
+// We convert them into explicit Reloc structs so that the EH frames can be
+// handled just like a regular ConcatInputSection later in our output phase.
+//
+// We also need to handle the case where our input object file has explicit
+// relocations. This is the case when e.g. it's the output of `ld -r`. We only
+// look for the "abs-ified" relocation if an explicit relocation is absent.
+void ObjFile::registerEhFrames(Section &ehFrameSection) {
+  DenseMap<const InputSection *, CIE> cieMap;
+  for (const Subsection &subsec : ehFrameSection.subsections) {
+    auto *isec = cast<ConcatInputSection>(subsec.isec);
+    uint64_t isecOff = subsec.offset;
+
+    // Subtractor relocs require the subtrahend to be a symbol reloc. Ensure
+    // that all EH frames have an associated symbol so that we can generate
+    // subtractor relocs that reference them.
+    if (isec->symbols.size() == 0)
+      isec->symbols.push_back(make<Defined>(
+          "EH_Frame", isec->getFile(), isec, /*value=*/0, /*size=*/0,
+          /*isWeakDef=*/false, /*isExternal=*/false, /*isPrivateExtern=*/false,
+          /*includeInSymtab=*/false, /*isThumb=*/false,
+          /*isReferencedDynamically=*/false, /*noDeadStrip=*/false));
+    else if (isec->symbols[0]->value != 0)
+      fatal("found symbol at unexpected offset in __eh_frame");
+
+    EhReader reader(this, isec->data, subsec.offset);
+    size_t dataOff = 0; // Offset from the start of the EH frame.
+    reader.skipValidLength(&dataOff); // readLength() already validated this.
+    // cieOffOff is the offset from the start of the EH frame to the cieOff
+    // value, which is itself an offset from the current PC to a CIE.
+    const size_t cieOffOff = dataOff;
+
+    EhRelocator ehRelocator(isec);
+    auto cieOffRelocIt = llvm::find_if(
+        isec->relocs, [=](const Reloc &r) { return r.offset == cieOffOff; });
+    InputSection *cieIsec = nullptr;
+    if (cieOffRelocIt != isec->relocs.end()) {
+      // We already have an explicit relocation for the CIE offset.
+      cieIsec =
+          targetSymFromCanonicalSubtractor</*Invert=*/true>(isec, cieOffRelocIt)
+              ->isec;
+      dataOff += sizeof(uint32_t);
+    } else {
+      // If we haven't found a relocation, then the CIE offset is most likely
+      // embedded in the section data (AKA an "abs-ified" reloc.). Parse that
+      // and generate a Reloc struct.
+      uint32_t cieMinuend = reader.readU32(&dataOff);
+      if (cieMinuend == 0)
+        cieIsec = isec;
+      else {
+        uint32_t cieOff = isecOff + dataOff - cieMinuend;
+        cieIsec = findContainingSubsection(ehFrameSection, &cieOff);
+        if (cieIsec == nullptr)
+          fatal("failed to find CIE");
+      }
+      if (cieIsec != isec)
+        ehRelocator.makeNegativePcRel(cieOffOff, cieIsec->symbols[0],
+                                      /*length=*/2);
+    }
+    if (cieIsec == isec) {
+      cieMap[cieIsec] = parseCIE(isec, reader, dataOff);
+      continue;
+    }
+
+    assert(cieMap.count(cieIsec));
+    const CIE &cie = cieMap[cieIsec];
+    // Offset of the function address within the EH frame.
+    const size_t funcAddrOff = dataOff;
+    uint64_t funcAddr = reader.readPointer(&dataOff, cie.funcPtrSize) +
+                        ehFrameSection.addr + isecOff + funcAddrOff;
+    uint32_t funcLength = reader.readPointer(&dataOff, cie.funcPtrSize);
+    size_t lsdaAddrOff = 0; // Offset of the LSDA address within the EH frame.
+    Optional<uint64_t> lsdaAddrOpt;
+    if (cie.fdesHaveAug) {
+      reader.skipLeb128(&dataOff);
+      lsdaAddrOff = dataOff;
+      if (cie.lsdaPtrSize != 0) {
+        uint64_t lsdaOff = reader.readPointer(&dataOff, cie.lsdaPtrSize);
+        if (lsdaOff != 0) // FIXME possible to test this?
+          lsdaAddrOpt = ehFrameSection.addr + isecOff + lsdaAddrOff + lsdaOff;
+      }
+    }
+
+    auto funcAddrRelocIt = isec->relocs.end();
+    auto lsdaAddrRelocIt = isec->relocs.end();
+    for (auto it = isec->relocs.begin(); it != isec->relocs.end(); ++it) {
+      if (it->offset == funcAddrOff)
+        funcAddrRelocIt = it++; // Found subtrahend; skip over minuend reloc
+      else if (lsdaAddrOpt && it->offset == lsdaAddrOff)
+        lsdaAddrRelocIt = it++; // Found subtrahend; skip over minuend reloc
+    }
+
+    Defined *funcSym;
+    if (funcAddrRelocIt != isec->relocs.end()) {
+      funcSym = targetSymFromCanonicalSubtractor(isec, funcAddrRelocIt);
+      // Canonicalize the symbol. If there are multiple symbols at the same
+      // address, we want both `registerEhFrame` and `registerCompactUnwind`
+      // to register the unwind entry under same symbol.
+      // This is not particularly efficient, but we should run into this case
+      // infrequently (only when handling the output of `ld -r`).
+      funcSym = findSymbolAtOffset(cast<ConcatInputSection>(funcSym->isec),
+                                   funcSym->value);
+    } else {
+      funcSym = findSymbolAtAddress(sections, funcAddr);
+      ehRelocator.makePcRel(funcAddrOff, funcSym, target->p2WordSize);
+    }
+    // The symbol has been coalesced, or already has a compact unwind entry.
+    if (!funcSym || funcSym->getFile() != this || funcSym->unwindEntry) {
+      // We must prune unused FDEs for correctness, so we cannot rely on
+      // -dead_strip being enabled.
+      isec->live = false;
+      continue;
+    }
+
+    InputSection *lsdaIsec = nullptr;
+    if (lsdaAddrRelocIt != isec->relocs.end()) {
+      lsdaIsec = targetSymFromCanonicalSubtractor(isec, lsdaAddrRelocIt)->isec;
+    } else if (lsdaAddrOpt) {
+      uint64_t lsdaAddr = *lsdaAddrOpt;
+      Section *sec = findContainingSection(sections, &lsdaAddr);
+      lsdaIsec =
+          cast<ConcatInputSection>(findContainingSubsection(*sec, &lsdaAddr));
+      ehRelocator.makePcRel(lsdaAddrOff, lsdaIsec, target->p2WordSize);
+    }
+
+    fdes[isec] = {funcLength, cie.personalitySymbol, lsdaIsec};
+    funcSym->unwindEntry = isec;
+    ehRelocator.commit();
+  }
+
+  // __eh_frame is marked as S_ATTR_LIVE_SUPPORT in input files, because FDEs
+  // are normally required to be kept alive if they reference a live symbol.
+  // However, we've explicitly created a dependency from a symbol to its FDE, so
+  // dead-stripping will just work as usual, and S_ATTR_LIVE_SUPPORT will only
+  // serve to incorrectly prevent us from dead-stripping duplicate FDEs for a
+  // live symbol (e.g. if there were multiple weak copies). Remove this flag to
+  // let dead-stripping proceed correctly.
+  ehFrameSection.flags &= ~S_ATTR_LIVE_SUPPORT;
+}
+
 // The path can point to either a dylib or a .tbd file.
 static DylibFile *loadDylib(StringRef path, DylibFile *umbrella) {
   Optional<MemoryBufferRef> mbref = readFile(path);
@@ -1117,7 +1486,8 @@ static DylibFile *findDylib(StringRef path, DylibFile *umbrella,
          make_pointee_range(currentTopLevelTapi->documents())) {
       assert(child.documents().empty());
       if (path == child.getInstallName()) {
-        auto file = make<DylibFile>(child, umbrella);
+        auto file = make<DylibFile>(child, umbrella, /*isBundleLoader=*/false,
+                                    /*explicitlyLinked=*/false);
         file->parseReexports(child);
         return file;
       }
@@ -1158,15 +1528,14 @@ static void loadReexport(StringRef path, DylibFile *umbrella,
 }
 
 DylibFile::DylibFile(MemoryBufferRef mb, DylibFile *umbrella,
-                     bool isBundleLoader)
+                     bool isBundleLoader, bool explicitlyLinked)
     : InputFile(DylibKind, mb), refState(RefState::Unreferenced),
-      isBundleLoader(isBundleLoader) {
+      explicitlyLinked(explicitlyLinked), isBundleLoader(isBundleLoader) {
   assert(!isBundleLoader || !umbrella);
   if (umbrella == nullptr)
     umbrella = this;
   this->umbrella = umbrella;
 
-  auto *buf = reinterpret_cast<const uint8_t *>(mb.getBufferStart());
   auto *hdr = reinterpret_cast<const mach_header *>(mb.getBufferStart());
 
   // Initialize installName.
@@ -1201,39 +1570,53 @@ DylibFile::DylibFile(MemoryBufferRef mb, DylibFile *umbrella,
 
   // Initialize symbols.
   exportingFile = isImplicitlyLinked(installName) ? this : this->umbrella;
-  if (const load_command *cmd = findCommand(hdr, LC_DYLD_INFO_ONLY)) {
-    auto *c = reinterpret_cast<const dyld_info_command *>(cmd);
-    struct TrieEntry {
-      StringRef name;
-      uint64_t flags;
-    };
 
-    std::vector<TrieEntry> entries;
-    // Find all the $ld$* symbols to process first.
-    parseTrie(buf + c->export_off, c->export_size,
-              [&](const Twine &name, uint64_t flags) {
-                StringRef savedName = saver().save(name);
-                if (handleLDSymbol(savedName))
-                  return;
-                entries.push_back({savedName, flags});
-              });
-
-    // Process the "normal" symbols.
-    for (TrieEntry &entry : entries) {
-      if (exportingFile->hiddenSymbols.contains(
-              CachedHashStringRef(entry.name)))
-        continue;
+  const auto *dyldInfo = findCommand<dyld_info_command>(hdr, LC_DYLD_INFO_ONLY);
+  const auto *exportsTrie =
+      findCommand<linkedit_data_command>(hdr, LC_DYLD_EXPORTS_TRIE);
+  if (dyldInfo && exportsTrie) {
+    // It's unclear what should happen in this case. Maybe we should only error
+    // out if the two load commands refer to different data?
+    error("dylib " + toString(this) +
+          " has both LC_DYLD_INFO_ONLY and LC_DYLD_EXPORTS_TRIE");
+    return;
+  } else if (dyldInfo) {
+    parseExportedSymbols(dyldInfo->export_off, dyldInfo->export_size);
+  } else if (exportsTrie) {
+    parseExportedSymbols(exportsTrie->dataoff, exportsTrie->datasize);
+  } else {
+    error("No LC_DYLD_INFO_ONLY or LC_DYLD_EXPORTS_TRIE found in " +
+          toString(this));
+    return;
+  }
+}
 
-      bool isWeakDef = entry.flags & EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION;
-      bool isTlv = entry.flags & EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL;
+void DylibFile::parseExportedSymbols(uint32_t offset, uint32_t size) {
+  struct TrieEntry {
+    StringRef name;
+    uint64_t flags;
+  };
 
-      symbols.push_back(
-          symtab->addDylib(entry.name, exportingFile, isWeakDef, isTlv));
-    }
+  auto *buf = reinterpret_cast<const uint8_t *>(mb.getBufferStart());
+  std::vector<TrieEntry> entries;
+  // Find all the $ld$* symbols to process first.
+  parseTrie(buf + offset, size, [&](const Twine &name, uint64_t flags) {
+    StringRef savedName = saver().save(name);
+    if (handleLDSymbol(savedName))
+      return;
+    entries.push_back({savedName, flags});
+  });
 
-  } else {
-    error("LC_DYLD_INFO_ONLY not found in " + toString(this));
-    return;
+  // Process the "normal" symbols.
+  for (TrieEntry &entry : entries) {
+    if (exportingFile->hiddenSymbols.contains(CachedHashStringRef(entry.name)))
+      continue;
+
+    bool isWeakDef = entry.flags & EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION;
+    bool isTlv = entry.flags & EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL;
+
+    symbols.push_back(
+        symtab->addDylib(entry.name, exportingFile, isWeakDef, isTlv));
   }
 }
 
@@ -1269,17 +1652,26 @@ void DylibFile::parseLoadCommands(MemoryBufferRef mb) {
   }
 }
 
-// Some versions of XCode ship with .tbd files that don't have the right
+// Some versions of Xcode ship with .tbd files that don't have the right
 // platform settings.
-static constexpr std::array<StringRef, 3> skipPlatformChecks{
+constexpr std::array<StringRef, 3> skipPlatformChecks{
     "/usr/lib/system/libsystem_kernel.dylib",
     "/usr/lib/system/libsystem_platform.dylib",
     "/usr/lib/system/libsystem_pthread.dylib"};
 
+static bool skipPlatformCheckForCatalyst(const InterfaceFile &interface,
+                                         bool explicitlyLinked) {
+  // Catalyst outputs can link against implicitly linked macOS-only libraries.
+  if (config->platform() != PLATFORM_MACCATALYST || explicitlyLinked)
+    return false;
+  return is_contained(interface.targets(),
+                      MachO::Target(config->arch(), PLATFORM_MACOS));
+}
+
 DylibFile::DylibFile(const InterfaceFile &interface, DylibFile *umbrella,
-                     bool isBundleLoader)
+                     bool isBundleLoader, bool explicitlyLinked)
     : InputFile(DylibKind, interface), refState(RefState::Unreferenced),
-      isBundleLoader(isBundleLoader) {
+      explicitlyLinked(explicitlyLinked), isBundleLoader(isBundleLoader) {
   // FIXME: Add test for the missing TBD code path.
 
   if (umbrella == nullptr)
@@ -1295,7 +1687,8 @@ DylibFile::DylibFile(const InterfaceFile &interface, DylibFile *umbrella,
   inputFiles.insert(this);
 
   if (!is_contained(skipPlatformChecks, installName) &&
-      !is_contained(interface.targets(), config->platformInfo.target)) {
+      !is_contained(interface.targets(), config->platformInfo.target) &&
+      !skipPlatformCheckForCatalyst(interface, explicitlyLinked)) {
     error(toString(this) + " is incompatible with " +
           std::string(config->platformInfo.target));
     return;
@@ -1569,6 +1962,7 @@ static macho::Symbol *createBitcodeSymbol(const lto::InputFile::Symbol &objSym,
   case GlobalValue::DefaultVisibility:
     break;
   }
+  isPrivateExtern = isPrivateExtern || objSym.canBeOmittedFromSymbolTable();
 
   if (objSym.isCommon())
     return symtab->addCommon(name, &file, objSym.getCommonSize(),
diff --git a/lld/MachO/InputFiles.h b/lld/MachO/InputFiles.h
index 0b661c828c7c9..f53fed5142d27 100644
--- a/lld/MachO/InputFiles.h
+++ b/lld/MachO/InputFiles.h
@@ -58,11 +58,32 @@ struct Subsection {
 };
 
 using Subsections = std::vector<Subsection>;
+class InputFile;
 
-struct Section {
-  uint64_t address = 0;
+class Section {
+public:
+  InputFile *file;
+  StringRef segname;
+  StringRef name;
+  uint32_t flags;
+  uint64_t addr;
   Subsections subsections;
-  Section(uint64_t addr) : address(addr){};
+
+  Section(InputFile *file, StringRef segname, StringRef name, uint32_t flags,
+          uint64_t addr)
+      : file(file), segname(segname), name(name), flags(flags), addr(addr) {}
+  // Ensure pointers to Sections are never invalidated.
+  Section(const Section &) = delete;
+  Section &operator=(const Section &) = delete;
+  Section(Section &&) = delete;
+  Section &operator=(Section &&) = delete;
+
+private:
+  // Whether we have already split this section into individual subsections.
+  // For sections that cannot be split (e.g. literal sections), this is always
+  // false.
+  bool doneSplitting = false;
+  friend class ObjFile;
 };
 
 // Represents a call graph profile edge.
@@ -73,6 +94,9 @@ struct CallGraphEntry {
   uint32_t toIndex;
   // Number of calls from callee to caller in the profile.
   uint64_t count;
+
+  CallGraphEntry(uint32_t fromIndex, uint32_t toIndex, uint64_t count)
+      : fromIndex(fromIndex), toIndex(toIndex), count(count) {}
 };
 
 class InputFile {
@@ -93,7 +117,7 @@ class InputFile {
   MemoryBufferRef mb;
 
   std::vector<Symbol *> symbols;
-  std::vector<Section> sections;
+  std::vector<Section *> sections;
 
   // If not empty, this stores the name of the archive containing this file.
   // We use this string for creating error messages.
@@ -119,6 +143,12 @@ class InputFile {
   static int idCount;
 };
 
+struct FDE {
+  uint32_t funcLength;
+  Symbol *personality;
+  InputSection *lsda;
+};
+
 // .o file
 class ObjFile final : public InputFile {
 public:
@@ -130,13 +160,13 @@ class ObjFile final : public InputFile {
   static bool classof(const InputFile *f) { return f->kind() == ObjKind; }
 
   llvm::DWARFUnit *compileUnit = nullptr;
+  Section *addrSigSection = nullptr;
   const uint32_t modTime;
   std::vector<ConcatInputSection *> debugSections;
   std::vector<CallGraphEntry> callGraph;
+  llvm::DenseMap<ConcatInputSection *, FDE> fdes;
 
 private:
-  Section *compactUnwindSection = nullptr;
-
   template <class LP> void parseLazy();
   template <class SectionHeader> void parseSections(ArrayRef<SectionHeader>);
   template <class LP>
@@ -147,9 +177,11 @@ class ObjFile final : public InputFile {
   Symbol *parseNonSectionSymbol(const NList &sym, StringRef name);
   template <class SectionHeader>
   void parseRelocations(ArrayRef<SectionHeader> sectionHeaders,
-                        const SectionHeader &, Subsections &);
+                        const SectionHeader &, Section &);
   void parseDebugInfo();
-  void registerCompactUnwind();
+  void splitEhFrames(ArrayRef<uint8_t> dataArr, Section &ehFrameSection);
+  void registerCompactUnwind(Section &compactUnwindSection);
+  void registerEhFrames(Section &ehFrameSection);
 };
 
 // command-line -sectcreate file
@@ -170,10 +202,10 @@ class DylibFile final : public InputFile {
   // to the root. On the other hand, if a dylib is being directly loaded
   // (through an -lfoo flag), then `umbrella` should be a nullptr.
   explicit DylibFile(MemoryBufferRef mb, DylibFile *umbrella,
-                     bool isBundleLoader = false);
+                     bool isBundleLoader, bool explicitlyLinked);
   explicit DylibFile(const llvm::MachO::InterfaceFile &interface,
-                     DylibFile *umbrella = nullptr,
-                     bool isBundleLoader = false);
+                     DylibFile *umbrella, bool isBundleLoader,
+                     bool explicitlyLinked);
 
   void parseLoadCommands(MemoryBufferRef mb);
   void parseReexports(const llvm::MachO::InterfaceFile &interface);
@@ -207,6 +239,7 @@ class DylibFile final : public InputFile {
   void handleLDInstallNameSymbol(StringRef name, StringRef originalName);
   void handleLDHideSymbol(StringRef name, StringRef originalName);
   void checkAppExtensionSafety(bool dylibIsAppExtensionSafe) const;
+  void parseExportedSymbols(uint32_t offset, uint32_t size);
 
   llvm::DenseSet<llvm::CachedHashStringRef> hiddenSymbols;
 };
@@ -291,6 +324,7 @@ std::vector<const CommandType *> findCommands(const void *anyHdr,
 } // namespace macho
 
 std::string toString(const macho::InputFile *file);
+std::string toString(const macho::Section &);
 } // namespace lld
 
 #endif
diff --git a/lld/MachO/InputSection.cpp b/lld/MachO/InputSection.cpp
index d42085737dbb7..444a1e9b17c1a 100644
--- a/lld/MachO/InputSection.cpp
+++ b/lld/MachO/InputSection.cpp
@@ -30,7 +30,7 @@ using namespace lld::macho;
 // can differ based on STL debug levels (e.g. iterator debugging on MSVC's STL),
 // so account for that.
 static_assert(sizeof(void *) != 8 ||
-                  sizeof(ConcatInputSection) == sizeof(std::vector<Reloc>) + 96,
+                  sizeof(ConcatInputSection) == sizeof(std::vector<Reloc>) + 88,
               "Try to minimize ConcatInputSection's size, we create many "
               "instances of it");
 
@@ -55,46 +55,26 @@ static uint64_t resolveSymbolVA(const Symbol *sym, uint8_t type) {
   return sym->getVA();
 }
 
-// ICF needs to hash any section that might potentially be duplicated so
-// that it can match on content rather than identity.
-bool ConcatInputSection::isHashableForICF() const {
-  switch (sectionType(getFlags())) {
-  case S_REGULAR:
-    return true;
-  case S_CSTRING_LITERALS:
-  case S_4BYTE_LITERALS:
-  case S_8BYTE_LITERALS:
-  case S_16BYTE_LITERALS:
-  case S_LITERAL_POINTERS:
-    llvm_unreachable("found unexpected literal type in ConcatInputSection");
-  case S_ZEROFILL:
-  case S_GB_ZEROFILL:
-  case S_NON_LAZY_SYMBOL_POINTERS:
-  case S_LAZY_SYMBOL_POINTERS:
-  case S_SYMBOL_STUBS:
-  case S_MOD_INIT_FUNC_POINTERS:
-  case S_MOD_TERM_FUNC_POINTERS:
-  case S_COALESCED:
-  case S_INTERPOSING:
-  case S_DTRACE_DOF:
-  case S_LAZY_DYLIB_SYMBOL_POINTERS:
-  case S_THREAD_LOCAL_REGULAR:
-  case S_THREAD_LOCAL_ZEROFILL:
-  case S_THREAD_LOCAL_VARIABLES:
-  case S_THREAD_LOCAL_VARIABLE_POINTERS:
-  case S_THREAD_LOCAL_INIT_FUNCTION_POINTERS:
-    return false;
-  default:
-    llvm_unreachable("Section type");
-  }
-}
+std::string InputSection::getLocation(uint64_t off) const {
+  // First, try to find a symbol that's near the offset. Use it as a reference
+  // point.
+  for (size_t i = 0; i < symbols.size(); ++i)
+    if (symbols[i]->value <= off &&
+        (i + 1 == symbols.size() || symbols[i + 1]->value > off))
+      return (toString(getFile()) + ":(symbol " + symbols.front()->getName() +
+              "+0x" + Twine::utohexstr(off - symbols[i]->value) + ")")
+          .str();
 
-void ConcatInputSection::hashForICF() {
-  assert(data.data()); // zeroFill section data has nullptr with non-zero size
-  assert(icfEqClass[0] == 0); // don't overwrite a unique ID!
-  // Turn-on the top bit to guarantee that valid hashes have no collisions
-  // with the small-integer unique IDs for ICF-ineligible sections
-  icfEqClass[0] = xxHash64(data) | (1ull << 63);
+  // If that fails, use the section itself as a reference point.
+  for (const Subsection &subsec : section.subsections) {
+    if (subsec.isec == this) {
+      off += subsec.offset;
+      break;
+    }
+  }
+  return (toString(getFile()) + ":(" + getName() + "+0x" +
+          Twine::utohexstr(off) + ")")
+      .str();
 }
 
 void ConcatInputSection::foldIdentical(ConcatInputSection *copy) {
@@ -102,6 +82,8 @@ void ConcatInputSection::foldIdentical(ConcatInputSection *copy) {
   copy->live = false;
   copy->wasCoalesced = true;
   copy->replacement = this;
+  for (auto &copySym : copy->symbols)
+    copySym->wasIdenticalCodeFolded = true;
 
   // Merge the sorted vectors of symbols together.
   auto it = symbols.begin();
@@ -177,13 +159,25 @@ void ConcatInputSection::writeTo(uint8_t *buf) {
   }
 }
 
+ConcatInputSection *macho::makeSyntheticInputSection(StringRef segName,
+                                                     StringRef sectName,
+                                                     uint32_t flags,
+                                                     ArrayRef<uint8_t> data,
+                                                     uint32_t align) {
+  Section &section =
+      *make<Section>(/*file=*/nullptr, segName, sectName, flags, /*addr=*/0);
+  auto isec = make<ConcatInputSection>(section, data, align);
+  section.subsections.push_back({0, isec});
+  return isec;
+}
+
 void CStringInputSection::splitIntoPieces() {
   size_t off = 0;
   StringRef s = toStringRef(data);
   while (!s.empty()) {
     size_t end = s.find(0);
     if (end == StringRef::npos)
-      fatal(toString(this) + ": string is not null terminated");
+      fatal(getLocation(off) + ": string is not null terminated");
     size_t size = end + 1;
     uint32_t hash = config->dedupLiterals ? xxHash64(s.substr(0, size)) : 0;
     pieces.emplace_back(off, hash);
@@ -211,13 +205,11 @@ uint64_t CStringInputSection::getOffset(uint64_t off) const {
   return piece.outSecOff + addend;
 }
 
-WordLiteralInputSection::WordLiteralInputSection(StringRef segname,
-                                                 StringRef name,
-                                                 InputFile *file,
+WordLiteralInputSection::WordLiteralInputSection(const Section &section,
                                                  ArrayRef<uint8_t> data,
-                                                 uint32_t align, uint32_t flags)
-    : InputSection(WordLiteralKind, segname, name, file, data, align, flags) {
-  switch (sectionType(flags)) {
+                                                 uint32_t align)
+    : InputSection(WordLiteralKind, section, data, align) {
+  switch (sectionType(getFlags())) {
   case S_4BYTE_LITERALS:
     power2LiteralSize = 2;
     break;
@@ -271,6 +263,16 @@ bool macho::isCfStringSection(const InputSection *isec) {
          isec->getSegName() == segment_names::data;
 }
 
+bool macho::isClassRefsSection(const InputSection *isec) {
+  return isec->getName() == section_names::objcClassRefs &&
+         isec->getSegName() == segment_names::data;
+}
+
+bool macho::isEhFrameSection(const InputSection *isec) {
+  return isec->getName() == section_names::ehFrame &&
+         isec->getSegName() == segment_names::text;
+}
+
 std::string lld::toString(const InputSection *isec) {
   return (toString(isec->getFile()) + ":(" + isec->getName() + ")").str();
 }
diff --git a/lld/MachO/InputSection.h b/lld/MachO/InputSection.h
index 5535e871c539d..ad8404d0a64bb 100644
--- a/lld/MachO/InputSection.h
+++ b/lld/MachO/InputSection.h
@@ -29,38 +29,54 @@ class OutputSection;
 
 class InputSection {
 public:
-  enum Kind {
+  enum Kind : uint8_t {
     ConcatKind,
     CStringLiteralKind,
     WordLiteralKind,
   };
 
-  Kind kind() const { return shared->sectionKind; }
+  Kind kind() const { return sectionKind; }
   virtual ~InputSection() = default;
   virtual uint64_t getSize() const { return data.size(); }
   virtual bool empty() const { return data.empty(); }
-  InputFile *getFile() const { return shared->file; }
-  StringRef getName() const { return shared->name; }
-  StringRef getSegName() const { return shared->segname; }
-  uint32_t getFlags() const { return shared->flags; }
+  InputFile *getFile() const { return section.file; }
+  StringRef getName() const { return section.name; }
+  StringRef getSegName() const { return section.segname; }
+  uint32_t getFlags() const { return section.flags; }
   uint64_t getFileSize() const;
   // Translates \p off -- an offset relative to this InputSection -- into an
   // offset from the beginning of its parent OutputSection.
   virtual uint64_t getOffset(uint64_t off) const = 0;
   // The offset from the beginning of the file.
   uint64_t getVA(uint64_t off) const;
+  // Return a user-friendly string for use in diagnostics.
+  std::string getLocation(uint64_t off) const;
   // Whether the data at \p off in this InputSection is live.
   virtual bool isLive(uint64_t off) const = 0;
   virtual void markLive(uint64_t off) = 0;
   virtual InputSection *canonical() { return this; }
   virtual const InputSection *canonical() const { return this; }
 
-  OutputSection *parent = nullptr;
+protected:
+  InputSection(Kind kind, const Section &section, ArrayRef<uint8_t> data,
+               uint32_t align)
+      : sectionKind(kind), align(align), data(data), section(section) {}
 
-  uint32_t align = 1;
+  InputSection(const InputSection &rhs)
+      : sectionKind(rhs.sectionKind), align(rhs.align), data(rhs.data),
+        section(rhs.section) {}
+
+  Kind sectionKind;
+
+public:
   // is address assigned?
   bool isFinal = false;
+  // keep the address of the symbol(s) in this section unique in the final
+  // binary ?
+  bool keepUnique = false;
+  uint32_t align = 1;
 
+  OutputSection *parent = nullptr;
   ArrayRef<uint8_t> data;
   std::vector<Reloc> relocs;
   // The symbols that belong to this InputSection, sorted by value. With
@@ -68,31 +84,7 @@ class InputSection {
   llvm::TinyPtrVector<Defined *> symbols;
 
 protected:
-  // The fields in this struct are immutable. Since we create a lot of
-  // InputSections with identical values for them (due to
-  // .subsections_via_symbols), factoring them out into a shared struct reduces
-  // memory consumption and makes copying cheaper.
-  struct Shared {
-    InputFile *file;
-    StringRef name;
-    StringRef segname;
-    uint32_t flags;
-    Kind sectionKind;
-    Shared(InputFile *file, StringRef name, StringRef segname, uint32_t flags,
-           Kind kind)
-        : file(file), name(name), segname(segname), flags(flags),
-          sectionKind(kind) {}
-  };
-
-  InputSection(Kind kind, StringRef segname, StringRef name, InputFile *file,
-               ArrayRef<uint8_t> data, uint32_t align, uint32_t flags)
-      : align(align), data(data),
-        shared(make<Shared>(file, name, segname, flags, kind)) {}
-
-  InputSection(const InputSection &rhs)
-      : align(rhs.align), data(rhs.data), shared(rhs.shared) {}
-
-  const Shared *const shared;
+  const Section &section;
 };
 
 // ConcatInputSections are combined into (Concat)OutputSections through simple
@@ -100,15 +92,9 @@ class InputSection {
 // contents merged before output.
 class ConcatInputSection final : public InputSection {
 public:
-  ConcatInputSection(StringRef segname, StringRef name, InputFile *file,
-                     ArrayRef<uint8_t> data, uint32_t align = 1,
-                     uint32_t flags = 0)
-      : InputSection(ConcatKind, segname, name, file, data, align, flags) {}
-
-  ConcatInputSection(StringRef segname, StringRef name)
-      : ConcatInputSection(segname, name, /*file=*/nullptr,
-                           /*data=*/{},
-                           /*align=*/1, /*flags=*/0) {}
+  ConcatInputSection(const Section &section, ArrayRef<uint8_t> data,
+                     uint32_t align = 1)
+      : InputSection(ConcatKind, section, data, align) {}
 
   uint64_t getOffset(uint64_t off) const override { return outSecOff + off; }
   uint64_t getVA() const { return InputSection::getVA(0); }
@@ -117,8 +103,6 @@ class ConcatInputSection final : public InputSection {
   void markLive(uint64_t off) override { live = true; }
   bool isCoalescedWeak() const { return wasCoalesced && symbols.empty(); }
   bool shouldOmitFromOutput() const { return !live || isCoalescedWeak(); }
-  bool isHashableForICF() const;
-  void hashForICF();
   void writeTo(uint8_t *buf);
 
   void foldIdentical(ConcatInputSection *redundant);
@@ -136,7 +120,7 @@ class ConcatInputSection final : public InputSection {
   // Points to the surviving section after this one is folded by ICF
   ConcatInputSection *replacement = nullptr;
   // Equivalence-class ID for ICF
-  uint64_t icfEqClass[2] = {0, 0};
+  uint32_t icfEqClass[2] = {0, 0};
 
   // With subsections_via_symbols, most symbols have their own InputSection,
   // and for weak symbols (e.g. from inline functions), only the
@@ -152,6 +136,13 @@ class ConcatInputSection final : public InputSection {
   uint64_t outSecOff = 0;
 };
 
+// Initialize a fake InputSection that does not belong to any InputFile.
+ConcatInputSection *makeSyntheticInputSection(StringRef segName,
+                                              StringRef sectName,
+                                              uint32_t flags = 0,
+                                              ArrayRef<uint8_t> data = {},
+                                              uint32_t align = 1);
+
 // Helper functions to make it easy to sprinkle asserts.
 
 inline bool shouldOmitFromOutput(InputSection *isec) {
@@ -193,10 +184,9 @@ static_assert(sizeof(StringPiece) == 16, "StringPiece is too big!");
 // conservative behavior we can certainly implement that.
 class CStringInputSection final : public InputSection {
 public:
-  CStringInputSection(StringRef segname, StringRef name, InputFile *file,
-                      ArrayRef<uint8_t> data, uint32_t align, uint32_t flags)
-      : InputSection(CStringLiteralKind, segname, name, file, data, align,
-                     flags) {}
+  CStringInputSection(const Section &section, ArrayRef<uint8_t> data,
+                      uint32_t align)
+      : InputSection(CStringLiteralKind, section, data, align) {}
   uint64_t getOffset(uint64_t off) const override;
   bool isLive(uint64_t off) const override { return getStringPiece(off).live; }
   void markLive(uint64_t off) override { getStringPiece(off).live = true; }
@@ -231,9 +221,8 @@ class CStringInputSection final : public InputSection {
 
 class WordLiteralInputSection final : public InputSection {
 public:
-  WordLiteralInputSection(StringRef segname, StringRef name, InputFile *file,
-                          ArrayRef<uint8_t> data, uint32_t align,
-                          uint32_t flags);
+  WordLiteralInputSection(const Section &section, ArrayRef<uint8_t> data,
+                          uint32_t align);
   uint64_t getOffset(uint64_t off) const override;
   bool isLive(uint64_t off) const override {
     return live[off >> power2LiteralSize];
@@ -282,8 +271,9 @@ inline bool isWordLiteralSection(uint32_t flags) {
 }
 
 bool isCodeSection(const InputSection *);
-
 bool isCfStringSection(const InputSection *);
+bool isClassRefsSection(const InputSection *);
+bool isEhFrameSection(const InputSection *);
 
 extern std::vector<ConcatInputSection *> inputSections;
 
@@ -295,6 +285,7 @@ constexpr const char binding[] = "__binding";
 constexpr const char bitcodeBundle[] = "__bundle";
 constexpr const char cString[] = "__cstring";
 constexpr const char cfString[] = "__cfstring";
+constexpr const char cgProfile[] = "__cg_profile";
 constexpr const char codeSignature[] = "__code_signature";
 constexpr const char common[] = "__common";
 constexpr const char compactUnwind[] = "__compact_unwind";
@@ -319,6 +310,7 @@ constexpr const char moduleTermFunc[] = "__mod_term_func";
 constexpr const char nonLazySymbolPtr[] = "__nl_symbol_ptr";
 constexpr const char objcCatList[] = "__objc_catlist";
 constexpr const char objcClassList[] = "__objc_classlist";
+constexpr const char objcClassRefs[] = "__objc_classrefs";
 constexpr const char objcConst[] = "__objc_const";
 constexpr const char objcImageInfo[] = "__objc_imageinfo";
 constexpr const char objcNonLazyCatList[] = "__objc_nlcatlist";
@@ -340,6 +332,7 @@ constexpr const char threadVars[] = "__thread_vars";
 constexpr const char unwindInfo[] = "__unwind_info";
 constexpr const char weakBinding[] = "__weak_binding";
 constexpr const char zeroFill[] = "__zerofill";
+constexpr const char addrSig[] = "__llvm_addrsig";
 
 } // namespace section_names
 
diff --git a/lld/MachO/LTO.cpp b/lld/MachO/LTO.cpp
index fd49a09229d11..0400ee11c609c 100644
--- a/lld/MachO/LTO.cpp
+++ b/lld/MachO/LTO.cpp
@@ -34,6 +34,7 @@ using namespace llvm::sys;
 static lto::Config createConfig() {
   lto::Config c;
   c.Options = initTargetOptionsFromCodeGenFlags();
+  c.Options.EmitAddrsig = config->icfLevel == ICFLevel::safe;
   c.CodeModel = getCodeModelFromCMModel();
   c.CPU = getCPUStr();
   c.MAttrs = getMAttrs();
@@ -64,6 +65,8 @@ void BitcodeCompiler::add(BitcodeFile &f) {
   resols.reserve(objSyms.size());
 
   // Provide a resolution to the LTO API for each symbol.
+  bool exportDynamic =
+      config->outputType != MH_EXECUTE || config->exportDynamic;
   auto symIt = f.symbols.begin();
   for (const lto::InputFile::Symbol &objSym : objSyms) {
     resols.emplace_back();
@@ -77,12 +80,18 @@ void BitcodeCompiler::add(BitcodeFile &f) {
     // be removed.
     r.Prevailing = !objSym.isUndefined() && sym->getFile() == &f;
 
-    // FIXME: What about other output types? And we can probably be less
-    // restrictive with -flat_namespace, but it's an infrequent use case.
-    // FIXME: Honor config->exportDynamic.
-    r.VisibleToRegularObj = config->outputType != MH_EXECUTE ||
-                            config->namespaceKind == NamespaceKind::flat ||
-                            sym->isUsedInRegularObj;
+    if (const auto *defined = dyn_cast<Defined>(sym)) {
+      r.ExportDynamic =
+          defined->isExternal() && !defined->privateExtern && exportDynamic;
+      r.FinalDefinitionInLinkageUnit =
+          !defined->isExternalWeakDef() && !defined->interposable;
+    } else if (const auto *common = dyn_cast<CommonSymbol>(sym)) {
+      r.ExportDynamic = !common->privateExtern && exportDynamic;
+      r.FinalDefinitionInLinkageUnit = true;
+    }
+
+    r.VisibleToRegularObj =
+        sym->isUsedInRegularObj || (r.Prevailing && r.ExportDynamic);
 
     // Un-define the symbol so that we don't get duplicate symbol errors when we
     // load the ObjFile emitted by LTO compilation.
diff --git a/lld/MachO/MapFile.cpp b/lld/MachO/MapFile.cpp
index 8f9381ff0d792..a4a0065c28165 100644
--- a/lld/MachO/MapFile.cpp
+++ b/lld/MachO/MapFile.cpp
@@ -31,6 +31,7 @@
 #include "OutputSection.h"
 #include "OutputSegment.h"
 #include "Symbols.h"
+#include "SyntheticSections.h"
 #include "Target.h"
 #include "llvm/Support/Parallel.h"
 #include "llvm/Support/TimeProfiler.h"
@@ -76,7 +77,27 @@ getSymbolStrings(ArrayRef<Defined *> syms) {
   std::vector<std::string> str(syms.size());
   parallelForEachN(0, syms.size(), [&](size_t i) {
     raw_string_ostream os(str[i]);
-    os << toString(*syms[i]);
+    Defined *sym = syms[i];
+
+    switch (sym->isec->kind()) {
+    case InputSection::CStringLiteralKind: {
+      // Output "literal string: <string literal>"
+      const auto *isec = cast<CStringInputSection>(sym->isec);
+      const StringPiece &piece = isec->getStringPiece(sym->value);
+      assert(
+          sym->value == piece.inSecOff &&
+          "We expect symbols to always point to the start of a StringPiece.");
+      StringRef str = isec->getStringRef(&piece - &(*isec->pieces.begin()));
+      assert(str.back() == '\000');
+      (os << "literal string: ")
+          // Remove null sequence at the end
+          .write_escaped(str.substr(0, str.size() - 1));
+      break;
+    }
+    case InputSection::ConcatKind:
+    case InputSection::WordLiteralKind:
+      os << toString(*sym);
+    }
   });
 
   DenseMap<Symbol *, std::string> ret;
diff --git a/lld/MachO/MarkLive.cpp b/lld/MachO/MarkLive.cpp
index 4269c8342c656..7239e30bbdb22 100644
--- a/lld/MachO/MarkLive.cpp
+++ b/lld/MachO/MarkLive.cpp
@@ -21,65 +21,228 @@ namespace macho {
 using namespace llvm;
 using namespace llvm::MachO;
 
+struct WhyLiveEntry {
+  InputSection *isec;
+  // Keep track of the entry that caused us to mark `isec` as live.
+  const WhyLiveEntry *prev;
+
+  WhyLiveEntry(InputSection *isec, const WhyLiveEntry *prev)
+      : isec(isec), prev(prev) {}
+};
+
+// Type-erased interface to MarkLiveImpl. Used for adding roots to the liveness
+// graph.
+class MarkLive {
+public:
+  virtual void enqueue(InputSection *isec, uint64_t off) = 0;
+  virtual void addSym(Symbol *s) = 0;
+  virtual void markTransitively() = 0;
+  virtual ~MarkLive() = default;
+};
+
+template <bool RecordWhyLive> class MarkLiveImpl : public MarkLive {
+public:
+  // -why_live is a rarely used option, so we don't want support for that flag
+  // to slow down the main -dead_strip code path. As such, we employ templates
+  // to avoid the usage of WhyLiveEntry in the main code path. This saves us
+  // from needless allocations and pointer indirections.
+  using WorklistEntry =
+      std::conditional_t<RecordWhyLive, WhyLiveEntry, InputSection>;
+
+  void enqueue(InputSection *isec, uint64_t off) override {
+    enqueue(isec, off, nullptr);
+  }
+  void addSym(Symbol *s) override { addSym(s, nullptr); }
+  void markTransitively() override;
+
+private:
+  void enqueue(InputSection *isec, uint64_t off, const WorklistEntry *prev);
+  void addSym(Symbol *s, const WorklistEntry *prev);
+  void printWhyLive(Symbol *s, const WorklistEntry *prev);
+  const InputSection *getInputSection(const WorklistEntry *) const;
+  WorklistEntry *makeEntry(InputSection *, const WorklistEntry *prev) const;
+
+  // We build up a worklist of sections which have been marked as live. We
+  // only push into the worklist when we discover an unmarked section, and we
+  // mark as we push, so sections never appear twice in the list. Literal
+  // sections cannot contain references to other sections, so we only store
+  // ConcatInputSections in our worklist.
+  SmallVector<WorklistEntry *, 256> worklist;
+};
+
+template <bool RecordWhyLive>
+void MarkLiveImpl<RecordWhyLive>::enqueue(
+    InputSection *isec, uint64_t off,
+    const typename MarkLiveImpl<RecordWhyLive>::WorklistEntry *prev) {
+  if (isec->isLive(off))
+    return;
+  isec->markLive(off);
+  if (auto s = dyn_cast<ConcatInputSection>(isec)) {
+    assert(!s->isCoalescedWeak());
+    worklist.push_back(makeEntry(s, prev));
+  }
+}
+
+template <bool RecordWhyLive>
+void MarkLiveImpl<RecordWhyLive>::addSym(
+    Symbol *s,
+    const typename MarkLiveImpl<RecordWhyLive>::WorklistEntry *prev) {
+  if (s->used)
+    return;
+  s->used = true;
+  printWhyLive(s, prev);
+  if (auto *d = dyn_cast<Defined>(s)) {
+    if (d->isec)
+      enqueue(d->isec, d->value, prev);
+    if (d->unwindEntry)
+      enqueue(d->unwindEntry, 0, prev);
+  }
+}
+
+static void printWhyLiveImpl(const Symbol *s, const WhyLiveEntry *prev) {
+  std::string out = toString(*s) + " from " + toString(s->getFile());
+  int indent = 2;
+  for (const WhyLiveEntry *entry = prev; entry;
+       entry = entry->prev, indent += 2) {
+    const TinyPtrVector<Defined *> &symbols = entry->isec->symbols;
+    // With .subsections_with_symbols set, most isecs will have exactly one
+    // entry in their symbols vector, so we just print the first one.
+    if (!symbols.empty())
+      out += "\n" + std::string(indent, ' ') + toString(*symbols.front()) +
+             " from " + toString(symbols.front()->getFile());
+  }
+  message(out);
+}
+
+// NOTE: if/when `constexpr if` becomes available, we can simplify a lot of
+// the partial template specializations below.
+
+template <>
+void MarkLiveImpl<true>::printWhyLive(Symbol *s, const WhyLiveEntry *prev) {
+  if (!config->whyLive.empty() && config->whyLive.match(s->getName()))
+    printWhyLiveImpl(s, prev);
+}
+
+template <>
+void MarkLiveImpl<false>::printWhyLive(Symbol *s, const InputSection *prev) {}
+
+template <>
+const InputSection *
+MarkLiveImpl<true>::getInputSection(const WhyLiveEntry *entry) const {
+  return entry->isec;
+}
+
+template <>
+const InputSection *
+MarkLiveImpl<false>::getInputSection(const InputSection *isec) const {
+  return isec;
+}
+
+template <>
+typename MarkLiveImpl<true>::WorklistEntry *MarkLiveImpl<true>::makeEntry(
+    InputSection *isec, const MarkLiveImpl<true>::WorklistEntry *prev) const {
+  if (!isec) {
+    assert(!prev);
+    return nullptr;
+  }
+  return make<WhyLiveEntry>(isec, prev);
+}
+
+template <>
+typename MarkLiveImpl<false>::WorklistEntry *MarkLiveImpl<false>::makeEntry(
+    InputSection *isec, const MarkLiveImpl<false>::WorklistEntry *prev) const {
+  return isec;
+}
+
+template <bool RecordWhyLive>
+void MarkLiveImpl<RecordWhyLive>::markTransitively() {
+  do {
+    // Mark things reachable from GC roots as live.
+    while (!worklist.empty()) {
+      WorklistEntry *entry = worklist.pop_back_val();
+      // Entries that get placed onto the worklist always contain
+      // ConcatInputSections. `WhyLiveEntry::prev` may point to entries that
+      // contain other types of InputSections (due to S_ATTR_LIVE_SUPPORT), but
+      // those entries should never be pushed onto the worklist.
+      auto *isec = cast<ConcatInputSection>(getInputSection(entry));
+      assert(isec->live && "We mark as live when pushing onto the worklist!");
+
+      // Mark all symbols listed in the relocation table for this section.
+      for (const Reloc &r : isec->relocs) {
+        if (auto *s = r.referent.dyn_cast<Symbol *>())
+          addSym(s, entry);
+        else
+          enqueue(r.referent.get<InputSection *>(), r.addend, entry);
+      }
+      for (Defined *d : getInputSection(entry)->symbols)
+        addSym(d, entry);
+    }
+
+    // S_ATTR_LIVE_SUPPORT sections are live if they point _to_ a live
+    // section. Process them in a second pass.
+    for (ConcatInputSection *isec : inputSections) {
+      // FIXME: Check if copying all S_ATTR_LIVE_SUPPORT sections into a
+      // separate vector and only walking that here is faster.
+      if (!(isec->getFlags() & S_ATTR_LIVE_SUPPORT) || isec->live)
+        continue;
+
+      for (const Reloc &r : isec->relocs) {
+        if (auto *s = r.referent.dyn_cast<Symbol *>()) {
+          if (s->isLive()) {
+            InputSection *referentIsec = nullptr;
+            if (auto *d = dyn_cast<Defined>(s))
+              referentIsec = d->isec;
+            enqueue(isec, 0, makeEntry(referentIsec, nullptr));
+          }
+        } else {
+          auto *referentIsec = r.referent.get<InputSection *>();
+          if (referentIsec->isLive(r.addend))
+            enqueue(isec, 0, makeEntry(referentIsec, nullptr));
+        }
+      }
+    }
+
+    // S_ATTR_LIVE_SUPPORT could have marked additional sections live,
+    // which in turn could mark additional S_ATTR_LIVE_SUPPORT sections live.
+    // Iterate. In practice, the second iteration won't mark additional
+    // S_ATTR_LIVE_SUPPORT sections live.
+  } while (!worklist.empty());
+}
+
 // Set live bit on for each reachable chunk. Unmarked (unreachable)
 // InputSections will be ignored by Writer, so they will be excluded
 // from the final output.
 void markLive() {
   TimeTraceScope timeScope("markLive");
-
-  // We build up a worklist of sections which have been marked as live. We only
-  // push into the worklist when we discover an unmarked section, and we mark
-  // as we push, so sections never appear twice in the list.
-  // Literal sections cannot contain references to other sections, so we only
-  // store ConcatInputSections in our worklist.
-  SmallVector<ConcatInputSection *, 256> worklist;
-
-  auto enqueue = [&](InputSection *isec, uint64_t off) {
-    if (isec->isLive(off))
-      return;
-    isec->markLive(off);
-    if (auto s = dyn_cast<ConcatInputSection>(isec)) {
-      assert(!s->isCoalescedWeak());
-      worklist.push_back(s);
-    }
-  };
-
-  auto addSym = [&](Symbol *s) {
-    if (s->used)
-      return;
-    s->used = true;
-    if (auto *d = dyn_cast<Defined>(s)) {
-      if (d->isec)
-        enqueue(d->isec, d->value);
-      if (d->unwindEntry)
-        enqueue(d->unwindEntry, 0);
-    }
-  };
-
+  MarkLive *marker;
+  if (config->whyLive.empty())
+    marker = make<MarkLiveImpl<false>>();
+  else
+    marker = make<MarkLiveImpl<true>>();
   // Add GC roots.
   if (config->entry)
-    addSym(config->entry);
+    marker->addSym(config->entry);
   for (Symbol *sym : symtab->getSymbols()) {
     if (auto *defined = dyn_cast<Defined>(sym)) {
       // -exported_symbol(s_list)
       if (!config->exportedSymbols.empty() &&
           config->exportedSymbols.match(defined->getName())) {
-        // FIXME: Instead of doing this here, maybe the Driver code doing
-        // the matching should add them to explicitUndefineds? Then the
-        // explicitUndefineds code below would handle this automatically.
-        assert(!defined->privateExtern &&
-               "should have been rejected by driver");
-        addSym(defined);
+        // NOTE: Even though exporting private externs is an ill-defined
+        // operation, we are purposely not checking for privateExtern in
+        // order to follow ld64's behavior of treating all exported private
+        // extern symbols as live, irrespective of whether they are autohide.
+        marker->addSym(defined);
         continue;
       }
 
       // public symbols explicitly marked .no_dead_strip
       if (defined->referencedDynamically || defined->noDeadStrip) {
-        addSym(defined);
+        marker->addSym(defined);
         continue;
       }
 
-      // FIXME: When we implement these flags, make symbols from them GC roots:
+      // FIXME: When we implement these flags, make symbols from them GC
+      // roots:
       // * -reexported_symbol(s_list)
       // * -alias(-list)
       // * -init
@@ -89,80 +252,40 @@ void markLive() {
       bool externsAreRoots =
           config->outputType != MH_EXECUTE || config->exportDynamic;
       if (externsAreRoots && !defined->privateExtern) {
-        addSym(defined);
+        marker->addSym(defined);
         continue;
       }
     }
   }
   // -u symbols
   for (Symbol *sym : config->explicitUndefineds)
-    addSym(sym);
+    marker->addSym(sym);
   // local symbols explicitly marked .no_dead_strip
   for (const InputFile *file : inputFiles)
     if (auto *objFile = dyn_cast<ObjFile>(file))
       for (Symbol *sym : objFile->symbols)
         if (auto *defined = dyn_cast_or_null<Defined>(sym))
           if (!defined->isExternal() && defined->noDeadStrip)
-            addSym(defined);
+            marker->addSym(defined);
   if (auto *stubBinder =
           dyn_cast_or_null<DylibSymbol>(symtab->find("dyld_stub_binder")))
-    addSym(stubBinder);
+    marker->addSym(stubBinder);
   for (ConcatInputSection *isec : inputSections) {
     // Sections marked no_dead_strip
     if (isec->getFlags() & S_ATTR_NO_DEAD_STRIP) {
-      enqueue(isec, 0);
+      marker->enqueue(isec, 0);
       continue;
     }
 
     // mod_init_funcs, mod_term_funcs sections
     if (sectionType(isec->getFlags()) == S_MOD_INIT_FUNC_POINTERS ||
         sectionType(isec->getFlags()) == S_MOD_TERM_FUNC_POINTERS) {
-      enqueue(isec, 0);
+      marker->enqueue(isec, 0);
       continue;
     }
   }
 
-  do {
-    // Mark things reachable from GC roots as live.
-    while (!worklist.empty()) {
-      ConcatInputSection *s = worklist.pop_back_val();
-      assert(s->live && "We mark as live when pushing onto the worklist!");
-
-      // Mark all symbols listed in the relocation table for this section.
-      for (const Reloc &r : s->relocs) {
-        if (auto *s = r.referent.dyn_cast<Symbol *>())
-          addSym(s);
-        else
-          enqueue(r.referent.get<InputSection *>(), r.addend);
-      }
-      for (Defined *d : s->symbols)
-        addSym(d);
-    }
-
-    // S_ATTR_LIVE_SUPPORT sections are live if they point _to_ a live section.
-    // Process them in a second pass.
-    for (ConcatInputSection *isec : inputSections) {
-      // FIXME: Check if copying all S_ATTR_LIVE_SUPPORT sections into a
-      // separate vector and only walking that here is faster.
-      if (!(isec->getFlags() & S_ATTR_LIVE_SUPPORT) || isec->live)
-        continue;
-
-      for (const Reloc &r : isec->relocs) {
-        bool referentLive;
-        if (auto *s = r.referent.dyn_cast<Symbol *>())
-          referentLive = s->isLive();
-        else
-          referentLive = r.referent.get<InputSection *>()->isLive(r.addend);
-        if (referentLive)
-          enqueue(isec, 0);
-      }
-    }
-
-    // S_ATTR_LIVE_SUPPORT could have marked additional sections live,
-    // which in turn could mark additional S_ATTR_LIVE_SUPPORT sections live.
-    // Iterate. In practice, the second iteration won't mark additional
-    // S_ATTR_LIVE_SUPPORT sections live.
-  } while (!worklist.empty());
+  marker->markTransitively();
 }
 
 } // namespace macho
diff --git a/lld/MachO/ObjC.cpp b/lld/MachO/ObjC.cpp
index 3c40c5d7181b6..fbc129cf65896 100644
--- a/lld/MachO/ObjC.cpp
+++ b/lld/MachO/ObjC.cpp
@@ -40,7 +40,7 @@ template <class LP> static bool objectHasObjCSection(MemoryBufferRef mb) {
       if ((segname == segment_names::data &&
            sectname == section_names::objcCatList) ||
           (segname == segment_names::text &&
-           sectname == section_names::swift)) {
+           sectname.startswith(section_names::swift))) {
         return true;
       }
     }
diff --git a/lld/MachO/Options.td b/lld/MachO/Options.td
index ab79aa7d86701..c5f4636f0bf26 100644
--- a/lld/MachO/Options.td
+++ b/lld/MachO/Options.td
@@ -444,7 +444,6 @@ def no_pie : Flag<["-"], "no_pie">,
 def pagezero_size : Separate<["-"], "pagezero_size">,
     MetaVarName<"<size>">,
     HelpText<"Size of unreadable segment at address zero is hex <size> (default is 4KB on 32-bit and 4GB on 64-bit)">,
-    Flags<[HelpHidden]>,
     Group<grp_main>;
 def stack_size : Separate<["-"], "stack_size">,
     MetaVarName<"<size>">,
@@ -550,7 +549,6 @@ def whyload : Flag<["-"], "whyload">,
 def why_live : Separate<["-"], "why_live">,
     MetaVarName<"<symbol>">,
     HelpText<"Log a chain of references to <symbol>, for use with -dead_strip">,
-    Flags<[HelpHidden]>,
     Group<grp_introspect>;
 def print_statistics : Flag<["-"], "print_statistics">,
     HelpText<"Log the linker's memory and CPU usage">,
@@ -586,17 +584,14 @@ def S : Flag<["-"], "S">,
     Group<grp_symtab>;
 def x : Flag<["-"], "x">,
     HelpText<"Exclude non-global symbols from the output symbol table">,
-    Flags<[HelpHidden]>,
     Group<grp_symtab>;
 def non_global_symbols_strip_list : Separate<["-"], "non_global_symbols_strip_list">,
     MetaVarName<"<path>">,
     HelpText<"Specify in <path> the non-global symbols that should be removed from the output symbol table">,
-    Flags<[HelpHidden]>,
     Group<grp_symtab>;
 def non_global_symbols_no_strip_list : Separate<["-"], "non_global_symbols_no_strip_list">,
     MetaVarName<"<path>">,
     HelpText<"Specify in <path> the non-global symbols that should remain in the output symbol table">,
-    Flags<[HelpHidden]>,
     Group<grp_symtab>;
 def oso_prefix : Separate<["-"], "oso_prefix">,
     MetaVarName<"<path>">,
@@ -895,7 +890,6 @@ def e : Separate<["-"], "e">,
     Group<grp_rare>;
 def w : Flag<["-"], "w">,
     HelpText<"Suppress all warnings">,
-    Flags<[HelpHidden]>,
     Group<grp_rare>;
 def final_output : Separate<["-"], "final_output">,
     MetaVarName<"<name>">,
diff --git a/lld/MachO/OutputSection.cpp b/lld/MachO/OutputSection.cpp
index 8d7a29c2916ca..461d4f82b184a 100644
--- a/lld/MachO/OutputSection.cpp
+++ b/lld/MachO/OutputSection.cpp
@@ -13,9 +13,7 @@ using namespace llvm;
 using namespace lld;
 using namespace lld::macho;
 
-uint64_t OutputSection::getSegmentOffset() const {
-  return addr - parent->addr;
-}
+uint64_t OutputSection::getSegmentOffset() const { return addr - parent->addr; }
 
 void OutputSection::assignAddressesToStartEndSymbols() {
   for (Defined *d : sectionStartSymbols)
diff --git a/lld/MachO/Relocations.cpp b/lld/MachO/Relocations.cpp
index 2f316154a1cab..6f4b00c7acf91 100644
--- a/lld/MachO/Relocations.cpp
+++ b/lld/MachO/Relocations.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "Relocations.h"
+#include "ConcatOutputSection.h"
 #include "Symbols.h"
 #include "SyntheticSections.h"
 #include "Target.h"
@@ -24,33 +25,79 @@ bool macho::validateSymbolRelocation(const Symbol *sym,
                                      const InputSection *isec, const Reloc &r) {
   const RelocAttrs &relocAttrs = target->getRelocAttrs(r.type);
   bool valid = true;
-  auto message = [relocAttrs, sym, isec, &valid](const Twine &diagnostic) {
+  auto message = [&](const Twine &diagnostic) {
     valid = false;
-    return (relocAttrs.name + " relocation " + diagnostic + " for `" +
-            sym->getName() + "' in " + toString(isec))
+    return (isec->getLocation(r.offset) + ": " + relocAttrs.name +
+            " relocation " + diagnostic)
         .str();
   };
 
   if (relocAttrs.hasAttr(RelocAttrBits::TLV) != sym->isTlv())
-    error(message(Twine("requires that variable ") +
+    error(message(Twine("requires that symbol ") + sym->getName() + " " +
                   (sym->isTlv() ? "not " : "") + "be thread-local"));
 
   return valid;
 }
 
-void macho::reportRangeError(const Reloc &r, const Twine &v, uint8_t bits,
-                             int64_t min, uint64_t max) {
+// Given an offset in the output buffer, figure out which ConcatInputSection (if
+// any) maps to it. At the same time, update the offset such that it is relative
+// to the InputSection rather than to the output buffer.
+//
+// Obtaining the InputSection allows us to have better error diagnostics.
+// However, many of our relocation-handling methods do not take the InputSection
+// as a parameter. Since we are already passing the buffer offsets to our Target
+// methods, this function allows us to emit better errors without threading an
+// additional InputSection argument through the call stack.
+//
+// This is implemented as a slow linear search through OutputSegments,
+// OutputSections, and finally the InputSections themselves. However, this
+// function should be called only on error paths, so some overhead is fine.
+static InputSection *offsetToInputSection(uint64_t *off) {
+  for (OutputSegment *seg : outputSegments) {
+    if (*off < seg->fileOff || *off >= seg->fileOff + seg->fileSize)
+      continue;
+
+    const std::vector<OutputSection *> &sections = seg->getSections();
+    size_t osecIdx = 0;
+    for (; osecIdx < sections.size(); ++osecIdx)
+      if (*off < sections[osecIdx]->fileOff)
+        break;
+    assert(osecIdx > 0);
+    // We should be only calling this function on offsets that belong to
+    // ConcatOutputSections.
+    auto *osec = cast<ConcatOutputSection>(sections[osecIdx - 1]);
+    *off -= osec->fileOff;
+
+    size_t isecIdx = 0;
+    for (; isecIdx < osec->inputs.size(); ++isecIdx) {
+      const ConcatInputSection *isec = osec->inputs[isecIdx];
+      if (*off < isec->outSecOff)
+        break;
+    }
+    assert(isecIdx > 0);
+    ConcatInputSection *isec = osec->inputs[isecIdx - 1];
+    *off -= isec->outSecOff;
+    return isec;
+  }
+  return nullptr;
+}
+
+void macho::reportRangeError(void *loc, const Reloc &r, const Twine &v,
+                             uint8_t bits, int64_t min, uint64_t max) {
   std::string hint;
+  uint64_t off = reinterpret_cast<const uint8_t *>(loc) - in.bufferStart;
+  const InputSection *isec = offsetToInputSection(&off);
+  std::string locStr = isec ? isec->getLocation(off) : "(invalid location)";
   if (auto *sym = r.referent.dyn_cast<Symbol *>())
     hint = "; references " + toString(*sym);
-  // TODO: get location of reloc using something like LLD-ELF's getErrorPlace()
-  error("relocation " + target->getRelocAttrs(r.type).name +
+  error(locStr + ": relocation " + target->getRelocAttrs(r.type).name +
         " is out of range: " + v + " is not in [" + Twine(min) + ", " +
         Twine(max) + "]" + hint);
 }
 
-void macho::reportRangeError(SymbolDiagnostic d, const Twine &v, uint8_t bits,
-                             int64_t min, uint64_t max) {
+void macho::reportRangeError(void *loc, SymbolDiagnostic d, const Twine &v,
+                             uint8_t bits, int64_t min, uint64_t max) {
+  // FIXME: should we use `loc` somehow to provide a better error message?
   std::string hint;
   if (d.symbol)
     hint = "; references " + toString(*d.symbol);
diff --git a/lld/MachO/Relocations.h b/lld/MachO/Relocations.h
index 9457465ac203d..3c134d55cb201 100644
--- a/lld/MachO/Relocations.h
+++ b/lld/MachO/Relocations.h
@@ -61,6 +61,13 @@ struct Reloc {
   // gives the destination that this relocation refers to.
   int64_t addend = 0;
   llvm::PointerUnion<Symbol *, InputSection *> referent = nullptr;
+
+  Reloc() = default;
+
+  Reloc(uint8_t type, bool pcrel, uint8_t length, uint32_t offset,
+        int64_t addend, llvm::PointerUnion<Symbol *, InputSection *> referent)
+      : type(type), pcrel(pcrel), length(length), offset(offset),
+        addend(addend), referent(referent) {}
 };
 
 bool validateSymbolRelocation(const Symbol *, const InputSection *,
@@ -70,28 +77,28 @@ bool validateSymbolRelocation(const Symbol *, const InputSection *,
  * v: The value the relocation is attempting to encode
  * bits: The number of bits actually available to encode this relocation
  */
-void reportRangeError(const Reloc &, const llvm::Twine &v, uint8_t bits,
-                      int64_t min, uint64_t max);
+void reportRangeError(void *loc, const Reloc &, const llvm::Twine &v,
+                      uint8_t bits, int64_t min, uint64_t max);
 
 struct SymbolDiagnostic {
   const Symbol *symbol;
   llvm::StringRef reason;
 };
 
-void reportRangeError(SymbolDiagnostic, const llvm::Twine &v, uint8_t bits,
-                      int64_t min, uint64_t max);
+void reportRangeError(void *loc, SymbolDiagnostic, const llvm::Twine &v,
+                      uint8_t bits, int64_t min, uint64_t max);
 
 template <typename Diagnostic>
-inline void checkInt(Diagnostic d, int64_t v, int bits) {
+inline void checkInt(void *loc, Diagnostic d, int64_t v, int bits) {
   if (v != llvm::SignExtend64(v, bits))
-    reportRangeError(d, llvm::Twine(v), bits, llvm::minIntN(bits),
+    reportRangeError(loc, d, llvm::Twine(v), bits, llvm::minIntN(bits),
                      llvm::maxIntN(bits));
 }
 
 template <typename Diagnostic>
-inline void checkUInt(Diagnostic d, uint64_t v, int bits) {
+inline void checkUInt(void *loc, Diagnostic d, uint64_t v, int bits) {
   if ((v >> bits) != 0)
-    reportRangeError(d, llvm::Twine(v), bits, 0, llvm::maxUIntN(bits));
+    reportRangeError(loc, d, llvm::Twine(v), bits, 0, llvm::maxUIntN(bits));
 }
 
 inline void writeAddress(uint8_t *loc, uint64_t addr, uint8_t length) {
diff --git a/lld/MachO/SectionPriorities.cpp b/lld/MachO/SectionPriorities.cpp
index 35510d7338e89..cdabd3e9ef465 100644
--- a/lld/MachO/SectionPriorities.cpp
+++ b/lld/MachO/SectionPriorities.cpp
@@ -16,6 +16,7 @@
 #include "InputFiles.h"
 #include "Symbols.h"
 #include "Target.h"
+
 #include "lld/Common/Args.h"
 #include "lld/Common/CommonLinkerContext.h"
 #include "lld/Common/ErrorHandler.h"
@@ -33,7 +34,12 @@ using namespace llvm::sys;
 using namespace lld;
 using namespace lld::macho;
 
+PriorityBuilder macho::priorityBuilder;
+
 namespace {
+
+size_t highestAvailablePriority = std::numeric_limits<size_t>::max();
+
 struct Edge {
   int from;
   uint64_t weight;
@@ -58,7 +64,7 @@ struct Cluster {
 
 class CallGraphSort {
 public:
-  CallGraphSort();
+  CallGraphSort(const MapVector<SectionPair, uint64_t> &profile);
 
   DenseMap<const InputSection *, size_t> run();
 
@@ -71,13 +77,9 @@ class CallGraphSort {
 constexpr int MAX_DENSITY_DEGRADATION = 8;
 } // end anonymous namespace
 
-using SectionPair = std::pair<const InputSection *, const InputSection *>;
-
-// Take the edge list in config->callGraphProfile, resolve symbol names to
-// Symbols, and generate a graph between InputSections with the provided
-// weights.
-CallGraphSort::CallGraphSort() {
-  MapVector<SectionPair, uint64_t> &profile = config->callGraphProfile;
+// Take the edge list in callGraphProfile, resolve symbol names to Symbols, and
+// generate a graph between InputSections with the provided weights.
+CallGraphSort::CallGraphSort(const MapVector<SectionPair, uint64_t> &profile) {
   DenseMap<const InputSection *, int> secToCluster;
 
   auto getOrCreateCluster = [&](const InputSection *isec) -> int {
@@ -90,7 +92,7 @@ CallGraphSort::CallGraphSort() {
   };
 
   // Create the graph
-  for (std::pair<SectionPair, uint64_t> &c : profile) {
+  for (const std::pair<SectionPair, uint64_t> &c : profile) {
     const auto fromSec = c.first.first->canonical();
     const auto toSec = c.first.second->canonical();
     uint64_t weight = c.second;
@@ -208,7 +210,7 @@ DenseMap<const InputSection *, size_t> CallGraphSort::run() {
   // priority 0 and be placed at the end of sections.
   // NB: This is opposite from COFF/ELF to be compatible with the existing
   // order-file code.
-  int curOrder = clusters.size();
+  int curOrder = highestAvailablePriority;
   for (int leader : sorted) {
     for (int i = leader;;) {
       orderMap[sections[i]] = curOrder--;
@@ -247,8 +249,17 @@ DenseMap<const InputSection *, size_t> CallGraphSort::run() {
   return orderMap;
 }
 
-static size_t getSymbolPriority(const SymbolPriorityEntry &entry,
-                                const InputFile *f) {
+Optional<size_t> macho::PriorityBuilder::getSymbolPriority(const Defined *sym) {
+  if (sym->isAbsolute())
+    return None;
+
+  auto it = priorities.find(sym->getName());
+  if (it == priorities.end())
+    return None;
+  const SymbolPriorityEntry &entry = it->second;
+  const InputFile *f = sym->isec->getFile();
+  if (!f)
+    return entry.anyObjectFile;
   // We don't use toString(InputFile *) here because it returns the full path
   // for object files, and we only want the basename.
   StringRef filename;
@@ -260,8 +271,9 @@ static size_t getSymbolPriority(const SymbolPriorityEntry &entry,
   return std::max(entry.objectFiles.lookup(filename), entry.anyObjectFile);
 }
 
-void macho::extractCallGraphProfile() {
+void macho::PriorityBuilder::extractCallGraphProfile() {
   TimeTraceScope timeScope("Extract call graph profile");
+  bool hasOrderFile = !priorities.empty();
   for (const InputFile *file : inputFiles) {
     auto *obj = dyn_cast_or_null<ObjFile>(file);
     if (!obj)
@@ -271,15 +283,17 @@ void macho::extractCallGraphProfile() {
              entry.toIndex < obj->symbols.size());
       auto *fromSym = dyn_cast_or_null<Defined>(obj->symbols[entry.fromIndex]);
       auto *toSym = dyn_cast_or_null<Defined>(obj->symbols[entry.toIndex]);
-
-      if (!fromSym || !toSym)
-        continue;
-      config->callGraphProfile[{fromSym->isec, toSym->isec}] += entry.count;
+      if (fromSym && toSym &&
+          (!hasOrderFile ||
+           (!getSymbolPriority(fromSym) && !getSymbolPriority(toSym))))
+        callGraphProfile[{fromSym->isec, toSym->isec}] += entry.count;
     }
   }
 }
 
-void macho::parseOrderFile(StringRef path) {
+void macho::PriorityBuilder::parseOrderFile(StringRef path) {
+  assert(callGraphProfile.empty() &&
+         "Order file must be parsed before call graph profile is processed");
   Optional<MemoryBufferRef> buffer = readFile(path);
   if (!buffer) {
     error("Could not read order file at " + path);
@@ -287,7 +301,6 @@ void macho::parseOrderFile(StringRef path) {
   }
 
   MemoryBufferRef mbref = *buffer;
-  size_t priority = std::numeric_limits<size_t>::max();
   for (StringRef line : args::getLines(mbref)) {
     StringRef objectFile, symbol;
     line = line.take_until([](char c) { return c == '#'; }); // ignore comments
@@ -322,49 +335,42 @@ void macho::parseOrderFile(StringRef path) {
     symbol = line.trim();
 
     if (!symbol.empty()) {
-      SymbolPriorityEntry &entry = config->priorities[symbol];
+      SymbolPriorityEntry &entry = priorities[symbol];
       if (!objectFile.empty())
-        entry.objectFiles.insert(std::make_pair(objectFile, priority));
+        entry.objectFiles.insert(
+            std::make_pair(objectFile, highestAvailablePriority));
       else
-        entry.anyObjectFile = std::max(entry.anyObjectFile, priority);
+        entry.anyObjectFile =
+            std::max(entry.anyObjectFile, highestAvailablePriority);
     }
 
-    --priority;
+    --highestAvailablePriority;
   }
 }
 
-// Sort sections by the profile data provided by __LLVM,__cg_profile sections.
-//
-// This first builds a call graph based on the profile data then merges sections
-// according to the C heuristic. All clusters are then sorted by a density
-// metric to further improve locality.
-static DenseMap<const InputSection *, size_t> computeCallGraphProfileOrder() {
-  TimeTraceScope timeScope("Call graph profile sort");
-  return CallGraphSort().run();
-}
-
-// Each section gets assigned the priority of the highest-priority symbol it
-// contains.
-DenseMap<const InputSection *, size_t> macho::buildInputSectionPriorities() {
-  if (config->callGraphProfileSort)
-    return computeCallGraphProfileOrder();
+DenseMap<const InputSection *, size_t>
+macho::PriorityBuilder::buildInputSectionPriorities() {
   DenseMap<const InputSection *, size_t> sectionPriorities;
+  if (config->callGraphProfileSort) {
+    // Sort sections by the profile data provided by __LLVM,__cg_profile
+    // sections.
+    //
+    // This first builds a call graph based on the profile data then merges
+    // sections according to the C heuristic. All clusters are then sorted by a
+    // density metric to further improve locality.
+    TimeTraceScope timeScope("Call graph profile sort");
+    sectionPriorities = CallGraphSort(callGraphProfile).run();
+  }
 
-  if (config->priorities.empty())
+  if (priorities.empty())
     return sectionPriorities;
 
-  auto addSym = [&](Defined &sym) {
-    if (sym.isAbsolute())
+  auto addSym = [&](const Defined *sym) {
+    Optional<size_t> symbolPriority = getSymbolPriority(sym);
+    if (!symbolPriority.hasValue())
       return;
-
-    auto it = config->priorities.find(sym.getName());
-    if (it == config->priorities.end())
-      return;
-
-    SymbolPriorityEntry &entry = it->second;
-    size_t &priority = sectionPriorities[sym.isec];
-    priority =
-        std::max(priority, getSymbolPriority(entry, sym.isec->getFile()));
+    size_t &priority = sectionPriorities[sym->isec];
+    priority = std::max(priority, symbolPriority.getValue());
   };
 
   // TODO: Make sure this handles weak symbols correctly.
@@ -372,7 +378,7 @@ DenseMap<const InputSection *, size_t> macho::buildInputSectionPriorities() {
     if (isa<ObjFile>(file))
       for (Symbol *sym : file->symbols)
         if (auto *d = dyn_cast_or_null<Defined>(sym))
-          addSym(*d);
+          addSym(d);
   }
 
   return sectionPriorities;
diff --git a/lld/MachO/SectionPriorities.h b/lld/MachO/SectionPriorities.h
index 9cc4eff958cd7..d27fef92f559f 100644
--- a/lld/MachO/SectionPriorities.h
+++ b/lld/MachO/SectionPriorities.h
@@ -15,40 +15,67 @@
 namespace lld {
 namespace macho {
 
-// Reads every input section's call graph profile, and combines them into
-// config->callGraphProfile. If an order file is present, any edges where one
-// or both of the vertices are specified in the order file are discarded.
-void extractCallGraphProfile();
+using SectionPair = std::pair<const InputSection *, const InputSection *>;
 
-// Reads the order file at `path` into config->priorities.
-//
-// An order file has one entry per line, in the following format:
-//
-//   <cpu>:<object file>:<symbol name>
-//
-// <cpu> and <object file> are optional. If not specified, then that entry
-// matches any symbol of that name. Parsing this format is not quite
-// straightforward because the symbol name itself can contain colons, so when
-// encountering a colon, we consider the preceding characters to decide if it
-// can be a valid CPU type or file path.
-//
-// If a symbol is matched by multiple entries, then it takes the lowest-ordered
-// entry (the one nearest to the front of the list.)
-//
-// The file can also have line comments that start with '#'.
-void parseOrderFile(StringRef path);
+class PriorityBuilder {
+public:
+  // Reads every input section's call graph profile, and combines them into
+  // callGraphProfile. If an order file is present, any edges where one or both
+  // of the vertices are specified in the order file are discarded.
+  void extractCallGraphProfile();
 
-// Returns layout priorities for some or all input sections. Sections are laid
-// out in decreasing order; that is, a higher priority section will be closer
-// to the beginning of its output section.
-//
-// If either an order file or a call graph profile are present, this is used
-// as the source of priorities. If both are present, the order file takes
-// precedence. If neither is present, an empty map is returned.
-//
-// Each section gets assigned the priority of the highest-priority symbol it
-// contains.
-llvm::DenseMap<const InputSection *, size_t> buildInputSectionPriorities();
+  // Reads the order file at `path` into config->priorities.
+  //
+  // An order file has one entry per line, in the following format:
+  //
+  //   <cpu>:<object file>:<symbol name>
+  //
+  // <cpu> and <object file> are optional. If not specified, then that entry
+  // matches any symbol of that name. Parsing this format is not quite
+  // straightforward because the symbol name itself can contain colons, so when
+  // encountering a colon, we consider the preceding characters to decide if it
+  // can be a valid CPU type or file path.
+  //
+  // If a symbol is matched by multiple entries, then it takes the
+  // lowest-ordered entry (the one nearest to the front of the list.)
+  //
+  // The file can also have line comments that start with '#'.
+  void parseOrderFile(StringRef path);
+
+  // Returns layout priorities for some or all input sections. Sections are laid
+  // out in decreasing order; that is, a higher priority section will be closer
+  // to the beginning of its output section.
+  //
+  // If either an order file or a call graph profile are present, this is used
+  // as the source of priorities. If both are present, the order file takes
+  // precedence, but the call graph profile is still used for symbols that don't
+  // appear in the order file. If neither is present, an empty map is returned.
+  //
+  // Each section gets assigned the priority of the highest-priority symbol it
+  // contains.
+  llvm::DenseMap<const InputSection *, size_t> buildInputSectionPriorities();
+
+private:
+  // The symbol with the highest priority should be ordered first in the output
+  // section (modulo input section contiguity constraints). Using priority
+  // (highest first) instead of order (lowest first) has the convenient property
+  // that the default-constructed zero priority -- for symbols/sections without
+  // a user-defined order -- naturally ends up putting them at the end of the
+  // output.
+  struct SymbolPriorityEntry {
+    // The priority given to a matching symbol, regardless of which object file
+    // it originated from.
+    size_t anyObjectFile = 0;
+    // The priority given to a matching symbol from a particular object file.
+    llvm::DenseMap<llvm::StringRef, size_t> objectFiles;
+  };
+
+  llvm::Optional<size_t> getSymbolPriority(const Defined *sym);
+  llvm::DenseMap<llvm::StringRef, SymbolPriorityEntry> priorities;
+  llvm::MapVector<SectionPair, uint64_t> callGraphProfile;
+};
+
+extern PriorityBuilder priorityBuilder;
 } // namespace macho
 } // namespace lld
 
diff --git a/lld/MachO/SymbolTable.cpp b/lld/MachO/SymbolTable.cpp
index c7017c8a000dc..b9248e6f381c9 100644
--- a/lld/MachO/SymbolTable.cpp
+++ b/lld/MachO/SymbolTable.cpp
@@ -83,7 +83,7 @@ Defined *SymbolTable::addDefined(StringRef name, InputFile *file,
           concatIsec->symbols.erase(llvm::find(concatIsec->symbols, defined));
         }
       } else {
-        error("duplicate symbol: " + name + "\n>>> defined in " +
+        error("duplicate symbol: " + toString(*defined) + "\n>>> defined in " +
               toString(defined->getFile()) + "\n>>> defined in " +
               toString(file));
       }
@@ -96,10 +96,16 @@ Defined *SymbolTable::addDefined(StringRef name, InputFile *file,
     // of a name conflict, we fall through to the replaceSymbol() call below.
   }
 
+  // With -flat_namespace, all extern symbols in dylibs are interposable.
+  // FIXME: Add support for `-interposable` (PR53680).
+  bool interposable = config->namespaceKind == NamespaceKind::flat &&
+                      config->outputType != MachO::MH_EXECUTE &&
+                      !isPrivateExtern;
   Defined *defined = replaceSymbol<Defined>(
       s, name, file, isec, value, size, isWeakDef, /*isExternal=*/true,
-      isPrivateExtern, isThumb, isReferencedDynamically, noDeadStrip,
-      overridesWeakDef, isWeakDefCanBeHidden);
+      isPrivateExtern, /*includeInSymtab=*/true, isThumb,
+      isReferencedDynamically, noDeadStrip, overridesWeakDef,
+      isWeakDefCanBeHidden, interposable);
   return defined;
 }
 
@@ -225,11 +231,12 @@ Defined *SymbolTable::addSynthetic(StringRef name, InputSection *isec,
                                    uint64_t value, bool isPrivateExtern,
                                    bool includeInSymtab,
                                    bool referencedDynamically) {
+  assert(!isec || !isec->getFile()); // See makeSyntheticInputSection().
   Defined *s =
-      addDefined(name, nullptr, isec, value, /*size=*/0,
-                 /*isWeakDef=*/false, isPrivateExtern,
-                 /*isThumb=*/false, referencedDynamically,
-                 /*noDeadStrip=*/false, /*isWeakDefCanBeHidden=*/false);
+      addDefined(name, /*file=*/nullptr, isec, value, /*size=*/0,
+                 /*isWeakDef=*/false, isPrivateExtern, /*isThumb=*/false,
+                 referencedDynamically, /*noDeadStrip=*/false,
+                 /*isWeakDefCanBeHidden=*/false);
   s->includeInSymtab = includeInSymtab;
   return s;
 }
@@ -266,7 +273,7 @@ static void handleSectionBoundarySymbol(const Undefined &sym, StringRef segSect,
     }
 
   if (!osec) {
-    ConcatInputSection *isec = make<ConcatInputSection>(segName, sectName);
+    ConcatInputSection *isec = makeSyntheticInputSection(segName, sectName);
 
     // This runs after markLive() and is only called for Undefineds that are
     // live. Marking the isec live ensures an OutputSection is created that the
diff --git a/lld/MachO/Symbols.cpp b/lld/MachO/Symbols.cpp
index 7bf8c6dd56d63..31ee4c65fe6d4 100644
--- a/lld/MachO/Symbols.cpp
+++ b/lld/MachO/Symbols.cpp
@@ -15,13 +15,13 @@ using namespace llvm;
 using namespace lld;
 using namespace lld::macho;
 
-static_assert(sizeof(void *) != 8 || sizeof(Symbol) == 48,
+static_assert(sizeof(void *) != 8 || sizeof(Symbol) == 56,
               "Try to minimize Symbol's size; we create many instances");
 
 // The Microsoft ABI doesn't support using parent class tail padding for child
 // members, hence the _MSC_VER check.
 #if !defined(_MSC_VER)
-static_assert(sizeof(void *) != 8 || sizeof(Defined) == 80,
+static_assert(sizeof(void *) != 8 || sizeof(Defined) == 88,
               "Try to minimize Defined's size; we create many instances");
 #endif
 
@@ -42,14 +42,17 @@ uint64_t Symbol::getTlvVA() const { return in.tlvPointers->getVA(gotIndex); }
 
 Defined::Defined(StringRefZ name, InputFile *file, InputSection *isec,
                  uint64_t value, uint64_t size, bool isWeakDef, bool isExternal,
-                 bool isPrivateExtern, bool isThumb,
+                 bool isPrivateExtern, bool includeInSymtab, bool isThumb,
                  bool isReferencedDynamically, bool noDeadStrip,
-                 bool canOverrideWeakDef, bool isWeakDefCanBeHidden)
+                 bool canOverrideWeakDef, bool isWeakDefCanBeHidden,
+                 bool interposable)
     : Symbol(DefinedKind, name, file), overridesWeakDef(canOverrideWeakDef),
-      privateExtern(isPrivateExtern), includeInSymtab(true), thumb(isThumb),
+      privateExtern(isPrivateExtern), includeInSymtab(includeInSymtab),
+      wasIdenticalCodeFolded(false), thumb(isThumb),
       referencedDynamically(isReferencedDynamically), noDeadStrip(noDeadStrip),
-      weakDefCanBeHidden(isWeakDefCanBeHidden), weakDef(isWeakDef),
-      external(isExternal), isec(isec), value(value), size(size) {
+      interposable(interposable), weakDefCanBeHidden(isWeakDefCanBeHidden),
+      weakDef(isWeakDef), external(isExternal), isec(isec), value(value),
+      size(size) {
   if (isec) {
     isec->symbols.push_back(this);
     // Maintain sorted order.
diff --git a/lld/MachO/Symbols.h b/lld/MachO/Symbols.h
index b3d86b0d3cadc..227244711c08e 100644
--- a/lld/MachO/Symbols.h
+++ b/lld/MachO/Symbols.h
@@ -63,7 +63,7 @@ class Symbol {
   // Only undefined or dylib symbols can be weak references. A weak reference
   // need not be satisfied at runtime, e.g. due to the symbol not being
   // available on a given target platform.
-  virtual bool isWeakRef() const { llvm_unreachable("cannot be a weak ref"); }
+  virtual bool isWeakRef() const { return false; }
 
   virtual bool isTlv() const { llvm_unreachable("cannot be TLV"); }
 
@@ -87,9 +87,9 @@ class Symbol {
   // on whether it is a thread-local. A given symbol cannot be referenced by
   // both these sections at once.
   uint32_t gotIndex = UINT32_MAX;
-
+  uint32_t lazyBindOffset = UINT32_MAX;
+  uint32_t stubsHelperIndex = UINT32_MAX;
   uint32_t stubsIndex = UINT32_MAX;
-
   uint32_t symtabIndex = UINT32_MAX;
 
   InputFile *getFile() const { return file; }
@@ -109,7 +109,7 @@ class Symbol {
   // True if this symbol was referenced by a regular (non-bitcode) object.
   bool isUsedInRegularObj : 1;
 
-  // True if an undefined or dylib symbol is used from a live section.
+  // True if this symbol is used from a live section.
   bool used : 1;
 };
 
@@ -117,8 +117,9 @@ class Defined : public Symbol {
 public:
   Defined(StringRefZ name, InputFile *file, InputSection *isec, uint64_t value,
           uint64_t size, bool isWeakDef, bool isExternal, bool isPrivateExtern,
-          bool isThumb, bool isReferencedDynamically, bool noDeadStrip,
-          bool canOverrideWeakDef = false, bool isWeakDefCanBeHidden = false);
+          bool includeInSymtab, bool isThumb, bool isReferencedDynamically,
+          bool noDeadStrip, bool canOverrideWeakDef = false,
+          bool isWeakDefCanBeHidden = false, bool interposable = false);
 
   bool isWeakDef() const override { return weakDef; }
   bool isExternalWeakDef() const {
@@ -144,6 +145,8 @@ class Defined : public Symbol {
   bool privateExtern : 1;
   // Whether this symbol should appear in the output symbol table.
   bool includeInSymtab : 1;
+  // Whether this symbol was folded into a different symbol during ICF.
+  bool wasIdenticalCodeFolded : 1;
   // Only relevant when compiling for Thumb-supporting arm32 archs.
   bool thumb : 1;
   // Symbols marked referencedDynamically won't be removed from the output's
@@ -158,6 +161,14 @@ class Defined : public Symbol {
   // metadata. This is information only for the static linker and not written
   // to the output.
   bool noDeadStrip : 1;
+  // Whether references to this symbol can be interposed at runtime to point to
+  // a different symbol definition (with the same name). For example, if both
+  // dylib A and B define an interposable symbol _foo, and we load A before B at
+  // runtime, then all references to _foo within dylib B will point to the
+  // definition in dylib A.
+  //
+  // Only extern symbols may be interposable.
+  bool interposable : 1;
 
   bool weakDefCanBeHidden : 1;
 
@@ -172,6 +183,7 @@ class Defined : public Symbol {
   uint64_t value;
   // size is only calculated for regular (non-bitcode) symbols.
   uint64_t size;
+  // This can be a subsection of either __compact_unwind or __eh_frame.
   ConcatInputSection *unwindEntry = nullptr;
 };
 
@@ -258,9 +270,6 @@ class DylibSymbol : public Symbol {
 
   static bool classof(const Symbol *s) { return s->kind() == DylibKind; }
 
-  uint32_t stubsHelperIndex = UINT32_MAX;
-  uint32_t lazyBindOffset = UINT32_MAX;
-
   RefState getRefState() const { return refState; }
 
   void reference(RefState newState) {
diff --git a/lld/MachO/SyntheticSections.cpp b/lld/MachO/SyntheticSections.cpp
index 3fe551f5684b6..d7ae0d92b226f 100644
--- a/lld/MachO/SyntheticSections.cpp
+++ b/lld/MachO/SyntheticSections.cpp
@@ -49,7 +49,7 @@ std::vector<SyntheticSection *> macho::syntheticSections;
 SyntheticSection::SyntheticSection(const char *segname, const char *name)
     : OutputSection(SyntheticKind, name) {
   std::tie(this->segname, this->name) = maybeRenameSection({segname, name});
-  isec = make<ConcatInputSection>(segname, name);
+  isec = makeSyntheticInputSection(segname, name);
   isec->parent = this;
   syntheticSections.push_back(this);
 }
@@ -235,6 +235,8 @@ void macho::addNonLazyBindingEntries(const Symbol *sym,
     in.rebase->addEntry(isec, offset);
     if (defined->isExternalWeakDef())
       in.weakBinding->addEntry(sym, isec, offset, addend);
+    else if (defined->interposable)
+      in.binding->addEntry(sym, isec, offset, addend);
   } else {
     // Undefined symbols are filtered out in scanRelocations(); we should never
     // get here
@@ -417,6 +419,13 @@ static int16_t ordinalForDylibSymbol(const DylibSymbol &dysym) {
   return dysym.getFile()->ordinal;
 }
 
+static int16_t ordinalForSymbol(const Symbol &sym) {
+  if (const auto *dysym = dyn_cast<DylibSymbol>(&sym))
+    return ordinalForDylibSymbol(*dysym);
+  assert(cast<Defined>(&sym)->interposable);
+  return BIND_SPECIAL_DYLIB_FLAT_LOOKUP;
+}
+
 static void encodeDylibOrdinal(int16_t ordinal, raw_svector_ostream &os) {
   if (ordinal <= 0) {
     os << static_cast<uint8_t>(BIND_OPCODE_SET_DYLIB_SPECIAL_IMM |
@@ -486,14 +495,14 @@ void BindingSection::finalizeContents() {
   int16_t lastOrdinal = 0;
 
   for (auto &p : sortBindings(bindingsMap)) {
-    const DylibSymbol *sym = p.first;
+    const Symbol *sym = p.first;
     std::vector<BindingEntry> &bindings = p.second;
     uint8_t flags = BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM;
     if (sym->isWeakRef())
       flags |= BIND_SYMBOL_FLAGS_WEAK_IMPORT;
     os << flags << sym->getName() << '\0'
        << static_cast<uint8_t>(BIND_OPCODE_SET_TYPE_IMM | BIND_TYPE_POINTER);
-    int16_t ordinal = ordinalForDylibSymbol(*sym);
+    int16_t ordinal = ordinalForSymbol(*sym);
     if (ordinal != lastOrdinal) {
       encodeDylibOrdinal(ordinal, os);
       lastOrdinal = ordinal;
@@ -596,7 +605,7 @@ bool StubHelperSection::isNeeded() const { return in.lazyBinding->isNeeded(); }
 void StubHelperSection::writeTo(uint8_t *buf) const {
   target->writeStubHelperHeader(buf);
   size_t off = target->stubHelperHeaderSize;
-  for (const DylibSymbol *sym : in.lazyBinding->getEntries()) {
+  for (const Symbol *sym : in.lazyBinding->getEntries()) {
     target->writeStubHelperEntry(buf + off, *sym, addr + off);
     off += target->stubHelperEntrySize;
   }
@@ -625,6 +634,7 @@ void StubHelperSection::setup() {
       make<Defined>("__dyld_private", nullptr, in.imageLoaderCache, 0, 0,
                     /*isWeakDef=*/false,
                     /*isExternal=*/false, /*isPrivateExtern=*/false,
+                    /*includeInSymtab=*/true,
                     /*isThumb=*/false, /*isReferencedDynamically=*/false,
                     /*noDeadStrip=*/false);
   dyldPrivate->used = true;
@@ -667,7 +677,7 @@ LazyBindingSection::LazyBindingSection()
 void LazyBindingSection::finalizeContents() {
   // TODO: Just precompute output size here instead of writing to a temporary
   // buffer
-  for (DylibSymbol *sym : entries)
+  for (Symbol *sym : entries)
     sym->lazyBindOffset = encode(*sym);
 }
 
@@ -675,11 +685,11 @@ void LazyBindingSection::writeTo(uint8_t *buf) const {
   memcpy(buf, contents.data(), contents.size());
 }
 
-void LazyBindingSection::addEntry(DylibSymbol *dysym) {
-  if (entries.insert(dysym)) {
-    dysym->stubsHelperIndex = entries.size() - 1;
+void LazyBindingSection::addEntry(Symbol *sym) {
+  if (entries.insert(sym)) {
+    sym->stubsHelperIndex = entries.size() - 1;
     in.rebase->addEntry(in.lazyPointers->isec,
-                        dysym->stubsIndex * target->wordSize);
+                        sym->stubsIndex * target->wordSize);
   }
 }
 
@@ -689,15 +699,15 @@ void LazyBindingSection::addEntry(DylibSymbol *dysym) {
 // BIND_OPCODE_DONE terminator. As such, unlike in the non-lazy-binding case,
 // we cannot encode just the differences between symbols; we have to emit the
 // complete bind information for each symbol.
-uint32_t LazyBindingSection::encode(const DylibSymbol &sym) {
+uint32_t LazyBindingSection::encode(const Symbol &sym) {
   uint32_t opstreamOffset = contents.size();
   OutputSegment *dataSeg = in.lazyPointers->parent;
   os << static_cast<uint8_t>(BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB |
                              dataSeg->index);
-  uint64_t offset = in.lazyPointers->addr - dataSeg->addr +
-                    sym.stubsIndex * target->wordSize;
+  uint64_t offset =
+      in.lazyPointers->addr - dataSeg->addr + sym.stubsIndex * target->wordSize;
   encodeULEB128(offset, os);
-  encodeDylibOrdinal(ordinalForDylibSymbol(sym), os);
+  encodeDylibOrdinal(ordinalForSymbol(sym), os);
 
   uint8_t flags = BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM;
   if (sym.isWeakRef())
@@ -748,20 +758,20 @@ static std::vector<MachO::data_in_code_entry> collectDataInCodeEntries() {
     // For each code subsection find 'data in code' entries residing in it.
     // Compute the new offset values as
     // <offset within subsection> + <subsection address> - <__TEXT address>.
-    for (const Section &section : objFile->sections) {
-      for (const Subsection &subsec : section.subsections) {
+    for (const Section *section : objFile->sections) {
+      for (const Subsection &subsec : section->subsections) {
         const InputSection *isec = subsec.isec;
         if (!isCodeSection(isec))
           continue;
         if (cast<ConcatInputSection>(isec)->shouldOmitFromOutput())
           continue;
-        const uint64_t beginAddr = section.address + subsec.offset;
+        const uint64_t beginAddr = section->addr + subsec.offset;
         auto it = llvm::lower_bound(
             entries, beginAddr,
             [](const MachO::data_in_code_entry &entry, uint64_t addr) {
               return entry.offset < addr;
             });
-        const uint64_t endAddr = beginAddr + isec->getFileSize();
+        const uint64_t endAddr = beginAddr + isec->getSize();
         for (const auto end = entries.end();
              it != end && it->offset + it->length <= endAddr; ++it)
           dataInCodeEntries.push_back(
@@ -880,32 +890,46 @@ void SymtabSection::emitStabs() {
     stabs.emplace_back(std::move(astStab));
   }
 
-  std::vector<Defined *> symbolsNeedingStabs;
+  // Cache the file ID for each symbol in an std::pair for faster sorting.
+  using SortingPair = std::pair<Defined *, int>;
+  std::vector<SortingPair> symbolsNeedingStabs;
   for (const SymtabEntry &entry :
        concat<SymtabEntry>(localSymbols, externalSymbols)) {
     Symbol *sym = entry.sym;
     assert(sym->isLive() &&
            "dead symbols should not be in localSymbols, externalSymbols");
     if (auto *defined = dyn_cast<Defined>(sym)) {
+      // Excluded symbols should have been filtered out in finalizeContents().
+      assert(defined->includeInSymtab);
+
       if (defined->isAbsolute())
         continue;
+
+      // Constant-folded symbols go in the executable's symbol table, but don't
+      // get a stabs entry.
+      if (defined->wasIdenticalCodeFolded)
+        continue;
+
       InputSection *isec = defined->isec;
       ObjFile *file = dyn_cast_or_null<ObjFile>(isec->getFile());
       if (!file || !file->compileUnit)
         continue;
-      symbolsNeedingStabs.push_back(defined);
+
+      symbolsNeedingStabs.emplace_back(defined, defined->isec->getFile()->id);
     }
   }
 
-  llvm::stable_sort(symbolsNeedingStabs, [&](Defined *a, Defined *b) {
-    return a->isec->getFile()->id < b->isec->getFile()->id;
-  });
+  llvm::stable_sort(symbolsNeedingStabs,
+                    [&](const SortingPair &a, const SortingPair &b) {
+                      return a.second < b.second;
+                    });
 
   // Emit STABS symbols so that dsymutil and/or the debugger can map address
   // regions in the final binary to the source and object files from which they
   // originated.
   InputFile *lastFile = nullptr;
-  for (Defined *defined : symbolsNeedingStabs) {
+  for (SortingPair &pair : symbolsNeedingStabs) {
+    Defined *defined = pair.first;
     InputSection *isec = defined->isec;
     ObjFile *file = cast<ObjFile>(isec->getFile());
 
@@ -943,16 +967,42 @@ void SymtabSection::finalizeContents() {
     symbols.push_back({sym, strx});
   };
 
+  std::function<void(Symbol *)> localSymbolsHandler;
+  switch (config->localSymbolsPresence) {
+  case SymtabPresence::All:
+    localSymbolsHandler = [&](Symbol *sym) { addSymbol(localSymbols, sym); };
+    break;
+  case SymtabPresence::None:
+    localSymbolsHandler = [&](Symbol *) { /* Do nothing*/ };
+    break;
+  case SymtabPresence::SelectivelyIncluded:
+    localSymbolsHandler = [&](Symbol *sym) {
+      if (config->localSymbolPatterns.match(sym->getName()))
+        addSymbol(localSymbols, sym);
+    };
+    break;
+  case SymtabPresence::SelectivelyExcluded:
+    localSymbolsHandler = [&](Symbol *sym) {
+      if (!config->localSymbolPatterns.match(sym->getName()))
+        addSymbol(localSymbols, sym);
+    };
+    break;
+  }
+
   // Local symbols aren't in the SymbolTable, so we walk the list of object
   // files to gather them.
-  for (const InputFile *file : inputFiles) {
-    if (auto *objFile = dyn_cast<ObjFile>(file)) {
-      for (Symbol *sym : objFile->symbols) {
-        if (auto *defined = dyn_cast_or_null<Defined>(sym)) {
-          if (!defined->isExternal() && defined->isLive()) {
-            StringRef name = defined->getName();
-            if (!name.startswith("l") && !name.startswith("L"))
-              addSymbol(localSymbols, sym);
+  // But if `-x` is set, then we don't need to. localSymbolsHandler() will do
+  // the right thing regardless, but this check is a perf optimization because
+  // iterating through all the input files and their symbols is expensive.
+  if (config->localSymbolsPresence != SymtabPresence::None) {
+    for (const InputFile *file : inputFiles) {
+      if (auto *objFile = dyn_cast<ObjFile>(file)) {
+        for (Symbol *sym : objFile->symbols) {
+          if (auto *defined = dyn_cast_or_null<Defined>(sym)) {
+            if (defined->isExternal() || !defined->isLive() ||
+                !defined->includeInSymtab)
+              continue;
+            localSymbolsHandler(sym);
           }
         }
       }
@@ -962,7 +1012,7 @@ void SymtabSection::finalizeContents() {
   // __dyld_private is a local symbol too. It's linker-created and doesn't
   // exist in any object file.
   if (Defined *dyldPrivate = in.stubHelper->dyldPrivate)
-    addSymbol(localSymbols, dyldPrivate);
+    localSymbolsHandler(dyldPrivate);
 
   for (Symbol *sym : symtab->getSymbols()) {
     if (!sym->isLive())
@@ -972,7 +1022,7 @@ void SymtabSection::finalizeContents() {
         continue;
       assert(defined->isExternal());
       if (defined->privateExtern)
-        addSymbol(localSymbols, defined);
+        localSymbolsHandler(defined);
       else
         addSymbol(externalSymbols, defined);
     } else if (auto *dysym = dyn_cast<DylibSymbol>(sym)) {
@@ -1341,7 +1391,10 @@ void CStringSection::finalizeContents() {
     for (size_t i = 0, e = isec->pieces.size(); i != e; ++i) {
       if (!isec->pieces[i].live)
         continue;
-      uint32_t pieceAlign = MinAlign(isec->pieces[i].inSecOff, align);
+      // See comment above DeduplicatedCStringSection for how alignment is
+      // handled.
+      uint32_t pieceAlign =
+          1 << countTrailingZeros(isec->align | isec->pieces[i].inSecOff);
       offset = alignTo(offset, pieceAlign);
       isec->pieces[i].outSecOff = offset;
       isec->isFinal = true;
@@ -1351,45 +1404,89 @@ void CStringSection::finalizeContents() {
   }
   size = offset;
 }
+
 // Mergeable cstring literals are found under the __TEXT,__cstring section. In
 // contrast to ELF, which puts strings that need different alignments into
 // different sections, clang's Mach-O backend puts them all in one section.
 // Strings that need to be aligned have the .p2align directive emitted before
-// them, which simply translates into zero padding in the object file.
+// them, which simply translates into zero padding in the object file. In other
+// words, we have to infer the desired alignment of these cstrings from their
+// addresses.
 //
-// I *think* ld64 extracts the desired per-string alignment from this data by
-// preserving each string's offset from the last section-aligned address. I'm
-// not entirely certain since it doesn't seem consistent about doing this, and
-// in fact doesn't seem to be correct in general: we can in fact can induce ld64
-// to produce a crashing binary just by linking in an additional object file
-// that only contains a duplicate cstring at a different alignment. See PR50563
-// for details.
+// We differ slightly from ld64 in how we've chosen to align these cstrings.
+// Both LLD and ld64 preserve the number of trailing zeros in each cstring's
+// address in the input object files. When deduplicating identical cstrings,
+// both linkers pick the cstring whose address has more trailing zeros, and
+// preserve the alignment of that address in the final binary. However, ld64
+// goes a step further and also preserves the offset of the cstring from the
+// last section-aligned address.  I.e. if a cstring is at offset 18 in the
+// input, with a section alignment of 16, then both LLD and ld64 will ensure the
+// final address is 2-byte aligned (since 18 == 16 + 2). But ld64 will also
+// ensure that the final address is of the form 16 * k + 2 for some k.
 //
-// On x86_64, the cstrings we've seen so far that require special alignment are
-// all accessed by SIMD operations -- x86_64 requires SIMD accesses to be
-// 16-byte-aligned. arm64 also seems to require 16-byte-alignment in some cases
-// (PR50791), but I haven't tracked down the root cause. So for now, I'm just
-// aligning all strings to 16 bytes.  This is indeed wasteful, but
-// implementation-wise it's simpler than preserving per-string
-// alignment+offsets. It also avoids the aforementioned crash after
-// deduplication of differently-aligned strings.  Finally, the overhead is not
-// huge: using 16-byte alignment (vs no alignment) is only a 0.5% size overhead
-// when linking chromium_framework on x86_64.
-DeduplicatedCStringSection::DeduplicatedCStringSection()
-    : builder(StringTableBuilder::RAW, /*Alignment=*/16) {}
-
+// Note that ld64's heuristic means that a dedup'ed cstring's final address is
+// dependent on the order of the input object files. E.g. if in addition to the
+// cstring at offset 18 above, we have a duplicate one in another file with a
+// `.cstring` section alignment of 2 and an offset of zero, then ld64 will pick
+// the cstring from the object file earlier on the command line (since both have
+// the same number of trailing zeros in their address). So the final cstring may
+// either be at some address `16 * k + 2` or at some address `2 * k`.
+//
+// I've opted not to follow this behavior primarily for implementation
+// simplicity, and secondarily to save a few more bytes. It's not clear to me
+// that preserving the section alignment + offset is ever necessary, and there
+// are many cases that are clearly redundant. In particular, if an x86_64 object
+// file contains some strings that are accessed via SIMD instructions, then the
+// .cstring section in the object file will be 16-byte-aligned (since SIMD
+// requires its operand addresses to be 16-byte aligned). However, there will
+// typically also be other cstrings in the same file that aren't used via SIMD
+// and don't need this alignment. They will be emitted at some arbitrary address
+// `A`, but ld64 will treat them as being 16-byte aligned with an offset of `16
+// % A`.
 void DeduplicatedCStringSection::finalizeContents() {
-  // Add all string pieces to the string table builder to create section
-  // contents.
+  // Find the largest alignment required for each string.
+  for (const CStringInputSection *isec : inputs) {
+    for (size_t i = 0, e = isec->pieces.size(); i != e; ++i) {
+      const StringPiece &piece = isec->pieces[i];
+      if (!piece.live)
+        continue;
+      auto s = isec->getCachedHashStringRef(i);
+      assert(isec->align != 0);
+      uint8_t trailingZeros = countTrailingZeros(isec->align | piece.inSecOff);
+      auto it = stringOffsetMap.insert(
+          std::make_pair(s, StringOffset(trailingZeros)));
+      if (!it.second && it.first->second.trailingZeros < trailingZeros)
+        it.first->second.trailingZeros = trailingZeros;
+    }
+  }
+
+  // Assign an offset for each string and save it to the corresponding
+  // StringPieces for easy access.
   for (CStringInputSection *isec : inputs) {
-    for (size_t i = 0, e = isec->pieces.size(); i != e; ++i)
-      if (isec->pieces[i].live)
-        isec->pieces[i].outSecOff =
-            builder.add(isec->getCachedHashStringRef(i));
+    for (size_t i = 0, e = isec->pieces.size(); i != e; ++i) {
+      if (!isec->pieces[i].live)
+        continue;
+      auto s = isec->getCachedHashStringRef(i);
+      auto it = stringOffsetMap.find(s);
+      assert(it != stringOffsetMap.end());
+      StringOffset &offsetInfo = it->second;
+      if (offsetInfo.outSecOff == UINT64_MAX) {
+        offsetInfo.outSecOff = alignTo(size, 1ULL << offsetInfo.trailingZeros);
+        size = offsetInfo.outSecOff + s.size();
+      }
+      isec->pieces[i].outSecOff = offsetInfo.outSecOff;
+    }
     isec->isFinal = true;
   }
+}
 
-  builder.finalizeInOrder();
+void DeduplicatedCStringSection::writeTo(uint8_t *buf) const {
+  for (const auto &p : stringOffsetMap) {
+    StringRef data = p.first.val();
+    uint64_t off = p.second.outSecOff;
+    if (!data.empty())
+      memcpy(buf + off, data.data(), data.size());
+  }
 }
 
 // This section is actually emitted as __TEXT,__const by ld64, but clang may
diff --git a/lld/MachO/SyntheticSections.h b/lld/MachO/SyntheticSections.h
index 12e422b5c5d86..0c06f4222625e 100644
--- a/lld/MachO/SyntheticSections.h
+++ b/lld/MachO/SyntheticSections.h
@@ -105,6 +105,7 @@ class PageZeroSection final : public SyntheticSection {
 public:
   PageZeroSection();
   bool isHidden() const override { return true; }
+  bool isNeeded() const override { return target->pageZeroSize != 0; }
   uint64_t getSize() const override { return target->pageZeroSize; }
   uint64_t getFileSize() const override { return 0; }
   void writeTo(uint8_t *buf) const override {}
@@ -191,13 +192,13 @@ class BindingSection final : public LinkEditSection {
   bool isNeeded() const override { return !bindingsMap.empty(); }
   void writeTo(uint8_t *buf) const override;
 
-  void addEntry(const DylibSymbol *dysym, const InputSection *isec,
-                uint64_t offset, int64_t addend = 0) {
+  void addEntry(const Symbol *dysym, const InputSection *isec, uint64_t offset,
+                int64_t addend = 0) {
     bindingsMap[dysym].emplace_back(addend, Location(isec, offset));
   }
 
 private:
-  BindingsMap<const DylibSymbol *> bindingsMap;
+  BindingsMap<const Symbol *> bindingsMap;
   SmallVector<char, 128> contents;
 };
 
@@ -330,13 +331,13 @@ class LazyBindingSection final : public LinkEditSection {
   void writeTo(uint8_t *buf) const override;
   // Note that every entry here will by referenced by a corresponding entry in
   // the StubHelperSection.
-  void addEntry(DylibSymbol *dysym);
-  const llvm::SetVector<DylibSymbol *> &getEntries() const { return entries; }
+  void addEntry(Symbol *dysym);
+  const llvm::SetVector<Symbol *> &getEntries() const { return entries; }
 
 private:
-  uint32_t encode(const DylibSymbol &);
+  uint32_t encode(const Symbol &);
 
-  llvm::SetVector<DylibSymbol *> entries;
+  llvm::SetVector<Symbol *> entries;
   SmallVector<char, 128> contents;
   llvm::raw_svector_ostream os{contents};
 };
@@ -530,13 +531,19 @@ class CStringSection : public SyntheticSection {
 
 class DeduplicatedCStringSection final : public CStringSection {
 public:
-  DeduplicatedCStringSection();
-  uint64_t getSize() const override { return builder.getSize(); }
+  uint64_t getSize() const override { return size; }
   void finalizeContents() override;
-  void writeTo(uint8_t *buf) const override { builder.write(buf); }
+  void writeTo(uint8_t *buf) const override;
 
 private:
-  llvm::StringTableBuilder builder;
+  struct StringOffset {
+    uint8_t trailingZeros;
+    uint64_t outSecOff = UINT64_MAX;
+
+    explicit StringOffset(uint8_t zeros) : trailingZeros(zeros) {}
+  };
+  llvm::DenseMap<llvm::CachedHashStringRef, StringOffset> stringOffsetMap;
+  size_t size = 0;
 };
 
 /*
@@ -594,6 +601,7 @@ class WordLiteralSection final : public SyntheticSection {
 };
 
 struct InStruct {
+  const uint8_t *bufferStart = nullptr;
   MachHeaderSection *header = nullptr;
   CStringSection *cStringSection = nullptr;
   WordLiteralSection *wordLiteralSection = nullptr;
diff --git a/lld/MachO/Target.h b/lld/MachO/Target.h
index 9c021c611f7b8..e66a6966b59d7 100644
--- a/lld/MachO/Target.h
+++ b/lld/MachO/Target.h
@@ -14,6 +14,7 @@
 
 #include "llvm/ADT/BitmaskEnum.h"
 #include "llvm/BinaryFormat/MachO.h"
+#include "llvm/Support/MathExtras.h"
 #include "llvm/Support/MemoryBuffer.h"
 
 #include <cstddef>
@@ -37,6 +38,7 @@ class TargetInfo {
     pageZeroSize = LP::pageZeroSize;
     headerSize = sizeof(typename LP::mach_header);
     wordSize = LP::wordSize;
+    p2WordSize = llvm::CTLog2<LP::wordSize>();
   }
 
   virtual ~TargetInfo() = default;
@@ -52,7 +54,7 @@ class TargetInfo {
   // details.
   virtual void writeStub(uint8_t *buf, const Symbol &) const = 0;
   virtual void writeStubHelperHeader(uint8_t *buf) const = 0;
-  virtual void writeStubHelperEntry(uint8_t *buf, const DylibSymbol &,
+  virtual void writeStubHelperEntry(uint8_t *buf, const Symbol &,
                                     uint64_t entryAddr) const = 0;
 
   // Symbols may be referenced via either the GOT or the stubs section,
@@ -85,12 +87,17 @@ class TargetInfo {
   size_t stubSize;
   size_t stubHelperHeaderSize;
   size_t stubHelperEntrySize;
+  uint8_t p2WordSize;
   size_t wordSize;
 
   size_t thunkSize = 0;
   uint64_t forwardBranchRange = 0;
   uint64_t backwardBranchRange = 0;
 
+  uint32_t modeDwarfEncoding;
+  uint8_t subtractorRelocType;
+  uint8_t unsignedRelocType;
+
   // We contrive this value as sufficiently far from any valid address that it
   // will always be out-of-range for any architecture. UINT64_MAX is not a
   // good choice because it is (a) only 1 away from wrapping to 0, and (b) the
diff --git a/lld/MachO/UnwindInfoSection.cpp b/lld/MachO/UnwindInfoSection.cpp
index 8b1e357499aad..4f481427f29b7 100644
--- a/lld/MachO/UnwindInfoSection.cpp
+++ b/lld/MachO/UnwindInfoSection.cpp
@@ -28,6 +28,7 @@
 
 using namespace llvm;
 using namespace llvm::MachO;
+using namespace llvm::support::endian;
 using namespace lld;
 using namespace lld::macho;
 
@@ -95,12 +96,49 @@ using namespace lld::macho;
 // TODO(gkm): prune __eh_frame entries superseded by __unwind_info, PR50410
 // TODO(gkm): how do we align the 2nd-level pages?
 
-template <class Ptr> struct CompactUnwindEntry {
-  Ptr functionAddress;
+// The offsets of various fields in the on-disk representation of each compact
+// unwind entry.
+struct CompactUnwindOffsets {
+  uint32_t functionAddress;
+  uint32_t functionLength;
+  uint32_t encoding;
+  uint32_t personality;
+  uint32_t lsda;
+
+  CompactUnwindOffsets(size_t wordSize) {
+    if (wordSize == 8)
+      init<uint64_t>();
+    else {
+      assert(wordSize == 4);
+      init<uint32_t>();
+    }
+  }
+
+private:
+  template <class Ptr> void init() {
+    functionAddress = offsetof(Layout<Ptr>, functionAddress);
+    functionLength = offsetof(Layout<Ptr>, functionLength);
+    encoding = offsetof(Layout<Ptr>, encoding);
+    personality = offsetof(Layout<Ptr>, personality);
+    lsda = offsetof(Layout<Ptr>, lsda);
+  }
+
+  template <class Ptr> struct Layout {
+    Ptr functionAddress;
+    uint32_t functionLength;
+    compact_unwind_encoding_t encoding;
+    Ptr personality;
+    Ptr lsda;
+  };
+};
+
+// LLD's internal representation of a compact unwind entry.
+struct CompactUnwindEntry {
+  uint64_t functionAddress;
   uint32_t functionLength;
   compact_unwind_encoding_t encoding;
-  Ptr personality;
-  Ptr lsda;
+  Symbol *personality;
+  InputSection *lsda;
 };
 
 using EncodingMap = DenseMap<compact_unwind_encoding_t, size_t>;
@@ -114,26 +152,32 @@ struct SecondLevelPage {
   EncodingMap localEncodingIndexes;
 };
 
-template <class Ptr>
+// UnwindInfoSectionImpl allows us to avoid cluttering our header file with a
+// lengthy definition of UnwindInfoSection.
 class UnwindInfoSectionImpl final : public UnwindInfoSection {
 public:
-  void prepareRelocations(ConcatInputSection *) override;
-  void relocateCompactUnwind(std::vector<CompactUnwindEntry<Ptr>> &);
-  Reloc *findLsdaReloc(ConcatInputSection *) const;
-  void encodePersonalities();
+  UnwindInfoSectionImpl() : cuOffsets(target->wordSize) {}
+  uint64_t getSize() const override { return unwindInfoSize; }
+  void prepareRelocations() override;
   void finalize() override;
   void writeTo(uint8_t *buf) const override;
 
 private:
+  void prepareRelocations(ConcatInputSection *);
+  void relocateCompactUnwind(std::vector<CompactUnwindEntry> &);
+  void encodePersonalities();
+
+  uint64_t unwindInfoSize = 0;
+  std::vector<decltype(symbols)::value_type> symbolsVec;
+  CompactUnwindOffsets cuOffsets;
   std::vector<std::pair<compact_unwind_encoding_t, size_t>> commonEncodings;
   EncodingMap commonEncodingIndexes;
   // The entries here will be in the same order as their originating symbols
   // in symbolsVec.
-  std::vector<CompactUnwindEntry<Ptr>> cuEntries;
+  std::vector<CompactUnwindEntry> cuEntries;
   // Indices into the cuEntries vector.
   std::vector<size_t> cuIndices;
-  // Indices of personality functions within the GOT.
-  std::vector<Ptr> personalities;
+  std::vector<Symbol *> personalities;
   SmallDenseMap<std::pair<InputSection *, uint64_t /* addend */>, Symbol *>
       personalityTable;
   // Indices into cuEntries for CUEs with a non-null LSDA.
@@ -149,15 +193,6 @@ UnwindInfoSection::UnwindInfoSection()
   align = 4;
 }
 
-void UnwindInfoSection::prepareRelocations() {
-  // This iteration needs to be deterministic, since prepareRelocations may add
-  // entries to the GOT. Hence the use of a MapVector for
-  // UnwindInfoSection::symbols.
-  for (const Defined *d : make_second_range(symbols))
-    if (d->unwindEntry)
-      prepareRelocations(d->unwindEntry);
-}
-
 // Record function symbols that may need entries emitted in __unwind_info, which
 // stores unwind data for address ranges.
 //
@@ -176,20 +211,29 @@ void UnwindInfoSection::addSymbol(const Defined *d) {
   // we use that as the key here.
   auto p = symbols.insert({{d->isec, d->value}, d});
   // If we have multiple symbols at the same address, only one of them can have
-  // an associated CUE.
+  // an associated unwind entry.
   if (!p.second && d->unwindEntry) {
     assert(!p.first->second->unwindEntry);
     p.first->second = d;
   }
 }
 
+void UnwindInfoSectionImpl::prepareRelocations() {
+  // This iteration needs to be deterministic, since prepareRelocations may add
+  // entries to the GOT. Hence the use of a MapVector for
+  // UnwindInfoSection::symbols.
+  for (const Defined *d : make_second_range(symbols))
+    if (d->unwindEntry &&
+        d->unwindEntry->getName() == section_names::compactUnwind)
+      prepareRelocations(d->unwindEntry);
+}
+
 // Compact unwind relocations have different semantics, so we handle them in a
 // separate code path from regular relocations. First, we do not wish to add
 // rebase opcodes for __LD,__compact_unwind, because that section doesn't
 // actually end up in the final binary. Second, personality pointers always
 // reside in the GOT and must be treated specially.
-template <class Ptr>
-void UnwindInfoSectionImpl<Ptr>::prepareRelocations(ConcatInputSection *isec) {
+void UnwindInfoSectionImpl::prepareRelocations(ConcatInputSection *isec) {
   assert(!isec->shouldOmitFromOutput() &&
          "__compact_unwind section should not be omitted");
 
@@ -206,8 +250,7 @@ void UnwindInfoSectionImpl<Ptr>::prepareRelocations(ConcatInputSection *isec) {
     // compact unwind entries that references them, and thus appear as section
     // relocs. There is no need to prepare them. We only prepare relocs for
     // personality functions.
-    if (r.offset % sizeof(CompactUnwindEntry<Ptr>) !=
-        offsetof(CompactUnwindEntry<Ptr>, personality))
+    if (r.offset != cuOffsets.personality)
       continue;
 
     if (auto *s = r.referent.dyn_cast<Symbol *>()) {
@@ -265,8 +308,10 @@ void UnwindInfoSectionImpl<Ptr>::prepareRelocations(ConcatInputSection *isec) {
         s = make<Defined>("<internal>", /*file=*/nullptr, referentIsec,
                           r.addend, /*size=*/0, /*isWeakDef=*/false,
                           /*isExternal=*/false, /*isPrivateExtern=*/false,
+                          /*includeInSymtab=*/true,
                           /*isThumb=*/false, /*isReferencedDynamically=*/false,
                           /*noDeadStrip=*/false);
+        s->used = true;
         in.got->addEntry(s);
       }
       r.referent = s;
@@ -275,64 +320,55 @@ void UnwindInfoSectionImpl<Ptr>::prepareRelocations(ConcatInputSection *isec) {
   }
 }
 
-// Unwind info lives in __DATA, and finalization of __TEXT will occur before
-// finalization of __DATA. Moreover, the finalization of unwind info depends on
-// the exact addresses that it references. So it is safe for compact unwind to
-// reference addresses in __TEXT, but not addresses in any other segment.
-static ConcatInputSection *checkTextSegment(InputSection *isec) {
-  if (isec->getSegName() != segment_names::text)
-    error("compact unwind references address in " + toString(isec) +
-          " which is not in segment __TEXT");
-  // __text should always be a ConcatInputSection.
-  return cast<ConcatInputSection>(isec);
-}
-
 // We need to apply the relocations to the pre-link compact unwind section
 // before converting it to post-link form. There should only be absolute
 // relocations here: since we are not emitting the pre-link CU section, there
 // is no source address to make a relative location meaningful.
-template <class Ptr>
-void UnwindInfoSectionImpl<Ptr>::relocateCompactUnwind(
-    std::vector<CompactUnwindEntry<Ptr>> &cuEntries) {
+void UnwindInfoSectionImpl::relocateCompactUnwind(
+    std::vector<CompactUnwindEntry> &cuEntries) {
   parallelForEachN(0, symbolsVec.size(), [&](size_t i) {
-    uint8_t *buf = reinterpret_cast<uint8_t *>(cuEntries.data()) +
-                   i * sizeof(CompactUnwindEntry<Ptr>);
+    CompactUnwindEntry &cu = cuEntries[i];
     const Defined *d = symbolsVec[i].second;
-    // Write the functionAddress.
-    writeAddress(buf, d->getVA(), sizeof(Ptr) == 8 ? 3 : 2);
+    cu.functionAddress = d->getVA();
     if (!d->unwindEntry)
       return;
 
-    // Write the rest of the CUE.
-    memcpy(buf + sizeof(Ptr), d->unwindEntry->data.data(),
-           d->unwindEntry->data.size());
+    // If we have DWARF unwind info, create a CU entry that points to it.
+    if (d->unwindEntry->getName() == section_names::ehFrame) {
+      cu.encoding = target->modeDwarfEncoding | d->unwindEntry->outSecOff;
+      const FDE &fde = cast<ObjFile>(d->getFile())->fdes[d->unwindEntry];
+      cu.functionLength = fde.funcLength;
+      cu.personality = fde.personality;
+      cu.lsda = fde.lsda;
+      return;
+    }
+
+    assert(d->unwindEntry->getName() == section_names::compactUnwind);
+
+    auto buf = reinterpret_cast<const uint8_t *>(d->unwindEntry->data.data()) -
+               target->wordSize;
+    cu.functionLength =
+        support::endian::read32le(buf + cuOffsets.functionLength);
+    cu.encoding = support::endian::read32le(buf + cuOffsets.encoding);
     for (const Reloc &r : d->unwindEntry->relocs) {
-      uint64_t referentVA = 0;
-      if (auto *referentSym = r.referent.dyn_cast<Symbol *>()) {
-        if (!isa<Undefined>(referentSym)) {
-          if (auto *defined = dyn_cast<Defined>(referentSym))
-            checkTextSegment(defined->isec);
-          // At this point in the link, we may not yet know the final address of
-          // the GOT, so we just encode the index. We make it a 1-based index so
-          // that we can distinguish the null pointer case.
-          referentVA = referentSym->gotIndex + 1;
-        }
-      } else {
-        auto *referentIsec = r.referent.get<InputSection *>();
-        checkTextSegment(referentIsec);
-        referentVA = referentIsec->getVA(r.addend);
+      if (r.offset == cuOffsets.personality) {
+        cu.personality = r.referent.get<Symbol *>();
+      } else if (r.offset == cuOffsets.lsda) {
+        if (auto *referentSym = r.referent.dyn_cast<Symbol *>())
+          cu.lsda = cast<Defined>(referentSym)->isec;
+        else
+          cu.lsda = r.referent.get<InputSection *>();
       }
-      writeAddress(buf + r.offset, referentVA, r.length);
     }
   });
 }
 
 // There should only be a handful of unique personality pointers, so we can
 // encode them as 2-bit indices into a small array.
-template <class Ptr> void UnwindInfoSectionImpl<Ptr>::encodePersonalities() {
+void UnwindInfoSectionImpl::encodePersonalities() {
   for (size_t idx : cuIndices) {
-    CompactUnwindEntry<Ptr> &cu = cuEntries[idx];
-    if (cu.personality == 0)
+    CompactUnwindEntry &cu = cuEntries[idx];
+    if (cu.personality == nullptr)
       continue;
     // Linear search is fast enough for a small array.
     auto it = find(personalities, cu.personality);
@@ -348,7 +384,7 @@ template <class Ptr> void UnwindInfoSectionImpl<Ptr>::encodePersonalities() {
             static_cast<compact_unwind_encoding_t>(UNWIND_PERSONALITY_MASK));
   }
   if (personalities.size() > 3)
-    error("too many personalities (" + std::to_string(personalities.size()) +
+    error("too many personalities (" + Twine(personalities.size()) +
           ") for compact unwind to encode");
 }
 
@@ -377,23 +413,9 @@ static bool canFoldEncoding(compact_unwind_encoding_t encoding) {
   return true;
 }
 
-template <class Ptr>
-Reloc *
-UnwindInfoSectionImpl<Ptr>::findLsdaReloc(ConcatInputSection *isec) const {
-  if (isec == nullptr)
-    return nullptr;
-  auto it = llvm::find_if(isec->relocs, [](const Reloc &r) {
-    return r.offset % sizeof(CompactUnwindEntry<Ptr>) ==
-           offsetof(CompactUnwindEntry<Ptr>, lsda);
-  });
-  if (it == isec->relocs.end())
-    return nullptr;
-  return &*it;
-}
-
 // Scan the __LD,__compact_unwind entries and compute the space needs of
 // __TEXT,__unwind_info and __TEXT,__eh_frame.
-template <class Ptr> void UnwindInfoSectionImpl<Ptr>::finalize() {
+void UnwindInfoSectionImpl::finalize() {
   if (symbols.empty())
     return;
 
@@ -433,25 +455,9 @@ template <class Ptr> void UnwindInfoSectionImpl<Ptr>::finalize() {
            cuEntries[*foldBegin].encoding == cuEntries[*foldEnd].encoding &&
            cuEntries[*foldBegin].personality ==
                cuEntries[*foldEnd].personality &&
-           canFoldEncoding(cuEntries[*foldEnd].encoding)) {
-      // In most cases, we can just compare the values of cuEntries[*].lsda.
-      // However, it is possible for -rename_section to cause the LSDA section
-      // (__gcc_except_tab) to be finalized after the unwind info section. In
-      // that case, we don't yet have unique addresses for the LSDA entries.
-      // So we check their relocations instead.
-      // FIXME: should we account for an LSDA at an absolute address? ld64 seems
-      // to support it, but it seems unlikely to be used in practice.
-      Reloc *lsda1 = findLsdaReloc(symbolsVec[*foldBegin].second->unwindEntry);
-      Reloc *lsda2 = findLsdaReloc(symbolsVec[*foldEnd].second->unwindEntry);
-      if (lsda1 == nullptr && lsda2 == nullptr)
-        continue;
-      if (lsda1 == nullptr || lsda2 == nullptr)
-        break;
-      if (lsda1->referent != lsda2->referent)
-        break;
-      if (lsda1->addend != lsda2->addend)
-        break;
-    }
+           cuEntries[*foldBegin].lsda == cuEntries[*foldEnd].lsda &&
+           canFoldEncoding(cuEntries[*foldEnd].encoding))
+      ;
     *foldWrite++ = *foldBegin;
     foldBegin = foldEnd;
   }
@@ -509,7 +515,7 @@ template <class Ptr> void UnwindInfoSectionImpl<Ptr>::finalize() {
             sizeof(uint32_t);
     while (wordsRemaining >= 1 && i < cuIndices.size()) {
       idx = cuIndices[i];
-      const CompactUnwindEntry<Ptr> *cuPtr = &cuEntries[idx];
+      const CompactUnwindEntry *cuPtr = &cuEntries[idx];
       if (cuPtr->functionAddress >= functionAddressMax) {
         break;
       } else if (commonEncodingIndexes.count(cuPtr->encoding) ||
@@ -544,8 +550,7 @@ template <class Ptr> void UnwindInfoSectionImpl<Ptr>::finalize() {
 
   for (size_t idx : cuIndices) {
     lsdaIndex[idx] = entriesWithLsda.size();
-    const Defined *d = symbolsVec[idx].second;
-    if (findLsdaReloc(d->unwindEntry))
+    if (cuEntries[idx].lsda)
       entriesWithLsda.push_back(idx);
   }
 
@@ -564,8 +569,7 @@ template <class Ptr> void UnwindInfoSectionImpl<Ptr>::finalize() {
 
 // All inputs are relocated and output addresses are known, so write!
 
-template <class Ptr>
-void UnwindInfoSectionImpl<Ptr>::writeTo(uint8_t *buf) const {
+void UnwindInfoSectionImpl::writeTo(uint8_t *buf) const {
   assert(!cuIndices.empty() && "call only if there is unwind info");
 
   // section header
@@ -587,9 +591,8 @@ void UnwindInfoSectionImpl<Ptr>::writeTo(uint8_t *buf) const {
     *i32p++ = encoding.first;
 
   // Personalities
-  for (Ptr personality : personalities)
-    *i32p++ =
-        in.got->addr + (personality - 1) * target->wordSize - in.header->addr;
+  for (const Symbol *personality : personalities)
+    *i32p++ = personality->getGotVA() - in.header->addr;
 
   // Level-1 index
   uint32_t lsdaOffset =
@@ -608,7 +611,7 @@ void UnwindInfoSectionImpl<Ptr>::writeTo(uint8_t *buf) const {
     l2PagesOffset += SECOND_LEVEL_PAGE_BYTES;
   }
   // Level-1 sentinel
-  const CompactUnwindEntry<Ptr> &cuEnd = cuEntries[cuIndices.back()];
+  const CompactUnwindEntry &cuEnd = cuEntries[cuIndices.back()];
   iep->functionOffset =
       cuEnd.functionAddress - in.header->addr + cuEnd.functionLength;
   iep->secondLevelPagesSectionOffset = 0;
@@ -621,18 +624,8 @@ void UnwindInfoSectionImpl<Ptr>::writeTo(uint8_t *buf) const {
   auto *lep =
       reinterpret_cast<unwind_info_section_header_lsda_index_entry *>(iep);
   for (size_t idx : entriesWithLsda) {
-    const CompactUnwindEntry<Ptr> &cu = cuEntries[idx];
-    const Defined *d = symbolsVec[idx].second;
-    if (Reloc *r = findLsdaReloc(d->unwindEntry)) {
-      uint64_t va;
-      if (auto *isec = r->referent.dyn_cast<InputSection *>()) {
-        va = isec->getVA(r->addend);
-      } else {
-        auto *sym = r->referent.get<Symbol *>();
-        va = sym->getVA() + r->addend;
-      }
-      lep->lsdaOffset = va - in.header->addr;
-    }
+    const CompactUnwindEntry &cu = cuEntries[idx];
+    lep->lsdaOffset = cu.lsda->getVA(/*off=*/0) - in.header->addr;
     lep->functionOffset = cu.functionAddress - in.header->addr;
     lep++;
   }
@@ -655,7 +648,7 @@ void UnwindInfoSectionImpl<Ptr>::writeTo(uint8_t *buf) const {
       p2p->encodingsCount = page.localEncodings.size();
       auto *ep = reinterpret_cast<uint32_t *>(&p2p[1]);
       for (size_t i = 0; i < page.entryCount; i++) {
-        const CompactUnwindEntry<Ptr> &cue =
+        const CompactUnwindEntry &cue =
             cuEntries[cuIndices[page.entryIndex + i]];
         auto it = commonEncodingIndexes.find(cue.encoding);
         if (it == commonEncodingIndexes.end())
@@ -675,7 +668,7 @@ void UnwindInfoSectionImpl<Ptr>::writeTo(uint8_t *buf) const {
       p2p->entryCount = page.entryCount;
       auto *ep = reinterpret_cast<uint32_t *>(&p2p[1]);
       for (size_t i = 0; i < page.entryCount; i++) {
-        const CompactUnwindEntry<Ptr> &cue =
+        const CompactUnwindEntry &cue =
             cuEntries[cuIndices[page.entryIndex + i]];
         *ep++ = cue.functionAddress;
         *ep++ = cue.encoding;
@@ -686,8 +679,5 @@ void UnwindInfoSectionImpl<Ptr>::writeTo(uint8_t *buf) const {
 }
 
 UnwindInfoSection *macho::makeUnwindInfoSection() {
-  if (target->wordSize == 8)
-    return make<UnwindInfoSectionImpl<uint64_t>>();
-  else
-    return make<UnwindInfoSectionImpl<uint32_t>>();
+  return make<UnwindInfoSectionImpl>();
 }
diff --git a/lld/MachO/UnwindInfoSection.h b/lld/MachO/UnwindInfoSection.h
index e1d60bec077c9..c6b334731c75b 100644
--- a/lld/MachO/UnwindInfoSection.h
+++ b/lld/MachO/UnwindInfoSection.h
@@ -23,19 +23,15 @@ class UnwindInfoSection : public SyntheticSection {
   // If all functions are free of unwind info, we can omit the unwind info
   // section entirely.
   bool isNeeded() const override { return !allEntriesAreOmitted; }
-  uint64_t getSize() const override { return unwindInfoSize; }
   void addSymbol(const Defined *);
-  void prepareRelocations();
+  virtual void prepareRelocations() = 0;
 
 protected:
   UnwindInfoSection();
-  virtual void prepareRelocations(ConcatInputSection *) = 0;
 
   llvm::MapVector<std::pair<const InputSection *, uint64_t /*Defined::value*/>,
                   const Defined *>
       symbols;
-  std::vector<decltype(symbols)::value_type> symbolsVec;
-  uint64_t unwindInfoSize = 0;
   bool allEntriesAreOmitted = true;
 };
 
diff --git a/lld/MachO/Writer.cpp b/lld/MachO/Writer.cpp
index 851cb3db3859a..3e9641ba5ef7b 100644
--- a/lld/MachO/Writer.cpp
+++ b/lld/MachO/Writer.cpp
@@ -20,6 +20,7 @@
 #include "SyntheticSections.h"
 #include "Target.h"
 #include "UnwindInfoSection.h"
+#include "llvm/Support/Parallel.h"
 
 #include "lld/Common/Arrays.h"
 #include "lld/Common/CommonLinkerContext.h"
@@ -458,9 +459,11 @@ class LCBuildVersion final : public LoadCommand {
     auto *c = reinterpret_cast<build_version_command *>(buf);
     c->cmd = LC_BUILD_VERSION;
     c->cmdsize = getSize();
+
     c->platform = static_cast<uint32_t>(platformInfo.target.Platform);
     c->minos = encodeVersion(platformInfo.minimum);
     c->sdk = encodeVersion(platformInfo.sdk);
+
     c->ntools = ntools;
     auto *t = reinterpret_cast<build_tool_version *>(&c[1]);
     t->tool = TOOL_LD;
@@ -594,6 +597,9 @@ static void prepareBranchTarget(Symbol *sym) {
         in.weakBinding->addEntry(sym, in.lazyPointers->isec,
                                  sym->stubsIndex * target->wordSize);
       }
+    } else if (defined->interposable) {
+      if (in.stubs->addEntry(sym))
+        in.lazyBinding->addEntry(sym);
     }
   } else {
     llvm_unreachable("invalid branch target symbol type");
@@ -605,7 +611,7 @@ static bool needsBinding(const Symbol *sym) {
   if (isa<DylibSymbol>(sym))
     return true;
   if (const auto *defined = dyn_cast<Defined>(sym))
-    return defined->isExternalWeakDef();
+    return defined->isExternalWeakDef() || defined->interposable;
   return false;
 }
 
@@ -765,6 +771,11 @@ template <class LP> void Writer::createLoadCommands() {
   else
     in.header->addLoadCommand(make<LCMinVersion>(config->platformInfo));
 
+  if (config->secondaryPlatformInfo) {
+    in.header->addLoadCommand(
+        make<LCBuildVersion>(*config->secondaryPlatformInfo));
+  }
+
   // This is down here to match ld64's load command order.
   if (config->outputType == MH_EXECUTE)
     in.header->addLoadCommand(make<LCMain>());
@@ -857,7 +868,7 @@ static void sortSegmentsAndSections() {
   sortOutputSegments();
 
   DenseMap<const InputSection *, size_t> isecPriorities =
-      buildInputSectionPriorities();
+      priorityBuilder.buildInputSectionPriorities();
 
   uint32_t sectionIndex = 0;
   for (OutputSegment *seg : outputSegments) {
@@ -939,8 +950,14 @@ template <class LP> void Writer::createOutputSections() {
     StringRef segname = it.first.first;
     ConcatOutputSection *osec = it.second;
     assert(segname != segment_names::ld);
-    if (osec->isNeeded())
+    if (osec->isNeeded()) {
+      // See comment in ObjFile::splitEhFrames()
+      if (osec->name == section_names::ehFrame &&
+          segname == segment_names::text)
+        osec->align = target->wordSize;
+
       getOrCreateOutputSegment(segname)->addOutputSection(osec);
+    }
   }
 
   for (SyntheticSection *ssec : syntheticSections) {
@@ -969,6 +986,21 @@ template <class LP> void Writer::createOutputSections() {
 void Writer::finalizeAddresses() {
   TimeTraceScope timeScope("Finalize addresses");
   uint64_t pageSize = target->getPageSize();
+
+  // We could parallelize this loop, but local benchmarking indicates it is
+  // faster to do it all in the main thread.
+  for (OutputSegment *seg : outputSegments) {
+    if (seg == linkEditSegment)
+      continue;
+    for (OutputSection *osec : seg->getSections()) {
+      if (!osec->isNeeded())
+        continue;
+      // Other kinds of OutputSections have already been finalized.
+      if (auto concatOsec = dyn_cast<ConcatOutputSection>(osec))
+        concatOsec->finalizeContents();
+    }
+  }
+
   // Ensure that segments (and the sections they contain) are allocated
   // addresses in ascending order, which dyld requires.
   //
@@ -1048,17 +1080,21 @@ void Writer::openFile() {
                                FileOutputBuffer::F_executable);
 
   if (!bufferOrErr)
-    error("failed to open " + config->outputFile + ": " +
+    fatal("failed to open " + config->outputFile + ": " +
           llvm::toString(bufferOrErr.takeError()));
-  else
-    buffer = std::move(*bufferOrErr);
+  buffer = std::move(*bufferOrErr);
+  in.bufferStart = buffer->getBufferStart();
 }
 
 void Writer::writeSections() {
   uint8_t *buf = buffer->getBufferStart();
+  std::vector<const OutputSection *> osecs;
   for (const OutputSegment *seg : outputSegments)
-    for (const OutputSection *osec : seg->getSections())
-      osec->writeTo(buf + osec->fileOff);
+    append_range(osecs, seg->getSections());
+
+  parallelForEach(osecs.begin(), osecs.end(), [&](const OutputSection *osec) {
+    osec->writeTo(buf + osec->fileOff);
+  });
 }
 
 // In order to utilize multiple cores, we first split the buffer into chunks,
@@ -1072,7 +1108,8 @@ void Writer::writeUuid() {
   // Round-up integer division
   size_t chunkSize = (data.size() + chunkCount - 1) / chunkCount;
   std::vector<ArrayRef<uint8_t>> chunks = split(data, chunkSize);
-  std::vector<uint64_t> hashes(chunks.size());
+  // Leave one slot for filename
+  std::vector<uint64_t> hashes(chunks.size() + 1);
   SmallVector<std::shared_future<void>> threadFutures;
   threadFutures.reserve(chunks.size());
   for (size_t i = 0; i < chunks.size(); ++i)
@@ -1080,7 +1117,9 @@ void Writer::writeUuid() {
         [&](size_t j) { hashes[j] = xxHash64(chunks[j]); }, i));
   for (std::shared_future<void> &future : threadFutures)
     future.wait();
-
+  // Append the output filename so that identical binaries with different names
+  // don't get the same UUID.
+  hashes[chunks.size()] = xxHash64(sys::path::filename(config->finalOutput));
   uint64_t digest = xxHash64({reinterpret_cast<uint8_t *>(hashes.data()),
                               hashes.size() * sizeof(uint64_t)});
   uuidCommand->writeUuid(digest);
@@ -1172,10 +1211,10 @@ void macho::createSyntheticSections() {
   // dyld to cache an address to the image loader it uses.
   uint8_t *arr = bAlloc().Allocate<uint8_t>(target->wordSize);
   memset(arr, 0, target->wordSize);
-  in.imageLoaderCache = make<ConcatInputSection>(
-      segment_names::data, section_names::data, /*file=*/nullptr,
+  in.imageLoaderCache = makeSyntheticInputSection(
+      segment_names::data, section_names::data, S_REGULAR,
       ArrayRef<uint8_t>{arr, target->wordSize},
-      /*align=*/target->wordSize, /*flags=*/S_REGULAR);
+      /*align=*/target->wordSize);
   // References from dyld are not visible to us, so ensure this section is
   // always treated as live.
   in.imageLoaderCache->live = true;
diff --git a/lld/MachO/ld64-vs-lld.rst b/lld/MachO/ld64-vs-lld.rst
index b31b4bb0ea89f..3601c224f95b0 100644
--- a/lld/MachO/ld64-vs-lld.rst
+++ b/lld/MachO/ld64-vs-lld.rst
@@ -4,23 +4,29 @@ LD64 vs LLD-MACHO
 
 This doc lists all significant deliberate differences in behavior between LD64 and LLD-MachO.
 
-String literal deduplication
+String Literal Deduplication
 ****************************
-LD64 always deduplicates string literals. LLD only does it when the `--icf=` or
-the `--deduplicate-literals` flag is passed. Omitting deduplication by default
-ensures that our link is as fast as possible. However, it may also break some
-programs which have (incorrectly) relied on string deduplication always
+LD64 always deduplicates string literals. LLD only does it when the ``--icf=``
+or the ``--deduplicate-literals`` flag is passed. Omitting deduplication by
+default ensures that our link is as fast as possible. However, it may also break
+some programs which have (incorrectly) relied on string deduplication always
 occurring. In particular, programs which compare string literals via pointer
 equality must be fixed to use value equality instead.
 
+String Alignment
+****************
+LLD is slightly less conservative about aligning cstrings, allowing it to pack
+them more compactly. This should not result in any meaningful semantic
+difference.
+
 ``-no_deduplicate`` Flag
-**********************
+************************
 - LD64:
    * This turns off ICF (deduplication pass) in the linker.
 - LLD
    * This turns off ICF and string merging in the linker.
 
-ObjC symbols treatment
+ObjC Symbols Treatment
 **********************
 There are differences in how LLD and LD64 handle ObjC symbols loaded from archives.
 
diff --git a/lld/cmake/modules/AddLLD.cmake b/lld/cmake/modules/AddLLD.cmake
index dd2898ce62364..5e176976b6030 100644
--- a/lld/cmake/modules/AddLLD.cmake
+++ b/lld/cmake/modules/AddLLD.cmake
@@ -20,7 +20,7 @@ macro(add_lld_library name)
       ${export_to_lldtargets}
       LIBRARY DESTINATION lib${LLVM_LIBDIR_SUFFIX}
       ARCHIVE DESTINATION lib${LLVM_LIBDIR_SUFFIX}
-      RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}")
+      RUNTIME DESTINATION ${LLVM_TOOLS_INSTALL_DIR})
 
     if (${ARG_SHARED} AND NOT CMAKE_CONFIGURATION_TYPES)
       add_llvm_install_targets(install-${name}
@@ -47,7 +47,7 @@ macro(add_lld_tool name)
     get_target_export_arg(${name} LLD export_to_lldtargets)
     install(TARGETS ${name}
       ${export_to_lldtargets}
-      RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
+      RUNTIME DESTINATION ${LLVM_TOOLS_INSTALL_DIR}
       COMPONENT ${name})
 
     if(NOT CMAKE_CONFIGURATION_TYPES)
diff --git a/lld/docs/ReleaseNotes.rst b/lld/docs/ReleaseNotes.rst
index 672759fdf6b38..b64f96ffae821 100644
--- a/lld/docs/ReleaseNotes.rst
+++ b/lld/docs/ReleaseNotes.rst
@@ -181,10 +181,14 @@ Mach-O Improvements
   (`D113534 <https://reviews.llvm.org/D113534>`_)
 * Passing both ``--icf=all`` and ``-no_deduplicate`` no longer results in a
   warning. (`D110672 <https://reviews.llvm.org/D110672>`_)
-* ICF now deduplicates functions with (identical) unwind info too.
-  (`D109946 <https://reviews.llvm.org/D109946>`_)
-* We now support ordering sections based on call graph profile data.
-  (`D112164 <https://reviews.llvm.org/D112164>`_)
+* We now support proper relocation and pruning of EH frames. **NoCF now deduplicates functions with (identical) unwind info too.
+  (`D109946 <https://reviews.llv:** this
+  comes at some performance overhead on x86_64 builds, and we recommend adding
+  the ``-femit-compact-unwind=no-compact-unwind`` compile flag to avoid it.
+  (`D129540 <https://reviews.llvm.org/D109946>`_)
+*.org/D129540>`_,
+  We now support ordering sections based on call graph profile data.
+  (`D`D112164 <https://reviews22258 <https://reviews.llvm.llvm.org/D112164>`_)
 * Map file output now proceeds in parallel with output of the binary.
   (`D117069 <https://reviews.llvm.org/D117069>`_)
 * The map file now contains dead-stripped symbols too.
@@ -196,7 +200,7 @@ Mach-O Improvements
 * ``-noall_load`` is now supported.
   (`D117629 <https://reviews.llvm.org/D117629>`_)
 * ``-add_empty_section`` is now supported.
-  (`D117749 <https://reviews.llvm.org/D117749>`_)
+  (`D117749 <https://reviews.llvm.org/D117749>`_)org/D122258>`_)
 
 WebAssembly Improvements
 ------------------------
diff --git a/lld/include/lld/Common/CommonLinkerContext.h b/lld/include/lld/Common/CommonLinkerContext.h
index 3954d38ded636..0627bbdc8bd87 100644
--- a/lld/include/lld/Common/CommonLinkerContext.h
+++ b/lld/include/lld/Common/CommonLinkerContext.h
@@ -21,7 +21,6 @@
 
 #include "lld/Common/ErrorHandler.h"
 #include "lld/Common/Memory.h"
-#include "llvm/CodeGen/CommandFlags.h"
 #include "llvm/Support/StringSaver.h"
 
 namespace llvm {
@@ -42,9 +41,6 @@ class CommonLinkerContext {
   llvm::DenseMap<void *, SpecificAllocBase *> instances;
 
   ErrorHandler e;
-
-private:
-  llvm::codegen::RegisterCodeGenFlags cgf;
 };
 
 // Retrieve the global state. Currently only one state can exist per process,
diff --git a/lld/include/lld/Common/ErrorHandler.h b/lld/include/lld/Common/ErrorHandler.h
index ce077290d60b3..acb6e0d6c4b85 100644
--- a/lld/include/lld/Common/ErrorHandler.h
+++ b/lld/include/lld/Common/ErrorHandler.h
@@ -101,6 +101,7 @@ class ErrorHandler {
   StringRef logName = "lld";
   bool exitEarly = true;
   bool fatalWarnings = false;
+  bool suppressWarnings = false;
   bool verbose = false;
   bool vsDiagnostics = false;
   bool disableOutput = false;
diff --git a/lld/test/MachO/Inputs/MacOSX.sdk/System/Library/Frameworks/MacOnly-Indirect.framework/MacOnly-Indirect.tbd b/lld/test/MachO/Inputs/MacOSX.sdk/System/Library/Frameworks/MacOnly-Indirect.framework/MacOnly-Indirect.tbd
new file mode 100644
index 0000000000000..a7f0322b0fd56
--- /dev/null
+++ b/lld/test/MachO/Inputs/MacOSX.sdk/System/Library/Frameworks/MacOnly-Indirect.framework/MacOnly-Indirect.tbd
@@ -0,0 +1,22 @@
+--- !tapi-tbd
+tbd-version:      4
+targets:          [ x86_64-macos, x86_64-maccatalyst ]
+uuids:
+  - target: x86_64-maccatalyst
+    value:  00000000-0000-0000-0000-000000000000
+  - target: x86_64-macos
+    value:  00000000-0000-0000-0000-000000000000
+install-name:     'MacOnly-Indirect.dylib'
+current-version:  0001.001.1
+reexported-libraries:
+  - targets:      [ x86_64-macos, x86_64-maccatalyst ]
+    libraries:    [ 'MacOnly-reexport.dylib' ]
+--- !tapi-tbd
+tbd-version:      4
+targets:          [ x86_64-macos ]
+uuids:
+  - target: x86_64-macos
+    value:  00000000-0000-0000-0000-000000000000
+install-name:     'MacOnly-reexport.dylib'
+current-version:  0001.001.1
+...
diff --git a/lld/test/MachO/Inputs/MacOSX.sdk/System/Library/Frameworks/MacOnly.framework/MacOnly.tbd b/lld/test/MachO/Inputs/MacOSX.sdk/System/Library/Frameworks/MacOnly.framework/MacOnly.tbd
new file mode 100644
index 0000000000000..cd9c7da82b4f3
--- /dev/null
+++ b/lld/test/MachO/Inputs/MacOSX.sdk/System/Library/Frameworks/MacOnly.framework/MacOnly.tbd
@@ -0,0 +1,9 @@
+--- !tapi-tbd
+tbd-version:      4
+targets:          [ x86_64-macos ]
+uuids:
+  - target: x86_64-macos
+    value:  00000000-0000-0000-0000-000000000000
+install-name:     'MacOnly.dylib'
+current-version:  0001.001.1
+...
diff --git a/lld/test/MachO/Inputs/double-unwind-info.yaml b/lld/test/MachO/Inputs/double-unwind-info.yaml
new file mode 100644
index 0000000000000..077f334343ba4
--- /dev/null
+++ b/lld/test/MachO/Inputs/double-unwind-info.yaml
@@ -0,0 +1,159 @@
+--- !mach-o
+FileHeader:
+  magic:           0xFEEDFACF
+  cputype:         0x1000007
+  cpusubtype:      0x3
+  filetype:        0x1
+  ncmds:           4
+  sizeofcmds:      384
+  flags:           0x2000
+  reserved:        0x0
+LoadCommands:
+  - cmd:             LC_SEGMENT_64
+    cmdsize:         312
+    segname:         ''
+    vmaddr:          0
+    vmsize:          96
+    fileoff:         448
+    filesize:        96
+    maxprot:         7
+    initprot:        7
+    nsects:          3
+    flags:           0
+    Sections:
+      - sectname:        __text
+        segname:         __TEXT
+        addr:            0x0
+        size:            2
+        offset:          0x1C0
+        align:           0
+        reloff:          0x0
+        nreloc:          0
+        flags:           0x80000400
+        reserved1:       0x0
+        reserved2:       0x0
+        reserved3:       0x0
+        content:         '9090'
+      - sectname:        __eh_frame
+        segname:         __TEXT
+        addr:            0x8
+        size:            56
+        offset:          0x1C8
+        align:           3
+        reloff:          0x220
+        nreloc:          4
+        flags:           0x0
+        reserved1:       0x0
+        reserved2:       0x0
+        reserved3:       0x0
+        content:         1400000000000000017A520001781001100C0708900100001C00000004000000F8FFFFFFFFFFFFFF0100000000000000000E080000000000
+        relocations:
+          - address:         0x1C
+            symbolnum:       3
+            pcrel:           false
+            length:          2
+            extern:          true
+            type:            5
+            scattered:       false
+            value:           0
+          - address:         0x1C
+            symbolnum:       4
+            pcrel:           false
+            length:          2
+            extern:          true
+            type:            0
+            scattered:       false
+            value:           0
+          - address:         0x20
+            symbolnum:       4
+            pcrel:           false
+            length:          3
+            extern:          true
+            type:            5
+            scattered:       false
+            value:           0
+          - address:         0x20
+            symbolnum:       2
+            pcrel:           false
+            length:          3
+            extern:          true
+            type:            0
+            scattered:       false
+            value:           0
+      - sectname:        __compact_unwind
+        segname:         __LD
+        addr:            0x40
+        size:            32
+        offset:          0x200
+        align:           3
+        reloff:          0x240
+        nreloc:          1
+        flags:           0x2000000
+        reserved1:       0x0
+        reserved2:       0x0
+        reserved3:       0x0
+        content:         '0000000000000000010000000000010200000000000000000000000000000000'
+        relocations:
+          - address:         0x0
+            symbolnum:       2
+            pcrel:           false
+            length:          3
+            extern:          true
+            type:            0
+            scattered:       false
+            value:           0
+  - cmd:             LC_SYMTAB
+    cmdsize:         24
+    symoff:          584
+    nsyms:           5
+    stroff:          664
+    strsize:         40
+  - cmd:             LC_BUILD_VERSION
+    cmdsize:         32
+    platform:        1
+    minos:           659200
+    sdk:             0
+    ntools:          1
+    Tools:
+      - tool:            3
+        version:         50069504
+  - cmd:             LC_DATA_IN_CODE
+    cmdsize:         16
+    dataoff:         584
+    datasize:        0
+LinkEditData:
+  NameList:
+    - n_strx:          2
+      n_type:          0xE
+      n_sect:          1
+      n_desc:          0
+      n_value:         0
+    - n_strx:          10
+      n_type:          0xE
+      n_sect:          1
+      n_desc:          0
+      n_value:         1
+    - n_strx:          16
+      n_type:          0xE
+      n_sect:          1
+      n_desc:          0
+      n_value:         1
+    - n_strx:          21
+      n_type:          0xE
+      n_sect:          2
+      n_desc:          0
+      n_value:         8
+    - n_strx:          31
+      n_type:          0xE
+      n_sect:          2
+      n_desc:          0
+      n_value:         32
+  StringTable:
+    - ' '
+    - _spacer
+    - ltmp1
+    - _foo
+    - EH_Frame1
+    - func.eh
+    - ''
+...
diff --git a/lld/test/MachO/arm64-thunk-starvation.s b/lld/test/MachO/arm64-thunk-starvation.s
index 51249a120f95e..9e2b54f843c23 100644
--- a/lld/test/MachO/arm64-thunk-starvation.s
+++ b/lld/test/MachO/arm64-thunk-starvation.s
@@ -18,7 +18,7 @@ _f6: b _fn6
 ## Currently leaves 12 bytes for one thunk, so 36 bytes.
 ## Uses < instead of <=, so 40 bytes.
 
-.global _spacer1, _spacer1
+.global _spacer1, _spacer2
 ## 0x8000000 is 128 MiB, one more than the forward branch limit,
 ## distributed over two functions since our thunk insertion algorithm
 ## can't deal with a single function that's 128 MiB.
diff --git a/lld/test/MachO/arm64-thunk-visibility.s b/lld/test/MachO/arm64-thunk-visibility.s
new file mode 100644
index 0000000000000..5fa195f8b1156
--- /dev/null
+++ b/lld/test/MachO/arm64-thunk-visibility.s
@@ -0,0 +1,83 @@
+# REQUIRES: aarch64
+
+# foo.s and bar.s both contain TU-local symbols (think static function)
+# with the same name, and both need a thunk.  This tests that ld64.lld doesn't
+# create a duplicate symbol for the two functions.
+
+# Test this both when the TU-local symbol is the branch source or target,
+# and for both forward and backwards jumps.
+
+# RUN: rm -rf %t; split-file %s %t
+# RUN: llvm-mc -filetype=obj -triple=arm64-apple-darwin %t/foo.s -o %t/foo.o
+# RUN: llvm-mc -filetype=obj -triple=arm64-apple-darwin %t/bar.s -o %t/bar.o
+# RUN: %lld -arch arm64 -lSystem -o %t.out %t/foo.o %t/bar.o
+
+#--- foo.s
+
+.subsections_via_symbols
+
+# Note: No .globl, since these are TU-local symbols.
+.p2align 2
+_early_jumping_local_fn: b _some_late_external
+.p2align 2
+_early_landing_local_fn: ret
+
+.globl _some_early_external
+.p2align 2
+_some_early_external: b _late_landing_local_fn
+
+## 0x8000000 is 128 MiB, one more than the forward branch limit.
+## Distribute that over two functions since our thunk insertion algorithm
+## can't deal with a single function that's 128 MiB.
+.global _spacer1, _spacer2
+_spacer1:
+.space 0x4000000
+_spacer2:
+.space 0x4000000
+
+# Note: No .globl, since these are TU-local symbols.
+.p2align 2
+_late_jumping_local_fn: b _some_early_external
+.p2align 2
+_late_landing_local_fn: ret
+
+.globl _some_late_external
+.p2align 2
+_some_late_external: b _early_landing_local_fn
+
+#--- bar.s
+
+.subsections_via_symbols
+
+# Note: No .globl, since these are TU-local symbols.
+.p2align 2
+_early_jumping_local_fn: b _some_other_late_external
+.p2align 2
+_early_landing_local_fn: ret
+
+.globl _some_other_early_external
+.p2align 2
+_some_other_early_external: b _late_landing_local_fn
+
+## 0x8000000 is 128 MiB, one more than the forward branch limit.
+## Distribute that over two functions since our thunk insertion algorithm
+## can't deal with a single function that's 128 MiB.
+.global _other_spacer1, _other_spacer1
+_spacer1:
+.space 0x4000000
+_spacer2:
+.space 0x4000000
+
+# Note: No .globl, since these are TU-local symbols.
+.p2align 2
+_late_jumping_local_fn: b _some_other_early_external
+.p2align 2
+_late_landing_local_fn: ret
+
+.globl _some_other_late_external
+.p2align 2
+_some_other_late_external: b _early_landing_local_fn
+
+.globl _main
+_main:
+  ret
diff --git a/lld/test/MachO/cfstring-dedup.s b/lld/test/MachO/cfstring-dedup.s
index 1a043064b6e0d..73aa50fa98b04 100644
--- a/lld/test/MachO/cfstring-dedup.s
+++ b/lld/test/MachO/cfstring-dedup.s
@@ -37,6 +37,10 @@
 
 #--- foo1.s
 .cstring
+L_.str.0:
+  .asciz  "bar"
+## This string is at a different offset than the corresponding "foo" string in
+## foo2.s. Make sure that we treat references to either string as equivalent.
 L_.str:
   .asciz  "foo"
 
@@ -57,7 +61,7 @@ _named_cfstring:
   .quad  3 ## strlen
 
 .section  __TEXT,__ustring
-l_.str.2:
+l_.ustr:
   .short  102 ## f
   .short  111 ## o
   .short  0   ## \0
@@ -77,7 +81,7 @@ L__unnamed_cfstring_.2:
   .quad  ___CFConstantStringClassReference
   .long  2000 ## utf-16
   .space  4
-  .quad  l_.str.2
+  .quad  l_.ustr
   .quad  4 ## strlen
 
 .text
@@ -116,7 +120,7 @@ _named_cfstring:
 
 .section  __TEXT,__ustring
   .p2align  1
-l_.str.2:
+l_.ustr:
   .short  102 ## f
   .short  111 ## o
   .short  0   ## \0
@@ -129,7 +133,7 @@ L__unnamed_cfstring_.2:
   .quad  ___CFConstantStringClassReference
   .long  2000 ## utf-16
   .space  4
-  .quad  l_.str.2
+  .quad  l_.ustr
   .quad  4 ## strlen
 
 .text
diff --git a/lld/test/MachO/cgprofile-orderfile.s b/lld/test/MachO/cgprofile-orderfile.s
new file mode 100644
index 0000000000000..eb3a30b27e1bd
--- /dev/null
+++ b/lld/test/MachO/cgprofile-orderfile.s
@@ -0,0 +1,50 @@
+# REQUIRES: x86
+
+# RUN: rm -rf %t; split-file %s %t
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/test.s -o %t/test.o
+
+# RUN: %lld -e A %t/test.o -order_file %t/order_file -o %t/test 
+# RUN: llvm-nm --numeric-sort %t/test | FileCheck %s
+# RUN: %lld -e A %t/test.o -o %t/test 
+# RUN: llvm-nm --numeric-sort %t/test | FileCheck %s --check-prefix NO-ORDER
+
+
+#--- order_file
+B
+A
+
+#--- test.s
+
+.text
+    .globl  D
+D:
+    retq
+
+    .globl  C
+C:
+    retq
+
+    .globl  B
+B:
+    retq
+
+    .globl  A
+A:
+    retq
+
+.cg_profile A, B, 100
+.cg_profile A, C,  40
+.cg_profile C, D,  61
+
+.subsections_via_symbols
+
+# CHECK:      T B
+# CHECK-NEXT: T A
+# CHECK-NEXT: T C
+# CHECK-NEXT: T D
+
+# NO-ORDER:      T A
+# NO-ORDER-NEXT: T B
+# NO-ORDER-NEXT: T C
+# NO-ORDER-NEXT: T D
+
diff --git a/lld/test/MachO/compact-unwind.s b/lld/test/MachO/compact-unwind.s
index 289bba2a2294f..25af4dd7eae1d 100644
--- a/lld/test/MachO/compact-unwind.s
+++ b/lld/test/MachO/compact-unwind.s
@@ -81,6 +81,7 @@
 .globl _my_personality, _exception0
 .text
 .p2align 2
+.no_dead_strip _foo
 _foo:
   .cfi_startproc
 ## This will generate a section relocation.
@@ -91,6 +92,7 @@ _foo:
   .cfi_endproc
 
 .p2align 2
+.no_dead_strip _bar
 _bar:
   .cfi_startproc
 ## Check that we dedup references to the same statically-linked personality.
@@ -100,7 +102,11 @@ _bar:
   ret
   .cfi_endproc
 
+.data
 .p2align 2
+## We put this personality in `__data` to test if we correctly handle
+## personality symbols whose output addresses occur after that of the
+## `__unwind_info` section.
 _my_personality:
   ret
 
@@ -108,6 +114,8 @@ _my_personality:
 _exception0:
   .space 1
 
+.subsections_via_symbols
+
 #--- main.s
 .globl _main, _quux, _my_personality, _exception1
 
diff --git a/lld/test/MachO/cstring-align.s b/lld/test/MachO/cstring-align.s
new file mode 100644
index 0000000000000..f3e995c02e4d3
--- /dev/null
+++ b/lld/test/MachO/cstring-align.s
@@ -0,0 +1,133 @@
+# REQUIRES: x86
+# RUN: rm -rf %t; split-file %s %t
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/align-empty.s -o %t/align-empty.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/align-4-0.s -o %t/align-4-0.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/align-4-2.s -o %t/align-4-2.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/align-16-0.s -o %t/align-16-0.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/align-16-2.s -o %t/align-16-2.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/align-16-4.s -o %t/align-16-4.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/align-16-8.s -o %t/align-16-8.o
+
+## Check that we preserve the alignment of cstrings. Alignment is determined
+## not by section alignment but by the number of trailing zeros of the cstring's
+## address in the input object file.
+
+## The non-dedup case is not particularly interesting since the null bytes don't
+## get dedup'ed, meaning that the output strings get their offsets "naturally"
+## preserved.
+
+# RUN: %lld -dylib %t/align-empty.o %t/align-4-0.o %t/align-16-0.o -o %t/align-4-0-16-0
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/align-4-0-16-0 | \
+# RUN:   FileCheck %s -D#OFF1=4 -D#OFF2=16
+# RUN: %lld -dylib %t/align-empty.o %t/align-16-0.o %t/align-4-0.o -o %t/align-16-0-4-0
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/align-16-0-4-0 | \
+# RUN:   FileCheck %s -D#OFF1=16 -D#OFF2=20
+
+# RUN: %lld -dylib %t/align-empty.o %t/align-4-2.o %t/align-16-0.o -o %t/align-4-2-16-0
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/align-4-2-16-0 | \
+# RUN:   FileCheck %s -D#OFF1=6 -D#OFF2=16
+# RUN: %lld -dylib %t/align-empty.o %t/align-16-0.o %t/align-4-2.o -o %t/align-16-0-4-2
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/align-16-0-4-2 | \
+# RUN:   FileCheck %s -D#OFF1=16 -D#OFF2=22
+
+# RUN: %lld -dylib %t/align-empty.o %t/align-4-0.o %t/align-16-2.o -o %t/align-4-0-16-2
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/align-4-0-16-2 | \
+# RUN:   FileCheck %s -D#OFF1=4 -D#OFF2=18
+# RUN: %lld -dylib %t/align-empty.o %t/align-16-2.o %t/align-4-0.o -o %t/align-16-2-4-0
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/align-16-2-4-0 | \
+# RUN:   FileCheck %s -D#OFF1=18 -D#OFF2=20
+
+# CHECK:       Contents of (__TEXT,__cstring) section
+# CHECK-NEXT:  [[#%.16x,START:]]     {{$}}
+# CHECK:       [[#%.16x,START+OFF1]] a{{$}}
+# CHECK:       [[#%.16x,START+OFF2]] a{{$}}
+# CHECK-EMPTY:
+
+## The dedup cases are more interesting...
+
+## Same offset, different alignments => pick higher alignment
+# RUN: %lld -dylib --deduplicate-literals %t/align-empty.o %t/align-4-0.o %t/align-16-0.o -o %t/dedup-4-0-16-0
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/dedup-4-0-16-0 | \
+# RUN:   FileCheck %s --check-prefix=DEDUP -D#OFF=16
+# RUN: %lld -dylib --deduplicate-literals %t/align-empty.o %t/align-16-0.o %t/align-4-0.o -o %t/dedup-16-0-4-0
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/dedup-16-0-4-0 | \
+# RUN:   FileCheck %s --check-prefix=DEDUP -D#OFF=16
+
+## 16 byte alignment vs 2 byte offset => align to 16 bytes
+# RUN: %lld -dylib --deduplicate-literals %t/align-empty.o %t/align-4-2.o %t/align-16-0.o -o %t/dedup-4-2-16-0
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/dedup-4-2-16-0 | \
+# RUN:   FileCheck %s --check-prefix=DEDUP -D#OFF=16
+# RUN: %lld -dylib --deduplicate-literals %t/align-empty.o %t/align-16-0.o %t/align-4-2.o -o %t/dedup-16-0-4-2
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/dedup-16-0-4-2 | \
+# RUN:   FileCheck %s --check-prefix=DEDUP -D#OFF=16
+
+## 4 byte alignment vs 2 byte offset => align to 4 bytes
+# RUN: %lld -dylib --deduplicate-literals %t/align-empty.o %t/align-4-0.o %t/align-16-2.o -o %t/dedup-4-0-16-2
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/dedup-4-0-16-2 | \
+# RUN:   FileCheck %s --check-prefix=DEDUP -D#OFF=4
+# RUN: %lld -dylib --deduplicate-literals %t/align-empty.o %t/align-16-2.o %t/align-4-0.o -o %t/dedup-16-2-4-0
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/dedup-16-2-4-0 | \
+# RUN:   FileCheck %s --check-prefix=DEDUP -D#OFF=4
+
+## Both inputs are 4-byte aligned, one via offset and the other via section alignment
+# RUN: %lld -dylib --deduplicate-literals %t/align-empty.o %t/align-4-0.o %t/align-16-4.o -o %t/dedup-4-0-16-4
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/dedup-4-0-16-4 | \
+# RUN:   FileCheck %s --check-prefix=DEDUP -D#OFF=4
+# RUN: %lld -dylib --deduplicate-literals %t/align-empty.o %t/align-16-4.o %t/align-4-0.o -o %t/dedup-16-4-4-0
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/dedup-16-4-4-0 | \
+# RUN:   FileCheck %s --check-prefix=DEDUP -D#OFF=4
+
+## 8-byte offset vs 4-byte section alignment => align to 8 bytes
+# RUN: %lld -dylib --deduplicate-literals %t/align-empty.o %t/align-4-0.o %t/align-16-8.o -o %t/dedup-4-0-16-8
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/dedup-4-0-16-8 | \
+# RUN:   FileCheck %s --check-prefix=DEDUP -D#OFF=8
+# RUN: %lld -dylib --deduplicate-literals %t/align-empty.o %t/align-16-8.o %t/align-4-0.o -o %t/dedup-16-8-4-0
+# RUN: llvm-objdump --macho --section="__TEXT,__cstring" %t/dedup-16-8-4-0 | \
+# RUN:   FileCheck %s --check-prefix=DEDUP -D#OFF=8
+
+# DEDUP:       Contents of (__TEXT,__cstring) section
+# DEDUP-NEXT:  [[#%.16x,START:]]    {{$}}
+# DEDUP:       [[#%.16x,START+OFF]] a{{$}}
+# DEDUP-EMPTY:
+
+#--- align-empty.s
+## We use this file to create an empty string at the start of every output
+## file's .cstring section. This makes the test cases more interesting since LLD
+## can't place the string "a" at the trivially-aligned zero offset.
+.cstring
+.p2align 2
+.asciz ""
+
+#--- align-4-0.s
+.cstring
+.p2align 2
+.asciz "a"
+
+#--- align-4-2.s
+.cstring
+.p2align 2
+.zero 0x2
+.asciz "a"
+
+#--- align-16-0.s
+.cstring
+.p2align 4
+.asciz "a"
+
+#--- align-16-2.s
+.cstring
+.p2align 4
+.zero 0x2
+.asciz "a"
+
+#--- align-16-4.s
+.cstring
+.p2align 4
+.zero 0x4
+.asciz "a"
+
+#--- align-16-8.s
+.cstring
+.p2align 4
+.zero 0x8
+.asciz "a"
diff --git a/lld/test/MachO/cstring-dedup.s b/lld/test/MachO/cstring-dedup.s
index 86ba812d02087..144e77d66050c 100644
--- a/lld/test/MachO/cstring-dedup.s
+++ b/lld/test/MachO/cstring-dedup.s
@@ -8,12 +8,11 @@
 # RUN: llvm-objdump --macho --section="__DATA,ptrs" --syms %t/test | FileCheck %s
 # RUN: llvm-readobj --section-headers %t/test | FileCheck %s --check-prefix=HEADER
 
-## Make sure we only have 3 deduplicated strings in __cstring, and that they
-## are 16-byte-aligned.
+## Make sure we only have 3 deduplicated strings in __cstring.
 # STR: Contents of (__TEXT,__cstring) section
-# STR: {{.*}}0 foo
-# STR: {{.*}}0 barbaz
-# STR: {{.*}}0 {{$}}
+# STR: {{[[:xdigit:]]+}} foo
+# STR: {{[[:xdigit:]]+}} barbaz
+# STR: {{[[:xdigit:]]+}} {{$}}
 
 ## Make sure both symbol and section relocations point to the right thing.
 # CHECK:      Contents of (__DATA,ptrs) section
diff --git a/lld/test/MachO/demangle.s b/lld/test/MachO/demangle.s
index 0352f16210bab..14ebfa12b0f22 100644
--- a/lld/test/MachO/demangle.s
+++ b/lld/test/MachO/demangle.s
@@ -1,15 +1,46 @@
 # REQUIRES: x86
 
-# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %s -o %t.o
+# RUN: rm -rf %t; split-file %s %t
 
-# RUN: not %lld %t.o -o /dev/null 2>&1 | FileCheck %s
-# RUN: not %lld -demangle %t.o -o /dev/null 2>&1 | \
-# RUN:     FileCheck --check-prefix=DEMANGLE %s
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/undefined-symbol.s -o %t/undefined-symbol.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/export-symbols.s -o %t/export-symbols.o
 
-# CHECK: undefined symbol: __Z1fv
-# DEMANGLE: undefined symbol: f()
+# RUN: not %lld %t/undefined-symbol.o -o /dev/null 2>&1 | FileCheck --check-prefix=UNDEF %s
+# RUN: not %lld -demangle %t/undefined-symbol.o -o /dev/null 2>&1 | \
+# RUN:     FileCheck --check-prefix=DEMANGLE-UNDEF %s
 
+# RUN: not %lld -exported_symbol __ZTIN3foo3bar4MethE -exported_symbol __ZTSN3foo3bar4MethE %t/export-symbols.o -o /dev/null 2>&1 | FileCheck --check-prefix=EXPORT %s
+# RUN: not %lld -demangle -exported_symbol __ZTIN3foo3bar4MethE -exported_symbol __ZTSN3foo3bar4MethE %t/export-symbols.o -o /dev/null 2>&1 | FileCheck --check-prefix=DEMANGLE-EXPORT %s
+
+# UNDEF: undefined symbol: __Z1fv
+# DEMANGLE-UNDEF: undefined symbol: f()
+
+# EXPORT: cannot export hidden symbol __ZTSN3foo3bar4MethE
+# EXPORT: cannot export hidden symbol __ZTIN3foo3bar4MethE
+
+# DEMANGLE-EXPORT: cannot export hidden symbol typeinfo name for foo::bar::Meth
+# DEMANGLE-EXPORT: cannot export hidden symbol typeinfo for foo::bar::Meth
+
+#--- undefined-symbol.s
 .globl _main
 _main:
   callq __Z1fv
   ret
+
+
+#--- export-symbols.s
+.globl _main
+_main:
+  ret
+
+.globl __ZTIN3foo3bar4MethE
+.weak_def_can_be_hidden __ZTIN3foo3bar4MethE
+.private_extern __ZTIN3foo3bar4MethE
+__ZTIN3foo3bar4MethE:
+  retq
+
+.globl __ZTSN3foo3bar4MethE
+.weak_def_can_be_hidden __ZTSN3foo3bar4MethE
+.private_extern __ZTSN3foo3bar4MethE
+__ZTSN3foo3bar4MethE:
+  retq
diff --git a/lld/test/MachO/double-unwind-info.s b/lld/test/MachO/double-unwind-info.s
new file mode 100644
index 0000000000000..d1301cb744207
--- /dev/null
+++ b/lld/test/MachO/double-unwind-info.s
@@ -0,0 +1,26 @@
+## When changing the assembly input, uncomment these lines to re-generate the
+## YAML.
+# COM: llvm-mc --emit-dwarf-unwind=always -filetype=obj -triple=x86_64-apple-macos10.15 %s -o %t.o
+# COM: ld -r %t.o -o %t-r.o
+# COM: obj2yaml %t-r.o > %S/Inputs/double-unwind-info.yaml
+
+# RUN: yaml2obj %S/Inputs/double-unwind-info.yaml > %t-r.o
+# RUN: %lld -dylib -lSystem %t-r.o -o /dev/null
+
+.text
+## eh_frame function address relocations are only emitted if the function isn't
+## at address 0x0.
+_spacer:
+  nop
+
+## Check that we perform unwind info registration correctly when there are
+## multiple symbols at the same address. This would previously hit an assertion
+## error (PR56570).
+_foo:
+ltmp1:
+  .cfi_startproc
+  .cfi_def_cfa_offset 8
+  nop
+  .cfi_endproc
+
+.subsections_via_symbols
diff --git a/lld/test/MachO/eh-frame-dead-strip.s b/lld/test/MachO/eh-frame-dead-strip.s
new file mode 100644
index 0000000000000..c9eb8c167720d
--- /dev/null
+++ b/lld/test/MachO/eh-frame-dead-strip.s
@@ -0,0 +1,46 @@
+# REQUIRES: x86, aarch64
+
+# RUN: rm -rf %t; split-file %s %t
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos11.0 %t/strong.s -o %t/strong_x86_64.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos11.0 %t/weak.s -o %t/weak_x86_64.o
+# RUN: %lld -dylib -dead_strip %t/strong_x86_64.o %t/weak_x86_64.o -o %t/libstrongweak_x86_64.dylib
+# RUN: llvm-dwarfdump --eh-frame %t/libstrongweak_x86_64.dylib | FileCheck --check-prefixes CHECK,X86_64 %s
+# RUN: %lld -dylib -dead_strip %t/weak_x86_64.o %t/strong_x86_64.o -o %t/libweakstrong_x86_64.dylib
+# RUN: llvm-dwarfdump --eh-frame %t/libweakstrong_x86_64.dylib | FileCheck --check-prefixes CHECK,X86_64 %s
+
+# RUN: llvm-mc -filetype=obj -triple=arm64-apple-macos11.0 %t/strong.s -o %t/strong_arm64.o
+# RUN: llvm-mc -filetype=obj -triple=arm64-apple-macos11.0 %t/weak.s -o %t/weak_arm64.o
+# RUN: %lld -arch arm64 -dylib -dead_strip %t/strong_arm64.o %t/weak_arm64.o -o %t/libstrongweak_arm64.dylib
+# RUN: llvm-dwarfdump --eh-frame %t/libstrongweak_arm64.dylib | FileCheck --check-prefixes CHECK,ARM64 %s
+# RUN: %lld -arch arm64 -dylib -dead_strip %t/weak_arm64.o %t/strong_arm64.o -o %t/libweakstrong_arm64.dylib
+# RUN: llvm-dwarfdump --eh-frame %t/libweakstrong_arm64.dylib | FileCheck --check-prefixes CHECK,ARM64 %s
+
+## Verify that unneeded FDEs (and their CIEs) are dead-stripped even if they
+## point to a live symbol (e.g. because we had multiple weak definitions).
+
+# CHECK: .eh_frame contents:
+# X86_64: 00000000 00000014 00000000 CIE
+# X86_64: 00000018 0000001c 0000001c FDE cie=00000000
+# ARM64: 00000000 00000010 00000000 CIE
+# ARM64: 00000014 00000018 00000018 FDE cie=00000000
+# CHECK-NOT: CIE
+# CHECK-NOT: FDE
+
+#--- strong.s
+.globl _fun
+_fun:
+  .cfi_startproc
+  ## cfi_escape cannot be encoded in compact unwind
+  .cfi_escape 0
+  ret
+  .cfi_endproc
+
+#--- weak.s
+.globl _fun
+.weak_definition _fun
+_fun:
+  .cfi_startproc
+  ## cfi_escape cannot be encoded in compact unwind
+  .cfi_escape 0
+  ret
+  .cfi_endproc
diff --git a/lld/test/MachO/eh-frame-sdata4.s b/lld/test/MachO/eh-frame-sdata4.s
new file mode 100644
index 0000000000000..20eb6cfd6e0e3
--- /dev/null
+++ b/lld/test/MachO/eh-frame-sdata4.s
@@ -0,0 +1,80 @@
+# REQUIRES: x86
+# RUN: rm -rf %t; split-file %s %t
+
+## Test that we correctly handle the sdata4 DWARF pointer encoding. llvm-mc's
+## CFI directives always generate EH frames using the absptr (i.e. system
+## pointer size) encoding, but it is possible to hand-roll your own EH frames
+## that use the sdata4 encoding. For instance, libffi does this.
+
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos10.15 %t/sdata4.s -o %t/sdata4.o
+# RUN: %lld -lSystem %t/sdata4.o -o %t/sdata4
+# RUN: llvm-objdump --macho --syms --dwarf=frames %t/sdata4 | FileCheck %s
+
+# CHECK: SYMBOL TABLE:
+# CHECK: [[#%.16x,MAIN:]] g     F __TEXT,__text _main
+
+# CHECK: .eh_frame contents:
+# CHECK: 00000000 00000010 00000000 CIE
+# CHECK:   Format:                DWARF32
+# CHECK:   Version:               1
+# CHECK:   Augmentation:          "zR"
+# CHECK:   Code alignment factor: 1
+# CHECK:   Data alignment factor: 1
+# CHECK:   Return address column: 1
+# CHECK:   Augmentation data:     1B
+# CHECK:   DW_CFA_def_cfa: reg7 +8
+# CHECK:   CFA=reg7+8
+
+# CHECK: 00000014 00000010 00000018 FDE cie=00000000 pc=[[#%x,MAIN]]...[[#%x,MAIN+1]]
+# CHECK:   Format:       DWARF32
+# CHECK:   DW_CFA_GNU_args_size: +16
+# CHECK:   DW_CFA_nop:
+# CHECK:   0x[[#%x,MAIN]]: CFA=reg7+8
+
+#--- sdata4.s
+.globl  _main
+_main:
+  retq
+LmainEnd:
+
+.balign 4
+.section __TEXT,__eh_frame
+# Although we don't reference this EhFrame symbol directly, we must have at
+# least one non-local symbol in this section, otherwise llvm-mc generates bogus
+# subtractor relocations.
+EhFrame:
+LCieHdr:
+  .long LCieEnd - LCieStart
+LCieStart:
+  .long 0           # CIE ID
+  .byte 1           # CIE version
+  .ascii "zR\0"
+  .byte 1           # Code alignment
+  .byte 1           # Data alignment
+  .byte 1           # RA column
+  .byte 1           # Augmentation size
+  .byte 0x1b        # FDE pointer encoding (pcrel | sdata4)
+  .byte 0xc, 7, 8   # DW_CFA_def_cfa reg7 +8
+  .balign 4
+LCieEnd:
+
+LFdeHdr:
+  .long LFdeEnd - LFdeStart
+LFdeStart:
+  .long LFdeStart - LCieHdr
+  # The next two fields are longs instead of quads because of the sdata4
+  # encoding.
+  .long _main - .        # Function address
+  .long LmainEnd - _main # Function length
+  .byte 0
+  ## Insert DW_CFA_GNU_args_size to prevent ld64 from creating a compact unwind
+  ## entry to replace this FDE. Makes it easier for us to cross-check behavior
+  ## across the two linkers (LLD never bothers trying to synthesize compact
+  ## unwind if it is not already present).
+  .byte 0x2e, 0x10       # DW_CFA_GNU_args_size
+  .balign 4
+LFdeEnd:
+
+  .long 0 # terminator
+
+.subsections_via_symbols 
diff --git a/lld/test/MachO/export-options.s b/lld/test/MachO/export-options.s
index 5678a48719a65..32ff8ac8fd8c0 100644
--- a/lld/test/MachO/export-options.s
+++ b/lld/test/MachO/export-options.s
@@ -133,7 +133,7 @@
 # RUN: llvm-nm -g %t/exp-autohide.dylib | FileCheck %s --check-prefix=EXP-AUTOHIDE
 
 # RUN: not %lld -dylib -exported_symbol "_foo" %t/autohide-private-extern.o \
-# RUN: -o /dev/null  2>&1 | FileCheck %s --check-prefix=AUTOHIDE-PRIVATE
+# RUN:   -o /dev/null  2>&1 | FileCheck %s --check-prefix=AUTOHIDE-PRIVATE
 
 # RUN: not %lld -dylib -exported_symbol "_foo" %t/autohide.o \
 # RUN:   %t/glob-private-extern.o -o /dev/null 2>&1 | \
@@ -143,9 +143,25 @@
 # RUN:   %t/weak-private-extern.o -o /dev/null 2>&1 | \
 # RUN:   FileCheck %s --check-prefix=AUTOHIDE-PRIVATE
 
-# EXP-AUTOHIDE: T _foo        
+## Test that exported hidden symbols are still treated as a liveness root.
+## This previously used to crash when enabling -dead_strip since it's unconventional
+## to add treat private extern symbols as a liveness root.
+# RUN: %no-fatal-warnings-lld -dylib -exported_symbol "_foo" %t/autohide-private-extern.o \
+# RUN:   -dead_strip -o %t/exported-hidden
+# RUN: llvm-nm -m %t/exported-hidden | FileCheck %s --check-prefix=AUTOHIDE-PRIVATE-DEAD-STRIP
+
+# RUN: %no-fatal-warnings-lld -dylib -exported_symbol "_foo" %t/autohide.o \
+# RUN:   -dead_strip %t/glob-private-extern.o -o %t/exported-hidden
+# RUN: llvm-nm -m %t/exported-hidden | FileCheck %s --check-prefix=AUTOHIDE-PRIVATE-DEAD-STRIP
+
+# RUN: %no-fatal-warnings-lld -dylib -exported_symbol "_foo" %t/autohide.o \
+# RUN:   -dead_strip %t/weak-private-extern.o -o %t/exported-hidden
+# RUN: llvm-nm -m %t/exported-hidden | FileCheck %s --check-prefix=AUTOHIDE-PRIVATE-DEAD-STRIP
+
+# EXP-AUTOHIDE: T _foo
 # AUTOHIDE-PRIVATE: error: cannot export hidden symbol _foo
-        
+# AUTOHIDE-PRIVATE-DEAD-STRIP: (__TEXT,__text) non-external (was a private external) _foo
+
 #--- default.s
 
 .globl _keep_globl, _hide_globl
@@ -214,6 +230,6 @@ _foo:
 #--- weak-private-extern.s
 .global _foo
 .weak_definition _foo
-.private_extern _foo        
+.private_extern _foo
 _foo:
   retq
diff --git a/lld/test/MachO/fatal-warnings.s b/lld/test/MachO/fatal-warnings.s
index ae08a13678687..8cd1d36c73489 100644
--- a/lld/test/MachO/fatal-warnings.s
+++ b/lld/test/MachO/fatal-warnings.s
@@ -6,6 +6,12 @@
 # RUN: not %no_fatal_warnings_lld %t1.o -fatal_warnings -o /dev/null \
 # RUN:     -single_module 2>&1 | FileCheck -check-prefix=ERROR %s
 
+# RUN: %no-fatal-warnings-lld %t1.o -w -o /dev/null -single_module 2>&1 \
+# RUN:     | count 0
+# RUN: not %no-fatal-warnings-lld %t1.o -fatal_warnings -w -o /dev/null \
+# RUN:     -single_module 2>&1 \
+# RUN:     | FileCheck --check-prefix=ERROR %s
+
 # ERROR: error: Option `-single_module' is deprecated
 # WARNING: warning: Option `-single_module' is deprecated
 
diff --git a/lld/test/MachO/flat-namespace.s b/lld/test/MachO/flat-namespace-dysyms.s
similarity index 100%
rename from lld/test/MachO/flat-namespace.s
rename to lld/test/MachO/flat-namespace-dysyms.s
diff --git a/lld/test/MachO/flat-namespace-interposable.s b/lld/test/MachO/flat-namespace-interposable.s
new file mode 100644
index 0000000000000..e561f7b1c9be8
--- /dev/null
+++ b/lld/test/MachO/flat-namespace-interposable.s
@@ -0,0 +1,80 @@
+# REQUIRES: x86
+# RUN: rm -rf %t; split-file %s %t
+
+## With -flat_namespace, non-weak extern symbols in dylibs become interposable.
+## Check that we generate the correct bindings for them. The test also includes
+## other symbol types like weak externs to verify we continue to do the same
+## (correct) thing even when `-flat_namespace` is enabled, instead of generating
+## spurious bindings.
+
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos -o %t/foo.o %t/foo.s
+# RUN: %lld -lSystem -flat_namespace -o %t/foo %t/foo.o
+# RUN: %lld -lSystem -dylib -flat_namespace -o %t/foo.dylib %t/foo.o
+# RUN: %lld -lSystem -bundle -flat_namespace -o %t/foo.bundle %t/foo.o
+# RUN: llvm-objdump --macho --bind --lazy-bind --weak-bind %t/foo | FileCheck \
+# RUN:   %s --check-prefix=EXEC --implicit-check-not=_private_extern
+# RUN: llvm-objdump --macho --bind --lazy-bind --weak-bind %t/foo.dylib | \
+# RUN:   FileCheck %s --check-prefix=DYLIB --implicit-check-not=_private_extern
+# RUN: llvm-objdump --macho --bind --lazy-bind --weak-bind %t/foo.bundle | \
+# RUN:   FileCheck %s --check-prefix=DYLIB --implicit-check-not=_private_extern
+
+## Executables with -flat_namespace don't have interposable externs.
+# EXEC:       Bind table:
+# EXEC-NEXT:  segment  section          address  type     addend dylib   symbol
+# EXEC-EMPTY:
+# EXEC-NEXT:  Lazy bind table:
+# EXEC-NEXT:  segment  section          address  dylib    symbol
+# EXEC-EMPTY:
+# EXEC-NEXT:  Weak bind table:
+# EXEC-NEXT:  segment  section          address  type     addend   symbol
+# EXEC-NEXT:  __DATA   __la_symbol_ptr  {{.*}}   pointer       0   _weak_extern
+# EXEC-NEXT:  __DATA   __data           {{.*}}   pointer       0   _weak_extern
+# EXEC-EMPTY:
+
+# DYLIB:       Bind table:
+# DYLIB-NEXT:  segment      section        address  type     addend dylib            symbol
+# DYLIB-DAG:   __DATA       __data         {{.*}}   pointer       0 flat-namespace   _extern
+# DYLIB-DAG:   __DATA       __thread_ptrs  {{.*}}   pointer       0 flat-namespace   _tlv
+# DYLIB-DAG:   __DATA_CONST __got          {{.*}}   pointer       0 flat-namespace   dyld_stub_binder
+# DYLIB-EMPTY:
+# DYLIB-NEXT:  Lazy bind table:
+# DYLIB-NEXT:  segment  section            address  dylib            symbol
+# DYLIB-NEXT:  __DATA   __la_symbol_ptr    {{.*}}   flat-namespace   _extern
+# DYLIB-EMPTY:
+# DYLIB-NEXT:  Weak bind table:
+# DYLIB-NEXT:  segment  section            address  type    addend   symbol
+# DYLIB-NEXT:  __DATA   __la_symbol_ptr    {{.*}}   pointer      0   _weak_extern
+# DYLIB-NEXT:  __DATA   __data             {{.*}}   pointer      0   _weak_extern
+
+#--- foo.s
+
+.globl _main, _extern, _weak_extern, _tlv
+.weak_definition _weak_extern
+.private_extern _private_extern
+
+_extern:
+  retq
+_weak_extern:
+  retq
+_private_extern:
+  retq
+_local:
+  retq
+
+_main:
+  callq _extern
+  callq _weak_extern
+  callq _private_extern
+  callq _local
+  mov _tlv@TLVP(%rip), %rax
+  retq
+
+.data
+.quad _extern
+.quad _weak_extern
+.quad _local
+
+.section __DATA,__thread_vars,thread_local_variables
+_tlv:
+
+.subsections_via_symbols
diff --git a/lld/test/MachO/icf-literals.s b/lld/test/MachO/icf-literals.s
index 908929655195e..815ca472a7e3f 100644
--- a/lld/test/MachO/icf-literals.s
+++ b/lld/test/MachO/icf-literals.s
@@ -7,6 +7,10 @@
 # CHECK:      _main:
 # CHECK-NEXT: callq   _foo2_ref
 # CHECK-NEXT: callq   _foo2_ref
+# CHECK-NEXT: callq   _foo2_neg_offset_ref
+# CHECK-NEXT: callq   _foo2_neg_offset_ref
+# CHECK-NEXT: callq   _foo2_pos_offset_ref
+# CHECK-NEXT: callq   _foo2_pos_offset_ref
 # CHECK-NEXT: callq   _bar2_ref
 # CHECK-NEXT: callq   _bar2_ref
 # CHECK-NEXT: callq   _baz2_ref
@@ -28,6 +32,10 @@
 # CHECK-NEXT: [[#%.16x,QUX:]]     l     O __TEXT,__literals _qux2
 # CHECK-NEXT: [[#%.16x,FOO_REF:]] l     F __TEXT,__text _foo1_ref
 # CHECK-NEXT: [[#%.16x,FOO_REF:]] l     F __TEXT,__text _foo2_ref
+# CHECK-NEXT: [[#%.16x,FOO_NEG:]] l     F __TEXT,__text _foo1_neg_offset_ref
+# CHECK-NEXT: [[#%.16x,FOO_NEG]]  l     F __TEXT,__text _foo2_neg_offset_ref
+# CHECK-NEXT: [[#%.16x,FOO_POS:]] l     F __TEXT,__text _foo1_pos_offset_ref
+# CHECK-NEXT: [[#%.16x,FOO_POS]]  l     F __TEXT,__text _foo2_pos_offset_ref
 # CHECK-NEXT: [[#%.16x,BAR_REF:]] l     F __TEXT,__text _bar1_ref
 # CHECK-NEXT: [[#%.16x,BAR_REF:]] l     F __TEXT,__text _bar2_ref
 # CHECK-NEXT: [[#%.16x,BAZ_REF:]] l     F __TEXT,__text _baz1_ref
@@ -63,6 +71,18 @@ _foo1_ref:
   leaq _foo1(%rip), %rax
 _foo2_ref:
   leaq _foo2(%rip), %rax
+_foo1_neg_offset_ref:
+## Check that we can correctly handle `_foo1-32` even though it points outside
+## the __cstring section.
+  leaq _foo1-32(%rip), %rax
+_foo2_neg_offset_ref:
+  leaq _foo2-32(%rip), %rax
+_foo1_pos_offset_ref:
+  leaq _foo1+4(%rip), %rax
+_foo2_pos_offset_ref:
+## Although `_foo2+4` points at _bar1 in the input object file, we shouldn't
+## dedup references to _foo2+4 with references to _bar1.
+  leaq _foo2+4(%rip), %rax
 _bar1_ref:
   leaq _bar1(%rip), %rax
 _bar2_ref:
@@ -101,6 +121,10 @@ _sub_lit_b_a:
 _main:
   callq _foo1_ref
   callq _foo2_ref
+  callq _foo1_neg_offset_ref
+  callq _foo2_neg_offset_ref
+  callq _foo1_pos_offset_ref
+  callq _foo2_pos_offset_ref
   callq _bar1_ref
   callq _bar2_ref
   callq _baz1_ref
diff --git a/lld/test/MachO/icf-options.s b/lld/test/MachO/icf-options.s
index 3a6eddb80361b..51383602214bb 100644
--- a/lld/test/MachO/icf-options.s
+++ b/lld/test/MachO/icf-options.s
@@ -8,8 +8,8 @@
 # RUN:     | FileCheck %s --check-prefix=DIAG-EMPTY --allow-empty
 # RUN: %lld -lSystem -no_deduplicate -o %t/no_dedup %t/main.o 2>&1 \
 # RUN:     | FileCheck %s --check-prefix=DIAG-EMPTY --allow-empty
-# RUN: not %lld -lSystem --icf=safe -o %t/safe %t/main.o 2>&1 \
-# RUN:     | FileCheck %s --check-prefix=DIAG-SAFE
+# RUN: %lld -lSystem --icf=safe -o %t/safe %t/main.o 2>&1 \
+# RUN:     | FileCheck %s --check-prefix=DIAG-EMPTY --allow-empty
 # RUN: not %lld -lSystem --icf=junk -o %t/junk %t/main.o 2>&1 \
 # RUN:     | FileCheck %s --check-prefix=DIAG-JUNK
 # RUN: %lld -lSystem --icf=all -no_deduplicate -o %t/none2 %t/main.o 2>&1 \
@@ -18,7 +18,6 @@
 # RUN:     | FileCheck %s --check-prefix=DIAG-EMPTY --allow-empty
 
 # DIAG-EMPTY-NOT: {{.}}
-# DIAG-SAFE: `--icf=safe' is not yet implemented, reverting to `none'
 # DIAG-JUNK: unknown --icf=OPTION `junk', defaulting to `none'
 
 # RUN: llvm-objdump -d --syms %t/all | FileCheck %s --check-prefix=FOLD
diff --git a/lld/test/MachO/icf-safe.ll b/lld/test/MachO/icf-safe.ll
new file mode 100644
index 0000000000000..71c6f9f7ddac8
--- /dev/null
+++ b/lld/test/MachO/icf-safe.ll
@@ -0,0 +1,65 @@
+; REQUIRES: aarch64
+
+; RUN: rm -rf %t; mkdir %t
+
+; RUN: llc -filetype=obj %s -O3 -o %t/icf-obj.o -enable-machine-outliner=never -mtriple arm64-apple-macos -addrsig
+; RUN: %lld -arch arm64 -lSystem --icf=safe -dylib -o %t/icf-safe.dylib %t/icf-obj.o
+; RUN: %lld -arch arm64 -lSystem --icf=all  -dylib -o %t/icf-all.dylib  %t/icf-obj.o
+; RUN: llvm-objdump %t/icf-safe.dylib -d --macho | FileCheck %s --check-prefix=ICFSAFE
+; RUN: llvm-objdump %t/icf-all.dylib  -d --macho | FileCheck %s --check-prefix=ICFALL
+
+; RUN: llvm-as %s -o %t/icf-bitcode.o
+; RUN: %lld -arch arm64 -lSystem --icf=safe -dylib -o %t/icf-safe-bitcode.dylib %t/icf-bitcode.o
+; RUN: %lld -arch arm64 -lSystem --icf=all  -dylib -o %t/icf-all-bitcode.dylib %t/icf-bitcode.o
+; RUN: llvm-objdump %t/icf-safe-bitcode.dylib -d --macho | FileCheck %s --check-prefix=ICFSAFE
+; RUN: llvm-objdump %t/icf-all-bitcode.dylib  -d --macho | FileCheck %s --check-prefix=ICFALL
+
+; ICFSAFE-LABEL:  _callAllFunctions
+; ICFSAFE:        bl _func02
+; ICFSAFE-NEXT:   bl _func02
+; ICFSAFE-NEXT:   bl _func03_takeaddr
+
+; ICFALL-LABEL:   _callAllFunctions
+; ICFALL:         bl _func03_takeaddr
+; ICFALL-NEXT:    bl _func03_takeaddr
+; ICFALL-NEXT:    bl _func03_takeaddr
+
+target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
+target triple = "arm64-apple-macos11.0"
+
+@result = global i32 0, align 4
+
+define void @func01() local_unnamed_addr noinline {
+entry:
+  %0 = load volatile i32, ptr @result, align 4
+  %add = add nsw i32 %0, 1
+  store volatile i32 %add, ptr @result, align 4
+  ret void
+}
+
+define void @func02() local_unnamed_addr noinline {
+entry:
+  %0 = load volatile i32, ptr @result, align 4
+  %add = add nsw i32 %0, 1
+  store volatile i32 %add, ptr @result, align 4
+  ret void
+}
+
+define void @func03_takeaddr() noinline {
+entry:
+  %0 = load volatile i32, ptr @result, align 4
+  %add = add nsw i32 %0, 1
+  store volatile i32 %add, ptr @result, align 4
+  ret void
+}
+
+define void @callAllFunctions() local_unnamed_addr {
+entry:
+  tail call void @func01()
+  tail call void @func02()
+  tail call void @func03_takeaddr()
+  %0 = load volatile i32, ptr @result, align 4
+  %add = add nsw i32 %0, ptrtoint (ptr @func03_takeaddr to i32)
+  store volatile i32 %add, ptr @result, align 4
+  ret void
+}
diff --git a/lld/test/MachO/icf-undef.s b/lld/test/MachO/icf-undef.s
new file mode 100644
index 0000000000000..ef445fa583455
--- /dev/null
+++ b/lld/test/MachO/icf-undef.s
@@ -0,0 +1,28 @@
+# REQUIRES: x86
+# RUN: rm -rf %t; split-file %s %t
+
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin19.0.0 %t/test.s -o %t/test.o
+
+## Check that we correctly dedup sections that reference dynamic-lookup symbols.
+# RUN: %lld -lSystem -dylib --icf=all -undefined dynamic_lookup -o %t/test %t/test.o
+# RUN: llvm-objdump --macho --syms %t/test | FileCheck %s
+
+## Check that we still raise an error when using regular undefined symbol
+## treatment.
+# RUN: not %lld -lSystem -dylib --icf=all -o /dev/null %t/test.o 2>&1 | \
+# RUN:   FileCheck %s --check-prefix=ERR
+
+# CHECK: [[#%x,ADDR:]] l    F __TEXT,__text _foo
+# CHECK: [[#ADDR]]     l    F __TEXT,__text _bar
+
+# ERR: error: undefined symbol: _undef
+
+#--- test.s
+
+.subsections_via_symbols
+
+_foo:
+  callq _undef + 1
+
+_bar:
+  callq _undef + 1
diff --git a/lld/test/MachO/icf.s b/lld/test/MachO/icf.s
index 5e61e941bffa2..4405bf8c13746 100644
--- a/lld/test/MachO/icf.s
+++ b/lld/test/MachO/icf.s
@@ -22,11 +22,13 @@
 # CHECK: [[#%x,DYLIB_REF_2:]]               l     F __TEXT,__text _dylib_ref_1
 # CHECK: [[#%x,DYLIB_REF_2:]]               l     F __TEXT,__text _dylib_ref_2
 # CHECK: [[#%x,DYLIB_REF_3:]]               l     F __TEXT,__text _dylib_ref_3
+# CHECK: [[#%x,DYLIB_REF_4:]]               l     F __TEXT,__text _dylib_ref_4
 # CHECK: [[#%x,ALT:]]                       l     F __TEXT,__text _alt
 # CHECK: [[#%x,WITH_ALT_ENTRY:]]            l     F __TEXT,__text _with_alt_entry
 # CHECK: [[#%x,WITH_ALT_ENTRY:]]            l     F __TEXT,__text _no_alt_entry
 # CHECK: [[#%x,DEFINED_REF_WITH_ADDEND_2:]] l     F __TEXT,__text _defined_ref_with_addend_1
 # CHECK: [[#%x,DEFINED_REF_WITH_ADDEND_2:]] l     F __TEXT,__text _defined_ref_with_addend_2
+# CHECK: [[#%x,DEFINED_REF_WITH_ADDEND_3:]] l     F __TEXT,__text _defined_ref_with_addend_3
 # CHECK: [[#%x,RECURSIVE:]]                 l     F __TEXT,__text _recursive
 # CHECK: [[#%x,CALL_RECURSIVE_2:]]          l     F __TEXT,__text _call_recursive_1
 # CHECK: [[#%x,CALL_RECURSIVE_2:]]          l     F __TEXT,__text _call_recursive_2
@@ -55,11 +57,13 @@
 # CHECK: callq 0x[[#%x,DYLIB_REF_2:]]               <_dylib_ref_2>
 # CHECK: callq 0x[[#%x,DYLIB_REF_2:]]               <_dylib_ref_2>
 # CHECK: callq 0x[[#%x,DYLIB_REF_3:]]               <_dylib_ref_3>
+# CHECK: callq 0x[[#%x,DYLIB_REF_4:]]               <_dylib_ref_4>
 # CHECK: callq 0x[[#%x,ALT:]]                       <_alt>
 # CHECK: callq 0x[[#%x,WITH_ALT_ENTRY:]]            <_with_alt_entry>
 # CHECK: callq 0x[[#%x,WITH_ALT_ENTRY:]]            <_with_alt_entry>
 # CHECK: callq 0x[[#%x,DEFINED_REF_WITH_ADDEND_2:]] <_defined_ref_with_addend_2>
 # CHECK: callq 0x[[#%x,DEFINED_REF_WITH_ADDEND_2:]] <_defined_ref_with_addend_2>
+# CHECK: callq 0x[[#%x,DEFINED_REF_WITH_ADDEND_3:]] <_defined_ref_with_addend_3>
 # CHECK: callq 0x[[#%x,RECURSIVE:]]                 <_recursive>
 # CHECK: callq 0x[[#%x,CALL_RECURSIVE_2:]]          <_call_recursive_2>
 # CHECK: callq 0x[[#%x,CALL_RECURSIVE_2:]]          <_call_recursive_2>
@@ -132,6 +136,11 @@ _dylib_ref_3:
   mov ___inf@GOTPCREL(%rip), %rax
   callq ___inf
 
+## No fold: referent dylib addend differs
+_dylib_ref_4:
+  mov ___nan + 1@GOTPCREL(%rip), %rax
+  callq ___inf + 1
+
 ## We can merge two sections even if one of them has an alt entry. Just make
 ## sure we don't merge the alt entry symbol with a regular symbol.
 .alt_entry _alt
@@ -150,6 +159,10 @@ _defined_ref_with_addend_1:
 _defined_ref_with_addend_2:
   callq _with_alt_entry + 4
 
+# No fold: addend differs
+_defined_ref_with_addend_3:
+  callq _with_alt_entry + 8
+
 ## _recursive has the same body as its next two callers, but cannot be folded
 ## with them.
 _recursive:
@@ -251,11 +264,13 @@ _main:
   callq _dylib_ref_1
   callq _dylib_ref_2
   callq _dylib_ref_3
+  callq _dylib_ref_4
   callq _alt
   callq _with_alt_entry
   callq _no_alt_entry
   callq _defined_ref_with_addend_1
   callq _defined_ref_with_addend_2
+  callq _defined_ref_with_addend_3
   callq _recursive
   callq _call_recursive_1
   callq _call_recursive_2
diff --git a/lld/test/MachO/invalid/bad-got-to-dylib-tlv-reference.s b/lld/test/MachO/invalid/bad-got-to-dylib-tlv-reference.s
index 85a077e4a35e7..463a044465172 100644
--- a/lld/test/MachO/invalid/bad-got-to-dylib-tlv-reference.s
+++ b/lld/test/MachO/invalid/bad-got-to-dylib-tlv-reference.s
@@ -8,7 +8,7 @@
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/test.s -o %t/test.o
 # RUN: not %lld -lSystem -L%t -ltlv -o /dev/null %t/test.o 2>&1 | FileCheck %s -DFILE=%t/test.o
 
-# CHECK: error: GOT_LOAD relocation requires that variable not be thread-local for `_foo' in [[FILE]]:(__text)
+# CHECK: error: [[FILE]]:(symbol _main+0x3): GOT_LOAD relocation requires that symbol _foo not be thread-local
 
 #--- libtlv.s
 .section __DATA,__thread_vars,thread_local_variables
diff --git a/lld/test/MachO/invalid/bad-got-to-tlv-reference.s b/lld/test/MachO/invalid/bad-got-to-tlv-reference.s
index 815a3de0df5b7..8934bc892a474 100644
--- a/lld/test/MachO/invalid/bad-got-to-tlv-reference.s
+++ b/lld/test/MachO/invalid/bad-got-to-tlv-reference.s
@@ -2,7 +2,7 @@
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %s -o %t.o
 # RUN: not %lld -o /dev/null %t.o 2>&1 | FileCheck %s -DFILE=%t.o
 
-# CHECK: error: GOT_LOAD relocation requires that variable not be thread-local for `_foo' in [[FILE]]:(__text)
+# CHECK: error: [[FILE]]:(symbol _main+0x3): GOT_LOAD relocation requires that symbol _foo not be thread-local
 
 .text
 .globl _main
diff --git a/lld/test/MachO/invalid/bad-tlv-relocation.s b/lld/test/MachO/invalid/bad-tlv-relocation.s
index 6c3489d0d0ce9..23890131a6828 100644
--- a/lld/test/MachO/invalid/bad-tlv-relocation.s
+++ b/lld/test/MachO/invalid/bad-tlv-relocation.s
@@ -2,7 +2,7 @@
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %s -o %t.o
 # RUN: not %lld -o /dev/null %t.o 2>&1 | FileCheck %s -DFILE=%t.o
 
-# CHECK: TLV relocation requires that variable be thread-local for `_foo' in [[FILE]]:(__text)
+# CHECK: [[FILE]]:(symbol _main+0x3): TLV relocation requires that symbol _foo be thread-local
 
 .text
 .globl _main
diff --git a/lld/test/MachO/invalid/compact-unwind-bad-reloc.s b/lld/test/MachO/invalid/compact-unwind-bad-reloc.s
index b6b6c36ccfac2..61c7a42968375 100644
--- a/lld/test/MachO/invalid/compact-unwind-bad-reloc.s
+++ b/lld/test/MachO/invalid/compact-unwind-bad-reloc.s
@@ -1,10 +1,9 @@
 # REQUIRES: x86
 # RUN: rm -rf %t; split-file %s %t
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin19.0.0 %t/bad-function.s -o %t/bad-function.o
-# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin19.0.0 %t/bad-personality.s -o %t/bad-personality.o
-# RUN: not %lld -lSystem -lc++ %t/bad-function.o -o %t 2>&1 | FileCheck %s -DFILE=%t/bad-function.o
-# RUN: not %lld -lSystem -lc++ %t/bad-personality.o -o %t 2>&1 | FileCheck %s -DFILE=%t/bad-personality.o
-# CHECK: error: compact unwind references address in [[FILE]]:(__data) which is not in segment __TEXT
+# RUN: not %lld -lSystem -dylib -lc++ %t/bad-function.o -o /dev/null 2>&1 | FileCheck %s
+# CHECK: error: {{.*}}bad-function.o:(__compact_unwind+0x0) references section __data which is not in segment __TEXT
+# CHECK: error: {{.*}}bad-function.o:(__compact_unwind+0x20) references section __data which is not in segment __TEXT
 
 #--- bad-function.s
 .data
@@ -15,16 +14,11 @@ _not_a_function:
   retq
   .cfi_endproc
 
-#--- bad-personality.s
-.globl _main, _not_a_function
-.text
-_main:
+_not_a_function_2:
   .cfi_startproc
-  .cfi_personality 155, _my_personality
+  .cfi_personality 155, ___gxx_personality_v0
   .cfi_def_cfa_offset 16
   retq
   .cfi_endproc
 
-.data
-.globl _my_personality
-_my_personality:
+.subsections_via_symbols
diff --git a/lld/test/MachO/invalid/cstring-dedup.s b/lld/test/MachO/invalid/cstring-dedup.s
index 287f7d2156a31..1b73be36eeaca 100644
--- a/lld/test/MachO/invalid/cstring-dedup.s
+++ b/lld/test/MachO/invalid/cstring-dedup.s
@@ -10,7 +10,7 @@
 # RUN: not %lld -dylib --deduplicate-literals %t/not-terminated.o 2>&1 | FileCheck %s --check-prefix=TERM
 # RUN: not %lld -dylib --deduplicate-literals %t/relocs.o 2>&1 | FileCheck %s --check-prefix=RELOCS
 
-# TERM:   not-terminated.o:(__cstring): string is not null terminated
+# TERM:   not-terminated.o:(__cstring+0x4): string is not null terminated
 # RELOCS: relocs.o contains relocations in __TEXT,__cstring, so LLD cannot deduplicate literals. Try re-running without --deduplicate-literals.
 
 #--- not-terminated.s
diff --git a/lld/test/MachO/invalid/duplicate-symbol.s b/lld/test/MachO/invalid/duplicate-symbol.s
index fc9fd7614630d..28495baea5cb7 100644
--- a/lld/test/MachO/invalid/duplicate-symbol.s
+++ b/lld/test/MachO/invalid/duplicate-symbol.s
@@ -1,15 +1,17 @@
 # REQUIRES: x86
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %s -o %t.o
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %s -o %t-dup.o
-# RUN: not %lld -o /dev/null %t-dup.o %t.o 2>&1 | FileCheck %s -DFILE_1=%t-dup.o -DFILE_2=%t.o
-# RUN: not %lld -o /dev/null %t.o %t.o 2>&1 | FileCheck %s -DFILE_1=%t.o -DFILE_2=%t.o
+# RUN: not %lld -dylib -o /dev/null %t-dup.o %t.o 2>&1 | FileCheck %s -DNAME=_ZN1a1bL3fooE -DFILE_1=%t-dup.o -DFILE_2=%t.o
+# RUN: not %lld -dylib -o /dev/null %t.o %t.o 2>&1 | FileCheck %s -DNAME=_ZN1a1bL3fooE -DFILE_1=%t.o -DFILE_2=%t.o
 
-# CHECK:      error: duplicate symbol: _main
+# RUN: not %lld -dylib -demangle -o /dev/null %t-dup.o %t.o 2>&1 | FileCheck %s -DNAME="a::b::foo" -DFILE_1=%t-dup.o -DFILE_2=%t.o
+# RUN: not %lld -dylib -demangle -o /dev/null %t.o %t.o 2>&1 | FileCheck %s -DNAME="a::b::foo" -DFILE_1=%t.o -DFILE_2=%t.o
+
+# CHECK:      error: duplicate symbol: [[NAME]]
 # CHECK-NEXT: >>> defined in [[FILE_1]]
 # CHECK-NEXT: >>> defined in [[FILE_2]]
 
 .text
-.global _main
-_main:
-  mov $0, %rax
+.global _ZN1a1bL3fooE
+_ZN1a1bL3fooE:
   ret
diff --git a/lld/test/MachO/invalid/eh-frame.s b/lld/test/MachO/invalid/eh-frame.s
new file mode 100644
index 0000000000000..0e51975bfa4b8
--- /dev/null
+++ b/lld/test/MachO/invalid/eh-frame.s
@@ -0,0 +1,83 @@
+# REQUIRES: x86
+# RUN: rm -rf %t; split-file %s %t
+
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos10.15 %t/too-small-1.s -o %t/too-small-1.o
+# RUN: not %lld -lSystem -dylib %t/too-small-1.o -o /dev/null 2>&1 | FileCheck %s --check-prefix TOO-SMALL-1
+# TOO-SMALL-1: error: {{.*}}too-small-1.o:(__eh_frame+0x0): CIE/FDE too small
+
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos10.15 %t/too-small-2.s -o %t/too-small-2.o
+# RUN: not %lld -lSystem -dylib %t/too-small-2.o -o /dev/null 2>&1 | FileCheck %s --check-prefix TOO-SMALL-2
+# TOO-SMALL-2: error: {{.*}}too-small-2.o:(__eh_frame+0x0): CIE/FDE extends past the end of the section
+
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos10.15 %t/personality-enc.s -o %t/personality-enc.o
+# RUN: not %lld -lSystem -dylib %t/personality-enc.o -o /dev/null 2>&1 | FileCheck %s --check-prefix PERS-ENC
+# PERS-ENC: error: {{.*}}personality-enc.o:(__eh_frame+0x12): unexpected personality encoding 0xb
+
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos10.15 %t/pointer-enc.s -o %t/pointer-enc.o
+# RUN: not %lld -lSystem -dylib %t/pointer-enc.o -o /dev/null 2>&1 | FileCheck %s --check-prefix PTR-ENC
+# PTR-ENC: error: {{.*}}pointer-enc.o:(__eh_frame+0x11): unexpected pointer encoding 0x12
+
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos10.15 %t/string-err.s -o %t/string-err.o
+# RUN: not %lld -lSystem -dylib %t/string-err.o -o /dev/null 2>&1 | FileCheck %s --check-prefix STR
+# STR: error: {{.*}}string-err.o:(__eh_frame+0x9): corrupted CIE (failed to read string)
+
+#--- too-small-1.s
+.p2align 3
+.section __TEXT,__eh_frame
+.short 0x3
+
+.subsections_via_symbols
+
+#--- too-small-2.s
+.p2align 3
+.section __TEXT,__eh_frame
+.long 0x3  # length
+
+.subsections_via_symbols
+
+#--- personality-enc.s
+.p2align 3
+.section __TEXT,__eh_frame
+
+.long 0x14   # length
+.long 0      # CIE offset
+.byte 1      # version
+.asciz "zPR" # aug string
+.byte 0x01   # code alignment
+.byte 0x78   # data alignment
+.byte 0x10   # return address register
+.byte 0x01   # aug length
+.byte 0x0b   # personality encoding
+.long 0xffff # personality pointer
+.byte 0x10   # pointer encoding
+.space 1     # pad to alignment
+
+.subsections_via_symbols
+
+#--- pointer-enc.s
+.p2align 3
+.section __TEXT,__eh_frame
+
+.long 0x14  # length
+.long 0     # CIE offset
+.byte 1     # version
+.asciz "zR" # aug string
+.byte 0x01  # code alignment
+.byte 0x78  # data alignment
+.byte 0x10  # return address register
+.byte 0x01  # aug length
+.byte 0x12  # pointer encoding
+.space 7    # pad to alignment
+
+.subsections_via_symbols
+
+#--- string-err.s
+.p2align 3
+.section __TEXT,__eh_frame
+
+.long 0x7   # length
+.long 0     # CIE offset
+.byte 1     # version
+.ascii "zR" # invalid aug string
+
+.subsections_via_symbols
diff --git a/lld/test/MachO/invalid/incompatible-arch.s b/lld/test/MachO/invalid/incompatible-arch.s
index 27fc1c83d04be..0fc84c79e8a3e 100644
--- a/lld/test/MachO/invalid/incompatible-arch.s
+++ b/lld/test/MachO/invalid/incompatible-arch.s
@@ -12,8 +12,8 @@
 
 # RUN: %lld -dylib -arch arm64 -platform_version macOS 10.14 10.15 -o %t/out.dylib %t/test.o
 
-# RUN: not %lld -dylib -arch arm64 -platform_version iOS 9.0 11.0 %t/out.dylib \
-# RUN:  -o /dev/null 2>&1 | FileCheck %s --check-prefix=DYLIB-PLAT
+# RUN: not %no-arg-lld -dylib -arch arm64 -platform_version iOS 9.0 11.0 \
+# RUN:  %t/out.dylib -o /dev/null 2>&1 | FileCheck %s --check-prefix=DYLIB-PLAT
 # DYLIB-PLAT: {{.*}}out.dylib has platform macOS, which is different from target platform iOS
 
 # RUN: %lld -lSystem -dylib -arch arm64 -platform_version macOS 10.14.0 10.15.0 %t/out.dylib -o /dev/null
@@ -24,7 +24,7 @@
 
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos10.15.0 %s -o %t/test_x86.o
 
-# RUN: not %lld %t/test_x86.o -lSystem -arch x86_64 -platform_version iOS 10.0 15.0 \
+# RUN: not %no-arg-lld %t/test_x86.o -lSystem -arch x86_64 -platform_version iOS 10.0 15.0 \
 # RUN:  -o /dev/null 2>&1 | FileCheck %s --check-prefix=OBJ-PLAT
 # OBJ-PLAT: {{.*}}test_x86.o has platform macOS, which is different from target platform iOS
 
@@ -38,13 +38,13 @@
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-ios14.0 %s -o %t/test_x86_ios.o
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-ios14.0-simulator %s -o %t/test_x86_ios_sim.o
 
-# RUN: %lld -dylib -platform_version ios-simulator 14.0.0 14.0.0 %t/test_x86_ios.o -o /dev/null
-# RUN: %lld -dylib -platform_version ios 14.0.0 14.0.0 %t/test_x86_ios_sim.o -o /dev/null
+# RUN: %no-arg-lld -dylib -arch x86_64 -platform_version ios-simulator 14.0.0 14.0.0 %t/test_x86_ios.o -o /dev/null
+# RUN: %no-arg-lld -dylib -arch x86_64 -platform_version ios 14.0.0 14.0.0 %t/test_x86_ios_sim.o -o /dev/null
 
-# RUN: not %lld -dylib  -platform_version watchos-simulator 14.0.0 14.0.0 %t/test_x86_ios.o \
+# RUN: not %no-arg-lld -dylib -arch x86_64 -platform_version watchos-simulator 14.0.0 14.0.0 %t/test_x86_ios.o \
 # RUN:	-o /dev/null 2>&1 | FileCheck %s --check-prefix=CROSS-SIM
 # CROSS-SIM: {{.*}}test_x86_ios.o has platform iOS, which is different from target platform watchOS Simulator
-# RUN: not %lld -dylib  -platform_version watchos-simulator 14.0.0 14.0.0 %t/test_x86_ios_sim.o \
+# RUN: not %no-arg-lld -dylib -arch x86_64 -platform_version watchos-simulator 14.0.0 14.0.0 %t/test_x86_ios_sim.o \
 # RUN:	-o /dev/null 2>&1 | FileCheck %s --check-prefix=CROSS-SIM2
 # CROSS-SIM2: {{.*}}test_x86_ios_sim.o has platform iOS Simulator, which is different from target platform watchOS Simulator
 
diff --git a/lld/test/MachO/invalid/incompatible-target-tapi.test b/lld/test/MachO/invalid/incompatible-target-tapi.test
index f99f63c67e78a..052e854d91e55 100644
--- a/lld/test/MachO/invalid/incompatible-target-tapi.test
+++ b/lld/test/MachO/invalid/incompatible-target-tapi.test
@@ -4,7 +4,7 @@ RUN: echo "" | llvm-mc -filetype=obj -triple=x86_64-apple-macosx -o %t/x86_64-te
 RUN: echo "" | llvm-mc -filetype=obj -triple=arm64-apple-iossimulator -o %t/arm64-test.o
 RUN: not %lld -dylib -arch x86_64 %S/Inputs/libincompatible.tbd %t/x86_64-test.o \
 RUN:   -o /dev/null 2>&1 | FileCheck %s --check-prefix=ARCH
-RUN: not %lld -dylib -arch arm64 -platform_version ios-simulator 14.0 15.0 %t/arm64-test.o \
+RUN: not %no-arg-lld -dylib -arch arm64 -platform_version ios-simulator 14.0 15.0 %t/arm64-test.o \
 RUN:   %S/Inputs/libincompatible.tbd -o /dev/null 2>&1 | FileCheck %s --check-prefix=PLATFORM
 ARCH:     error: {{.*}}libincompatible.tbd(/usr/lib/libincompatible.dylib) is incompatible with x86_64 (macOS)
 PLATFORM: error: {{.*}}libincompatible.tbd(/usr/lib/libincompatible.dylib) is incompatible with arm64 (iOS Simulator)
diff --git a/lld/test/MachO/invalid/invalid-stub.s b/lld/test/MachO/invalid/invalid-stub.s
index 546c91a53798b..997594918cd53 100644
--- a/lld/test/MachO/invalid/invalid-stub.s
+++ b/lld/test/MachO/invalid/invalid-stub.s
@@ -1,11 +1,14 @@
 # REQUIRES: x86
-# RUN: mkdir -p %t
+# RUN: mkdir -p %t/invalidYAML.framework
 # RUN: echo "--- !tapi-tbd-v3" > %t/libinvalidYAML.tbd
 # RUN: echo "invalid YAML" >> %t/libinvalidYAML.tbd
+# RUN: cp %t/libinvalidYAML.tbd %t/invalidYAML.framework/invalidYAML.tbd
 # RUN: llvm-mc -filetype obj -triple x86_64-apple-darwin %s -o %t/test.o
 # RUN: not %lld -L%t -linvalidYAML %t/test.o -o %t/test 2>&1 | FileCheck %s -DDIR=%t
+# RUN: not %lld -F%t -framework invalidYAML %t/test.o -o %t/test 2>&1 | FileCheck %s -DDIR=%t --check-prefix=CHECK-FRAMEWORK
 
 # CHECK: could not load TAPI file at [[DIR]]{{[\\/]}}libinvalidYAML.tbd: malformed file
+# CHECK-FRAMEWORK: could not load TAPI file at [[DIR]]{{[\\/]}}invalidYAML.framework{{[\\/]}}invalidYAML.tbd: malformed file
 
 .globl _main
 _main:
diff --git a/lld/test/MachO/invalid/range-check.s b/lld/test/MachO/invalid/range-check.s
index c25d367dd1184..1ad719cfa31d2 100644
--- a/lld/test/MachO/invalid/range-check.s
+++ b/lld/test/MachO/invalid/range-check.s
@@ -6,11 +6,11 @@
 # RUN: %lld -dylib %t/bar.o -o %t/libbar.dylib
 # RUN: not %lld -lSystem -o /dev/null %t/libbar.dylib %t/test.o 2>&1 | FileCheck %s
 
-# CHECK: error: relocation UNSIGNED is out of range: [[#]] is not in [0, 4294967295]; references _foo
-# CHECK: error: relocation GOT_LOAD is out of range: [[#]] is not in [-2147483648, 2147483647]; references _foo
-# CHECK: error: stub is out of range: [[#]] is not in [-2147483648, 2147483647]; references _bar
-# CHECK: error: stub helper header is out of range: [[#]] is not in [-2147483648, 2147483647]
-# CHECK: error: stub helper header is out of range: [[#]] is not in [-2147483648, 2147483647]
+# CHECK-DAG: error: {{.*}}test.o:(symbol _main+0xd): relocation UNSIGNED is out of range: [[#]] is not in [0, 4294967295]; references _foo
+# CHECK-DAG: error: {{.*}}test.o:(symbol _main+0x3): relocation GOT_LOAD is out of range: [[#]] is not in [-2147483648, 2147483647]; references _foo
+# CHECK-DAG: error: stub is out of range: [[#]] is not in [-2147483648, 2147483647]; references _bar
+# CHECK-DAG: error: stub helper header is out of range: [[#]] is not in [-2147483648, 2147483647]
+# CHECK-DAG: error: stub helper header is out of range: [[#]] is not in [-2147483648, 2147483647]
 
 #--- bar.s
 .globl _bar
diff --git a/lld/test/MachO/lc-build-version.s b/lld/test/MachO/lc-build-version.s
index d7bd8be26f4b3..3fc9ba24b3111 100644
--- a/lld/test/MachO/lc-build-version.s
+++ b/lld/test/MachO/lc-build-version.s
@@ -22,44 +22,44 @@
 # MACOS_10_13-NEXT: version 10.13
 # MACOS_10_13-NEXT: sdk 10.15
 
-# RUN: %lld -platform_version ios 12.0 10.15 -o %t.ios_12_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version ios 12.0 10.15 -o %t.ios_12_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.ios_12_0 | FileCheck %s --check-prefix=IOS_12_0
-# RUN: %lld -platform_version ios-simulator 13.0 10.15 -o %t.ios_sim_13_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version ios-simulator 13.0 10.15 -o %t.ios_sim_13_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.ios_sim_13_0 | FileCheck %s --check-prefix=IOS_12_0
 
 # IOS_12_0: cmd LC_BUILD_VERSION
 
-# RUN: %lld -platform_version ios 11.0 10.15 -o %t.ios_11_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version ios 11.0 10.15 -o %t.ios_11_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.ios_11_0 | FileCheck %s --check-prefix=IOS_11_0
-# RUN: %lld -platform_version ios-simulator 12.0 10.15 -o %t.ios_sim_12_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version ios-simulator 12.0 10.15 -o %t.ios_sim_12_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.ios_sim_12_0 | FileCheck %s --check-prefix=IOS_11_0
 
 # IOS_11_0: cmd LC_VERSION_MIN_IPHONEOS
 
-# RUN: %lld -platform_version tvos 12.0 10.15 -o %t.tvos_12_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version tvos 12.0 10.15 -o %t.tvos_12_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.tvos_12_0 | FileCheck %s --check-prefix=TVOS_12_0
-# RUN: %lld -platform_version tvos-simulator 13.0 10.15 -o %t.tvos_sim_13_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version tvos-simulator 13.0 10.15 -o %t.tvos_sim_13_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.tvos_sim_13_0 | FileCheck %s --check-prefix=TVOS_12_0
 
 # TVOS_12_0: cmd LC_BUILD_VERSION
 
-# RUN: %lld -platform_version tvos 11.0 10.15 -o %t.tvos_11_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version tvos 11.0 10.15 -o %t.tvos_11_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.tvos_11_0 | FileCheck %s --check-prefix=TVOS_11_0
-# RUN: %lld -platform_version tvos-simulator 12.0 10.15 -o %t.tvos_sim_12_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version tvos-simulator 12.0 10.15 -o %t.tvos_sim_12_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.tvos_sim_12_0 | FileCheck %s --check-prefix=TVOS_11_0
 
 # TVOS_11_0: cmd LC_VERSION_MIN_TVOS
 
-# RUN: %lld -platform_version watchos 5.0 10.15 -o %t.watchos_5_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version watchos 5.0 10.15 -o %t.watchos_5_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.watchos_5_0 | FileCheck %s --check-prefix=WATCHOS_5_0
-# RUN: %lld -platform_version watchos-simulator 6.0 10.15 -o %t.watchos_sim_6_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version watchos-simulator 6.0 10.15 -o %t.watchos_sim_6_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.watchos_sim_6_0 | FileCheck %s --check-prefix=WATCHOS_5_0
 
 # WATCHOS_5_0: cmd LC_BUILD_VERSION
 
-# RUN: %lld -platform_version watchos 4.0 10.15 -o %t.watchos_4_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version watchos 4.0 10.15 -o %t.watchos_4_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.watchos_4_0 | FileCheck %s --check-prefix=WATCHOS_4_0
-# RUN: %lld -platform_version watchos-simulator 5.0 10.15 -o %t.watchos_sim_5_0 %t.o
+# RUN: %no-arg-lld -arch x86_64 -platform_version watchos-simulator 5.0 10.15 -o %t.watchos_sim_5_0 %t.o
 # RUN: llvm-objdump --macho --all-headers %t.watchos_sim_5_0 | FileCheck %s --check-prefix=WATCHOS_4_0
 
 # WATCHOS_4_0: cmd LC_VERSION_MIN_WATCHOS
diff --git a/lld/test/MachO/lc-dyld-exports-trie.yaml b/lld/test/MachO/lc-dyld-exports-trie.yaml
new file mode 100644
index 0000000000000..224bc5207446a
--- /dev/null
+++ b/lld/test/MachO/lc-dyld-exports-trie.yaml
@@ -0,0 +1,140 @@
+# REQUIRES: x86
+# RUN: rm -rf %t; split-file %s %t
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos -o %t/obj.o %t/obj.s
+# RUN: yaml2obj %t/dylib.yaml -o %t/libdylib.dylib
+# RUN: %lld -platform_version macos 12.0.0 12.0.0 -lSystem %t/obj.o %t/libdylib.dylib -o /dev/null
+
+#--- obj.s
+  .globl _main
+_main:
+  call _foo
+
+#--- dylib.yaml
+## This yaml is from a dylib produced by ld64
+##   echo ".global _foo\n_foo" > dylib.s
+##   clang -target=x86_64-apple-macos12 -dynamiclib -isysroot Inputs/MacOSX.sdk dylib.s -o libdylib.dylib
+##   obj2yaml --raw-segment=data libdylib.dylib
+--- !mach-o
+FileHeader:
+  magic:           0xFEEDFACF
+  cputype:         0x1000007
+  cpusubtype:      0x3
+  filetype:        0x6
+  ncmds:           13
+  sizeofcmds:      568
+  flags:           0x100085
+  reserved:        0x0
+LoadCommands:
+  - cmd:             LC_SEGMENT_64
+    cmdsize:         152
+    segname:         __TEXT
+    vmaddr:          0
+    vmsize:          16384
+    fileoff:         0
+    filesize:        16384
+    maxprot:         5
+    initprot:        5
+    nsects:          1
+    flags:           0
+    Sections:
+      - sectname:        __text
+        segname:         __TEXT
+        addr:            0x4000
+        size:            0
+        offset:          0x4000
+        align:           0
+        reloff:          0x0
+        nreloc:          0
+        flags:           0x80000400
+        reserved1:       0x0
+        reserved2:       0x0
+        reserved3:       0x0
+        content:         ''
+  - cmd:             LC_SEGMENT_64
+    cmdsize:         72
+    segname:         __LINKEDIT
+    vmaddr:          16384
+    vmsize:          16384
+    fileoff:         16384
+    filesize:        96
+    maxprot:         1
+    initprot:        1
+    nsects:          0
+    flags:           0
+  - cmd:             LC_ID_DYLIB
+    cmdsize:         48
+    dylib:
+      name:            24
+      timestamp:       1
+      current_version: 0
+      compatibility_version: 0
+    Content:         libdylib.dylib
+    ZeroPadBytes:    3
+  - cmd:             LC_DYLD_CHAINED_FIXUPS
+    cmdsize:         16
+    dataoff:         16384
+    datasize:        48
+  - cmd:             LC_DYLD_EXPORTS_TRIE
+    cmdsize:         16
+    dataoff:         16432
+    datasize:        16
+  - cmd:             LC_SYMTAB
+    cmdsize:         24
+    symoff:          16456
+    nsyms:           1
+    stroff:          16472
+    strsize:         8
+  - cmd:             LC_DYSYMTAB
+    cmdsize:         80
+    ilocalsym:       0
+    nlocalsym:       0
+    iextdefsym:      0
+    nextdefsym:      1
+    iundefsym:       1
+    nundefsym:       0
+    tocoff:          0
+    ntoc:            0
+    modtaboff:       0
+    nmodtab:         0
+    extrefsymoff:    0
+    nextrefsyms:     0
+    indirectsymoff:  0
+    nindirectsyms:   0
+    extreloff:       0
+    nextrel:         0
+    locreloff:       0
+    nlocrel:         0
+  - cmd:             LC_UUID
+    cmdsize:         24
+    uuid:            52409B91-DF59-346A-A63F-D4E6FFDC3E04
+  - cmd:             LC_BUILD_VERSION
+    cmdsize:         32
+    platform:        1
+    minos:           786432
+    sdk:             851968
+    ntools:          1
+    Tools:
+      - tool:            3
+        version:         53674242
+  - cmd:             LC_SOURCE_VERSION
+    cmdsize:         16
+    version:         0
+  - cmd:             LC_LOAD_DYLIB
+    cmdsize:         56
+    dylib:
+      name:            24
+      timestamp:       2
+      current_version: 65793
+      compatibility_version: 65536
+    Content:         '/usr/lib/libSystem.dylib'
+    ZeroPadBytes:    8
+  - cmd:             LC_FUNCTION_STARTS
+    cmdsize:         16
+    dataoff:         16448
+    datasize:        8
+  - cmd:             LC_DATA_IN_CODE
+    cmdsize:         16
+    dataoff:         16456
+    datasize:        0
+__LINKEDIT:      00000000200000002C0000002C000000000000000100000000000000000000000200000000000000000000000000000000015F666F6F000804008080010000000000000000000000020000000F010000004000000000000020005F666F6F0000
+...
diff --git a/lld/test/MachO/lc-linker-option.ll b/lld/test/MachO/lc-linker-option.ll
index ea56226fb6be4..1bee13781176a 100644
--- a/lld/test/MachO/lc-linker-option.ll
+++ b/lld/test/MachO/lc-linker-option.ll
@@ -77,6 +77,21 @@
 ; SYMS-NEXT:  g     F __TEXT,__text __mh_execute_header
 ; SYMS-EMPTY:
 
+;; Make sure that frameworks containing object files or bitcode instead of
+;; dylibs or archives do not cause duplicate symbol errors
+; RUN: mkdir -p %t/Foo.framework
+; RUN: llc --filetype=obj %t/foo.ll -o %t/Foo.framework/Foo
+; RUN: llc --filetype=obj %t/load-framework-twice.ll -o %t/main
+;; Order of the object with the LC_LINKER_OPTION vs -framework arg is important.
+; RUN: %lld %t/main -F %t -framework Foo -framework Foo -o /dev/null
+; RUN: %lld -F %t -framework Foo -framework Foo %t/main -o /dev/null
+
+; RUN: llvm-as %t/foo.ll -o %t/Foo.framework/Foo
+; RUN: llvm-as %t/load-framework-twice.ll -o %t/main
+;; Order of the object with the LC_LINKER_OPTION vs -framework arg is important.
+; RUN: %lld %t/main -F %t -framework Foo -framework Foo -o /dev/null
+; RUN: %lld -F %t -framework Foo -framework Foo %t/main -o /dev/null
+
 ;--- framework.ll
 target triple = "x86_64-apple-macosx10.15.0"
 target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
@@ -127,6 +142,17 @@ target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16
 !0 = !{!"-framework", !"Foo"}
 !llvm.linker.options = !{!0}
 
+;--- load-framework-twice.ll
+target triple = "x86_64-apple-macosx10.15.0"
+target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+
+!0 = !{!"-framework", !"Foo"}
+!llvm.linker.options = !{!0, !0}
+
+define void @main() {
+  ret void
+}
+
 ;--- load-library-foo.ll
 target triple = "x86_64-apple-macosx10.15.0"
 target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
diff --git a/lld/test/MachO/lit.local.cfg b/lld/test/MachO/lit.local.cfg
index a45fbaee7f6e0..984c5e5fc4f61 100644
--- a/lld/test/MachO/lit.local.cfg
+++ b/lld/test/MachO/lit.local.cfg
@@ -10,9 +10,10 @@ import os
 # flag will append to the set of library roots. As such, we define a separate
 # alias for each platform.
 
-config.substitutions.append(('%lld-watchos',
-    'ld64.lld -fatal_warnings -arch arm64_32 -platform_version watchos 7.0 8.0 -syslibroot ' +
-    os.path.join(config.test_source_root, "MachO", "Inputs", "WatchOS.sdk")))
+lld_watchos = ('ld64.lld -arch arm64_32 -platform_version watchos 7.0 8.0 -syslibroot ' +
+    os.path.join(config.test_source_root, "MachO", "Inputs", "WatchOS.sdk"))
+config.substitutions.append(('%lld-watchos', lld_watchos + ' -fatal_warnings'))
+config.substitutions.append(('%no_fatal_warnings_lld-watchos', lld_watchos))
 
 # Since most of our tests are written around x86_64, we give this platform the
 # shortest substitution of "%lld".
diff --git a/lld/test/MachO/local-symbol-output.s b/lld/test/MachO/local-symbol-output.s
new file mode 100644
index 0000000000000..3fd9458c00a54
--- /dev/null
+++ b/lld/test/MachO/local-symbol-output.s
@@ -0,0 +1,141 @@
+# REQUIRES: x86
+
+# RUN: rm -rf %t; split-file %s %t
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos %t/main.s -o %t/main.o
+
+## Check that -non_global_symbols_no_strip_list and -non_global_symbols_strip_list
+## can't be used at the same time.
+# RUN: not %lld %t/main.o -o /dev/null \
+# RUN:       -non_global_symbols_no_strip_list %t/foo.txt \
+# RUN:       -non_global_symbols_strip_list %t/foo.txt 2>&1 | \
+# RUN:     FileCheck --check-prefix=CONFLICT %s
+
+# CONFLICT: error: cannot use both -non_global_symbols_no_strip_list and -non_global_symbols_strip_list
+
+## Check that -x causes none of the local symbols to be emitted.
+# RUN: %lld %t/main.o -x -o %t/no_local.out
+# RUN: llvm-nm %t/no_local.out | FileCheck --check-prefix NO_LOCAL %s
+
+# NO_LOCAL-NOT: t _foo
+# NO_LOCAL-NOT: t _bar
+# NO_LOCAL-NOT: t _baz
+# NO_LOCAL: T _main
+
+## Check that when using -x with -non_global_symbols_no_strip_list, whichever appears
+## last in the command line arg list will take precedence.
+# RUN: %lld %t/main.o -x -non_global_symbols_no_strip_list %t/foo.txt -o %t/x_then_no_strip.out
+# RUN: llvm-nm %t/x_then_no_strip.out | FileCheck --check-prefix X-NO-STRIP %s
+
+# RUN: %lld %t/main.o -non_global_symbols_no_strip_list %t/foo.txt -x -o %t/no_strip_then_x.out
+# RUN: llvm-nm %t/no_strip_then_x.out | FileCheck --check-prefix NO_LOCAL %s
+
+# X-NO-STRIP-NOT: t _bar
+# X-NO-STRIP-DAG: t _foo
+# X-NO-STRIP-DAG: T _main
+
+## Check that -non_global_symbols_no_strip_list can be specified more than once
+## (The final no-strip list is the union of all these)
+# RUN: %lld %t/main.o -o %t/no_strip_multi.out \
+# RUN:    -non_global_symbols_no_strip_list %t/foo.txt \
+# RUN:    -non_global_symbols_no_strip_list %t/bar.txt
+# RUN: llvm-nm %t/no_strip_multi.out | FileCheck --check-prefix NO-STRIP-MULTI %s
+
+# NO-STRIP-MULTI-NOT: t _baz
+# NO-STRIP-MULTI-DAG: t _foo
+# NO-STRIP-MULTI-DAG: t _bar
+# NO-STRIP-MULTI-DAG: T _main
+
+## Check that when using -x with -non_global_symbols_strip_list, whichever appears
+## last in the command line arg list will take precedence.
+# RUN: %lld %t/main.o -x -non_global_symbols_strip_list %t/foo.txt -o %t/x_then_strip.out
+# RUN: llvm-nm %t/x_then_strip.out | FileCheck --check-prefix X-STRIP %s
+
+# RUN: %lld %t/main.o -non_global_symbols_strip_list %t/foo.txt -x -o %t/strip_then_x.out
+# RUN: llvm-nm %t/no_strip_then_x.out | FileCheck --check-prefix NO_LOCAL %s
+
+# X-STRIP-NOT: t _foo
+# X-STRIP-DAG: t _bar
+# X-STRIP-DAG: t _baz
+# X-STRIP-DAG: T _main
+
+## Check that -non_global_symbols_strip_list can be specified more than once
+## (The final strip list is the union of all these)
+# RUN: %lld %t/main.o -o %t/strip_multi.out \
+# RUN:    -non_global_symbols_strip_list %t/foo.txt \
+# RUN:    -non_global_symbols_strip_list %t/bar.txt
+# RUN: llvm-nm %t/strip_multi.out | FileCheck --check-prefix STRIP-MULTI %s
+
+# STRIP-MULTI-NOT: t _foo
+# STRIP-MULTI-NOT: t _bar
+# STRIP-MULTI-DAG: t _baz
+# STRIP-MULTI-DAG: T _main
+
+## Test interactions with exported_symbol.
+# RUN: %lld %t/main.o -o %t/strip_all_export_one.out \
+# RUN:    -x -exported_symbol _foo \
+# RUN:    -undefined dynamic_lookup
+# RUN: llvm-nm %t/strip_all_export_one.out | FileCheck --check-prefix STRIP-EXP %s
+
+# STRIP-EXP: U _foo
+# STRIP-EXP-EMPTY:
+
+## Test interactions of -x and -non_global_symbols_strip_list with unexported_symbol.
+# RUN: %lld %t/main.o -o %t/strip_x_unexport_one.out \
+# RUN:    -x -unexported_symbol _globby \
+# RUN:    -undefined dynamic_lookup
+
+# RUN: %lld %t/main.o -o %t/strip_all_unexport_one.out \
+# RUN:    -non_global_symbols_strip_list %t/globby.txt \
+# RUN:    -non_global_symbols_strip_list %t/foo.txt \
+# RUN:    -non_global_symbols_strip_list %t/bar.txt \
+# RUN:    -unexported_symbol _globby \
+# RUN:    -undefined dynamic_lookup
+
+# RUN: llvm-nm %t/strip_x_unexport_one.out | FileCheck --check-prefix STRIP-UNEXP %s
+# RUN: llvm-nm %t/strip_all_unexport_one.out | FileCheck --check-prefix STRIP-UNEXP %s
+
+## -unexported_symbol made _globby a local, therefore it should be stripped by -x too
+# STRIP-UNEXP: T __mh_execute_header
+# STRIP-UNEXP-DAG: T _main
+# STRIP-UNEXP-EMPTY:
+
+## Test interactions of -non_global_symbols_strip_list and unexported_symbol.
+# RUN: %lld %t/main.o -undefined dynamic_lookup -o %t/no_strip_unexport.out \
+# RUN:    -non_global_symbols_no_strip_list %t/globby.txt \
+# RUN:    -unexported_symbol _globby
+
+# RUN: llvm-nm %t/no_strip_unexport.out | FileCheck --check-prefix NOSTRIP-UNEXP %s
+
+# NOSTRIP-UNEXP: T __mh_execute_header
+# NOSTRIP-UNEXP-DAG: T _main
+# NOSTRIP-UNEXP-DAG: t _globby
+# NOSTRIP-UNEXP-EMPTY:
+
+#--- foo.txt
+_foo
+
+#--- bar.txt
+_bar
+
+#--- globby.txt
+_globby
+
+#--- main.s
+.globl _main
+.globl _globby
+
+_foo:
+  ret
+
+_bar:
+  ret
+
+_baz:
+  ret
+
+_main:
+  callq _foo
+  ret
+
+ _globby:
+  ret
\ No newline at end of file
diff --git a/lld/test/MachO/lto-final-definition.ll b/lld/test/MachO/lto-final-definition.ll
new file mode 100644
index 0000000000000..e0feb43211344
--- /dev/null
+++ b/lld/test/MachO/lto-final-definition.ll
@@ -0,0 +1,27 @@
+; REQUIRES: x86
+; RUN: rm -rf %t; mkdir %t
+; RUN: llvm-as %s -o %t/test.o
+; RUN: %lld -lSystem -dylib %t/test.o -o %t/test -save-temps
+; RUN: llvm-dis %t/test.0.2.internalize.bc -o - | FileCheck %s
+; RUN: %lld -lSystem -dylib %t/test.o -o %t/flat-namespace.dylib -save-temps \
+; RUN:   -flat_namespace
+; RUN: llvm-dis %t/flat-namespace.dylib.0.2.internalize.bc -o - | FileCheck %s \
+; RUN:   --check-prefix=NO-DSO-LOCAL
+
+;; f() is never dso_local since it is a weak external.
+; CHECK:        define weak_odr void @f()
+; CHECK:        define dso_local void @main()
+
+; NO-DSO-LOCAL: define weak_odr void @f()
+; NO-DSO-LOCAL: define void @main()
+
+target triple = "x86_64-apple-macosx10.15.0"
+target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+
+define weak_odr void @f() {
+  ret void
+}
+
+define void @main() {
+  ret void
+}
diff --git a/lld/test/MachO/lto-internalize-unnamed-addr.ll b/lld/test/MachO/lto-internalize-unnamed-addr.ll
new file mode 100644
index 0000000000000..e0622d691cdc4
--- /dev/null
+++ b/lld/test/MachO/lto-internalize-unnamed-addr.ll
@@ -0,0 +1,75 @@
+; REQUIRES: x86
+; RUN: rm -rf %t; split-file %s %t
+;; This test covers both FullLTO and ThinLTO code paths because we have observed
+;; (unexpected) differences between the two.
+; RUN: llvm-as %t/test.ll -o %t/test.o
+; RUN: llvm-as %t/test2.ll -o %t/test2.o
+; RUN: opt -module-summary %t/test.ll -o %t/test.thinlto.o
+; RUN: opt -module-summary %t/test2.ll -o %t/test2.thinlto.o
+
+; RUN: %lld -lSystem %t/test.o %t/test2.o -o %t/test
+; RUN: llvm-nm -m %t/test | FileCheck %s --check-prefix=LTO
+
+; RUN: %lld -lSystem -dylib %t/test.o %t/test2.o -o %t/test.dylib
+; RUN: llvm-nm -m %t/test.dylib | FileCheck %s --check-prefix=LTO-DYLIB
+
+; RUN: %lld -lSystem %t/test.thinlto.o %t/test2.o -o %t/test.thinlto
+; RUN: llvm-nm -m %t/test.thinlto | FileCheck %s --check-prefix=THINLTO
+
+; RUN: %lld -lSystem -dylib %t/test.thinlto.o %t/test2.o -o %t/test.thinlto.dylib
+; RUN: llvm-nm -m %t/test.thinlto.dylib | FileCheck %s --check-prefix=THINLTO
+
+; LTO-DAG: (__DATA,__data) non-external _global_unnamed
+; LTO-DAG: (__DATA,__data) non-external _local_unnamed
+;; LD64 marks this with (was a private external). IMO both LD64 and LLD should
+;; mark all the other internalized symbols with (was a private external).
+; LTO-DAG: (__TEXT,__const) non-external _local_unnamed_always_const
+; LTO-DAG: (__TEXT,__const) non-external _local_unnamed_const
+;; LD64 doesn't internalize this -- it emits it as a weak external -- which I
+;; think is a missed optimization on its end.
+; LTO-DAG: (__TEXT,__const) non-external _local_unnamed_sometimes_const
+
+;; The output here is largely identical to LD64's, except that the non-external
+;; symbols here are all marked as (was a private external) by LD64. LLD should
+;; follow suit.
+; LTO-DYLIB-DAG: (__DATA,__data) non-external _global_unnamed
+; LTO-DYLIB-DAG: (__DATA,__data) weak external _local_unnamed
+; LTO-DYLIB-DAG: (__TEXT,__const) non-external _local_unnamed_always_const
+; LTO-DYLIB-DAG: (__TEXT,__const) non-external _local_unnamed_const
+; LTO-DYLIB-DAG: (__TEXT,__const) weak external _local_unnamed_sometimes_const
+
+; THINLTO-DAG: (__DATA,__data) non-external (was a private external) _global_unnamed
+; THINLTO-DAG: (__DATA,__data) weak external _local_unnamed
+;; The next two symbols are rendered as non-external (was a private external)
+;; by LD64. This is a missed optimization on LLD's end.
+; THINLTO-DAG: (__TEXT,__const) weak external _local_unnamed_always_const
+; THINLTO-DAG: (__TEXT,__const) weak external _local_unnamed_const
+;; LD64 actually fails to link when the following symbol is included in the test
+;; input, instead producing this error:
+;; reference to bitcode symbol '_local_unnamed_sometimes_const' which LTO has not compiled in '_used' from /tmp/lto.o for architecture x86_64
+; THINLTO-DAG: (__TEXT,__const) weak external _local_unnamed_sometimes_const
+
+;--- test.ll
+target triple = "x86_64-apple-darwin"
+target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+
+@global_unnamed = linkonce_odr unnamed_addr global i8 42
+@local_unnamed_const = linkonce_odr local_unnamed_addr constant i8 42
+@local_unnamed_always_const = linkonce_odr local_unnamed_addr constant i8 42
+@local_unnamed_sometimes_const = linkonce_odr local_unnamed_addr constant i8 42
+@local_unnamed = linkonce_odr local_unnamed_addr global i8 42
+@used = hidden constant [5 x i8*] [i8* @global_unnamed, i8* @local_unnamed,
+  i8* @local_unnamed_const, i8* @local_unnamed_always_const,
+  i8* @local_unnamed_sometimes_const]
+@llvm.used = appending global [1 x [5 x i8*]*] [[5 x i8*]* @used]
+
+define void @main() {
+  ret void
+}
+
+;--- test2.ll
+target triple = "x86_64-apple-darwin"
+target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+
+@local_unnamed_always_const = linkonce_odr local_unnamed_addr constant i8 42
+@local_unnamed_sometimes_const = linkonce_odr local_unnamed_addr global i8 42
diff --git a/lld/test/MachO/lto-internalize.ll b/lld/test/MachO/lto-internalize.ll
index c9bac63b730b9..75962aec96d3f 100644
--- a/lld/test/MachO/lto-internalize.ll
+++ b/lld/test/MachO/lto-internalize.ll
@@ -12,9 +12,12 @@
 ; RUN: llvm-dis < %t/test.0.2.internalize.bc | FileCheck %s
 ; RUN: llvm-objdump --macho --syms %t/test | FileCheck %s --check-prefix=SYMTAB
 
+; CHECK: @comm = internal global
+; CHECK: @comm_hide = internal global
+
 ;; Check that main is not internalized. This covers the case of bitcode symbols
 ;; referenced by undefined symbols that don't belong to any InputFile.
-; CHECK: define void @main()
+; CHECK: define dso_local void @main()
 
 ;; Check that the foo and bar functions are correctly internalized.
 ; CHECK: define internal void @bar()
@@ -22,24 +25,54 @@
 
 ;; Check that a bitcode symbol that is referenced by a regular object file isn't
 ;; internalized.
-; CHECK: define void @used_in_regular_obj()
+; CHECK: define dso_local void @used_in_regular_obj()
 
 ;; Check that a bitcode symbol that is defined in another bitcode file gets
 ;; internalized.
 ; CHECK: define internal void @baz()
 
-; Check foo and bar are not emitted to the .symtab
+;; Check that all internalized symbols are not emitted to the symtab
 ; SYMTAB-LABEL: SYMBOL TABLE:
-; SYMTAB-NEXT:  g     F __TEXT,__text _main
-; SYMTAB-NEXT:  g     F __TEXT,__text _used_in_regular_obj
-; SYMTAB-NEXT:  g     F __TEXT,__text __mh_execute_header
-; SYMTAB-NEXT:          *UND* dyld_stub_binder
+; SYMTAB-DAG:   g     F __TEXT,__text _main
+; SYMTAB-DAG:   g     F __TEXT,__text _used_in_regular_obj
+; SYMTAB-DAG:   g     F __TEXT,__text __mh_execute_header
+; SYMTAB-DAG:           *UND* dyld_stub_binder
 ; SYMTAB-EMPTY:
 
+; RUN: %lld -lSystem -dylib %t/test.o %t/baz.o %t/regular.o -o %t/test.dylib -save-temps
+; RUN: llvm-dis < %t/test.dylib.0.2.internalize.bc | FileCheck %s --check-prefix=DYN
+; RUN: llvm-nm -m %t/test.dylib | FileCheck %s --check-prefix=DYN-SYMS \
+; RUN:   --implicit-check-not _foo
+
+; RUN: %lld -lSystem -export_dynamic %t/test.o %t/baz.o %t/regular.o -o %t/test.extdyn -save-temps
+; RUN: llvm-dis < %t/test.extdyn.0.2.internalize.bc
+; RUN: llvm-nm -m %t/test.extdyn | FileCheck %s --check-prefix=DYN-SYMS \
+; RUN:   --implicit-check-not _foo
+
+;; Note that only foo() gets internalized here; everything else that isn't
+;; hidden must be exported.
+; DYN: @comm = common dso_local global
+; DYN: @comm_hide = internal global
+; DYN: define dso_local void @main()
+; DYN: define dso_local void @bar()
+; DYN: define internal void @foo()
+; DYN: define dso_local void @used_in_regular_obj()
+; DYN: define dso_local void @baz()
+
+; DYN-SYMS-DAG: (__TEXT,__text) external _bar
+; DYN-SYMS-DAG: (__TEXT,__text) external _baz
+; DYN-SYMS-DAG: (__DATA,__common) external _comm
+; DYN-SYMS-DAG: (__TEXT,__text) external _main
+; DYN-SYMS-DAG: (__TEXT,__text) external _used_in_regular_obj
+
 ;--- test.s
 target triple = "x86_64-apple-macosx10.15.0"
 target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
 
+;; Common symbols are always external.
+@comm = common global i8 0, align 1
+@comm_hide = common hidden global i8 0, align 1
+
 declare void @baz()
 
 define void @main() {
diff --git a/lld/test/MachO/map-file.s b/lld/test/MachO/map-file.s
index 85c23e763e9ef..aa0bc6a8caf1b 100644
--- a/lld/test/MachO/map-file.s
+++ b/lld/test/MachO/map-file.s
@@ -2,6 +2,7 @@
 # RUN: rm -rf %t; split-file %s %t
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/foo.s -o %t/foo.o
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/test.s -o %t/test.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/c-string-literal.s -o %t/c-string-literal.o
 
 # RUN: %lld -map %t/map %t/test.o %t/foo.o --time-trace -o %t/test-map
 # RUN: llvm-objdump --syms --section-headers %t/test-map > %t/objdump
@@ -51,4 +52,42 @@ _main:
 # CHECK-NEXT: 0x[[#FOO]]       [  2]  _foo
 # CHECK-NEXT: 0x[[#NUMBER]]    [  1]  _number
 
+#--- c-string-literal.s
+.section __TEXT,__cstring
+.globl _hello_world, _hello_its_me, _main
+
+_hello_world:
+.asciz "Hello world!\n"
+
+_hello_its_me:
+.asciz "Hello, it's me"
+
+.text
+_main:
+  movl $0x2000004, %eax # write() syscall
+  mov $1, %rdi # stdout
+  leaq _hello_world(%rip), %rsi
+  mov $13, %rdx # length of str
+  syscall
+  ret
+
+# RUN: %lld -map %t/c-string-literal-map %t/c-string-literal.o -o %t/c-string-literal-out
+# RUN: FileCheck --check-prefix=CSTRING %s < %t/c-string-literal-map
+
+## C-string literals should be printed as "literal string: <C string literal>"
+# CSTRING-LABEL: Symbols:
+# CSTRING-DAG: _main
+# CSTRING-DAG: literal string: Hello world!\n
+# CSTRING-DAG: literal string: Hello, it's me
+
+# RUN: %lld -dead_strip -map %t/dead-c-string-literal-map %t/c-string-literal.o -o %t/dead-c-string-literal-out
+# RUN: FileCheck --check-prefix=DEADCSTRING %s < %t/dead-c-string-literal-map
+
+## C-string literals should be printed as "literal string: <C string literal>"
+# DEADCSTRING-LABEL: Symbols:
+# DEADCSTRING-DAG: _main
+# DEADCSTRING-DAG: literal string: Hello world!\n
+# DEADCSTRING-LABEL: Dead Stripped Symbols:
+# DEADCSTRING-DAG: literal string: Hello, it's me
+
 # MAPFILE: "name":"Total Write map file"
diff --git a/lld/test/MachO/obj-file-with-stabs.s b/lld/test/MachO/obj-file-with-stabs.s
index 134a748a7ec2a..fd558e8f3e8cc 100644
--- a/lld/test/MachO/obj-file-with-stabs.s
+++ b/lld/test/MachO/obj-file-with-stabs.s
@@ -1,27 +1,33 @@
 # REQUIRES: x86
-## FIXME: This yaml is from an object file produced with 'ld -r'
-##        Replace this with "normal" .s test format once lld supports `-r`
+## FIXME: This yaml is from an object file produced with 'ld -r':
+##
+##   echo "int main() {return 1;}" > test.c
+##   clang -c -g -o test.o test.c
+##   ld -r -o test2.o test.o -no_data_in_code_info
+##
+## Replace this with "normal" .s test format once lld supports `-r`
 
 # RUN: yaml2obj %s -o %t.o
-# RUN: %lld -lSystem -platform_version macos 11.3 11.0 -arch x86_64 %t.o -o %t
+# RUN: %lld -lSystem -arch x86_64 %t.o -o %t
+
 --- !mach-o
 FileHeader:
   magic:           0xFEEDFACF
-  cputype:         0x01000007
-  cpusubtype:      0x00000003
-  filetype:        0x00000001
-  ncmds:           2
-  sizeofcmds:      384
-  flags:           0x00002000
-  reserved:        0x00000000
+  cputype:         0x1000007
+  cpusubtype:      0x3
+  filetype:        0x1
+  ncmds:           3
+  sizeofcmds:      288
+  flags:           0x2000
+  reserved:        0x0
 LoadCommands:
   - cmd:             LC_SEGMENT_64
-    cmdsize:         312
+    cmdsize:         232
     segname:         ''
     vmaddr:          0
-    vmsize:          120
-    fileoff:         448
-    filesize:        120
+    vmsize:          56
+    fileoff:         352
+    filesize:        56
     maxprot:         7
     initprot:        7
     nsects:          2
@@ -29,57 +35,33 @@ LoadCommands:
     Sections:
       - sectname:        __text
         segname:         __TEXT
-        addr:            0x0000000000000000
+        addr:            0x0
         size:            18
-        offset:          0x000001C0
+        offset:          0x160
         align:           4
-        reloff:          0x00000000
+        reloff:          0x0
         nreloc:          0
         flags:           0x80000400
-        reserved1:       0x00000000
-        reserved2:       0x00000000
-        reserved3:       0x00000000
+        reserved1:       0x0
+        reserved2:       0x0
+        reserved3:       0x0
         content:         554889E5C745FC00000000B8010000005DC3
-      - sectname:        __eh_frame
-        segname:         __TEXT
-        addr:            0x0000000000000018
-        size:            64
-        offset:          0x000001D8
+      - sectname:        __compact_unwind
+        segname:         __LD
+        addr:            0x18
+        size:            32
+        offset:          0x178
         align:           3
-        reloff:          0x00000238
-        nreloc:          4
-        flags:           0x00000000
-        reserved1:       0x00000000
-        reserved2:       0x00000000
-        reserved3:       0x00000000
-        content:         1400000000000000017A520001781001100C0708900100002400000004000000F8FFFFFFFFFFFFFF120000000000000000410E108602430D0600000000000000
+        reloff:          0x198
+        nreloc:          1
+        flags:           0x2000000
+        reserved1:       0x0
+        reserved2:       0x0
+        reserved3:       0x0
+        content:         '0000000000000000120000000000000100000000000000000000000000000000'
         relocations:
-          - address:         0x0000001C
-            symbolnum:       0
-            pcrel:           false
-            length:          2
-            extern:          true
-            type:            5
-            scattered:       false
-            value:           0
-          - address:         0x0000001C
-            symbolnum:       1
-            pcrel:           false
-            length:          2
-            extern:          true
-            type:            0
-            scattered:       false
-            value:           0
-          - address:         0x00000020
-            symbolnum:       1
-            pcrel:           false
-            length:          3
-            extern:          true
-            type:            5
-            scattered:       false
-            value:           0
-          - address:         0x00000020
-            symbolnum:       10
+          - address:         0x0
+            symbolnum:       8
             pcrel:           false
             length:          3
             extern:          true
@@ -88,39 +70,72 @@ LoadCommands:
             value:           0
   - cmd:             LC_SYMTAB
     cmdsize:         24
-    symoff:          608
-    nsyms:           11
-    stroff:          784
-    strsize:         72
+    symoff:          416
+    nsyms:           9
+    stroff:          560
+    strsize:         48
+  - cmd:             LC_BUILD_VERSION
+    cmdsize:         32
+    platform:        1
+    minos:           659200
+    sdk:             0
+    ntools:          1
+    Tools:
+      - tool:            3
+        version:         46596096
 LinkEditData:
   NameList:
-    - n_strx:          8      ## N_STAB sym (in got)
-      n_type:          0x0E
-      n_sect:          2
+    - n_strx:          8
+      n_type:          0x64 ## N_SO STAB
+      n_sect:          0
       n_desc:          0
-      n_value:         24
-    - n_strx:          18
-      n_type:          0x0E
-      n_sect:          2
+      n_value:         0
+    - n_strx:          14
+      n_type:          0x64 ## N_SO STAB
+      n_sect:          0
+      n_desc:          0
+      n_value:         0
+    - n_strx:          21
+      n_type:          0x66 ## N_OSO STAB
+      n_sect:          3
+      n_desc:          1
+      n_value:         1651001352
+    - n_strx:          1
+      n_type:          0x2E ## N_BNSYM STAB
+      n_sect:          1
+      n_desc:          0
+      n_value:         0
+    - n_strx:          41
+      n_type:          0x24 ## N_FUN STAB
+      n_sect:          1
       n_desc:          0
-      n_value:         48
+      n_value:         0
+    - n_strx:          1
+      n_type:          0x24 ## N_FUN STAB
+      n_sect:          0
+      n_desc:          0
+      n_value:         18
     - n_strx:          1
-      n_type:          0x4E
+      n_type:          0x4E ## N_ENSYM STAB
       n_sect:          1
       n_desc:          0
       n_value:         18
-    - n_strx:          2          ## _main
-      n_type:          0x0F
+    - n_strx:          1
+      n_type:          0x64 ## N_SO STAB
+      n_sect:          1
+      n_desc:          0
+      n_value:         0
+    - n_strx:          2
+      n_type:          0xF
       n_sect:          1
       n_desc:          0
       n_value:         0
   StringTable:
     - ' '
     - _main
-    - EH_Frame1
-    - func.eh
-    - '/Users/vyng/'
-    - test.cc
-    - '/Users/vyng/test.o'
+    - '/tmp/'
+    - test.c
+    - '/private/tmp/test.o'
     - _main
+    - ''
 ...
diff --git a/lld/test/MachO/objc-classrefs-dedup.s b/lld/test/MachO/objc-classrefs-dedup.s
new file mode 100644
index 0000000000000..dcb6bd6b75a55
--- /dev/null
+++ b/lld/test/MachO/objc-classrefs-dedup.s
@@ -0,0 +1,53 @@
+# REQUIRES: x86
+# RUN: rm -rf %t; split-file %s %t
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/defs.s -o %t/defs.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/refs1.s -o %t/refs1.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/refs2.s -o %t/refs2.o
+# RUN: %lld -lSystem -dylib %t/defs.o -o %t/libdefs.dylib
+# RUN: %lld -lSystem -dylib --icf=all %t/refs1.o %t/refs2.o %t/libdefs.dylib -o %t/out
+# RUN: llvm-objdump --macho --section-headers --bind %t/out | FileCheck %s \
+# RUN:   --implicit-check-not __objc_classrefs
+
+## Check that we only have 3 (unique) entries
+# CHECK:      Sections:
+# CHECK-NEXT: Idx Name             Size
+# CHECK:          __objc_classrefs 00000018
+
+## And only two binds
+# CHECK:       Bind table:
+# CHECK-NEXT:  segment  section           address  type     addend dylib    symbol
+# CHECK-DAG:   __DATA   __objc_classrefs  {{.*}}   pointer       0 libdefs  _OBJC_CLASS_$_Bar
+# CHECK-DAG:   __DATA   __objc_classrefs  {{.*}}   pointer       0 libdefs  _OBJC_CLASS_$_Foo
+
+#--- defs.s
+.globl _OBJC_CLASS_$_Foo, _OBJC_CLASS_$_Bar
+.section __DATA,__objc_data
+_OBJC_CLASS_$_Foo:
+ .quad 123
+
+_OBJC_CLASS_$_Bar:
+ .quad 456
+
+.subsections_via_symbols
+
+#--- refs1.s
+.globl _OBJC_CLASS_$_Baz
+
+.section __DATA,__objc_data
+_OBJC_CLASS_$_Baz:
+ .quad 789
+
+.section __DATA,__objc_classrefs
+.quad _OBJC_CLASS_$_Foo
+.quad _OBJC_CLASS_$_Bar
+.quad _OBJC_CLASS_$_Baz
+.quad _OBJC_CLASS_$_Baz
+
+.subsections_via_symbols
+
+#--- refs2.s
+.section __DATA,__objc_classrefs
+.quad _OBJC_CLASS_$_Foo
+.quad _OBJC_CLASS_$_Bar
+
+.subsections_via_symbols
diff --git a/lld/test/MachO/objc-uses-custom-personality.s b/lld/test/MachO/objc-uses-custom-personality.s
index 403c9004179ba..b3d57d14ad73e 100644
--- a/lld/test/MachO/objc-uses-custom-personality.s
+++ b/lld/test/MachO/objc-uses-custom-personality.s
@@ -5,9 +5,9 @@
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-iossimulator %t/defined.s -o %t/defined.o
 # RUN: yaml2obj %t/combined.yaml > %t/combined.o
 # RUN: llvm-ar r %t/pack.a %t/defined.o %t/combined.o
-# RUN: %lld -dylib -arch x86_64 -platform_version ios-simulator 12.0.0 15.0 -ObjC %t/pack.a -o %t/a.dylib
+# RUN: %no-arg-lld -dylib -arch x86_64 -platform_version ios-simulator 12.0.0 15.0 -ObjC %t/pack.a -o %t/a.dylib
 # RUN: llvm-objdump --macho --syms %t/a.dylib | FileCheck %s
-# RUN: %lld -dylib -arch x86_64 -platform_version ios-simulator 12.0.0 15.0 -ObjC --start-lib %t/defined.o %t/combined.o --end-lib -o %t/a.dylib
+# RUN: %no-arg-lld -dylib -arch x86_64 -platform_version ios-simulator 12.0.0 15.0 -ObjC --start-lib %t/defined.o %t/combined.o --end-lib -o %t/a.dylib
 # RUN: llvm-objdump --macho --syms %t/a.dylib | FileCheck %s
 
 # CHECK: SYMBOL TABLE:
diff --git a/lld/test/MachO/objc.s b/lld/test/MachO/objc.s
index 9cfd5285e0bef..ad7e639d99c21 100644
--- a/lld/test/MachO/objc.s
+++ b/lld/test/MachO/objc.s
@@ -5,11 +5,12 @@
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/has-objc-category.s -o %t/has-objc-category.o
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/has-objc-symbol-and-category.s -o %t/has-objc-symbol-and-category.o
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/has-swift.s -o %t/has-swift.o
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/has-swift-proto.s -o %t/has-swift-proto.o
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/no-objc.s -o %t/no-objc.o
 ## Make sure we don't mis-parse a 32-bit file as 64-bit
 # RUN: llvm-mc -filetype=obj -triple=armv7-apple-watchos %t/no-objc.s -o %t/wrong-arch.o
-# RUN: llvm-ar rcs %t/libHasSomeObjC.a %t/no-objc.o %t/has-objc-symbol.o %t/has-objc-category.o %t/has-swift.o %t/wrong-arch.o
-# RUN: llvm-ar rcs %t/libHasSomeObjC2.a %t/no-objc.o %t/has-objc-symbol-and-category.o %t/has-swift.o %t/wrong-arch.o
+# RUN: llvm-ar rcs %t/libHasSomeObjC.a %t/no-objc.o %t/has-objc-symbol.o %t/has-objc-category.o %t/has-swift.o %t/has-swift-proto.o %t/wrong-arch.o
+# RUN: llvm-ar rcs %t/libHasSomeObjC2.a %t/no-objc.o %t/has-objc-symbol-and-category.o %t/has-swift.o %t/has-swift-proto.o %t/wrong-arch.o
 
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %t/test.s -o %t/test.o
 
@@ -19,19 +20,21 @@
 # RUN: %lld -lSystem %t/test.o -o %t/test -L%t -lHasSomeObjC2 -ObjC
 # RUN: llvm-objdump --section-headers --syms %t/test | FileCheck %s --check-prefix=OBJC
 
-# RUN: %lld -lSystem %t/test.o -o %t/test --start-lib %t/no-objc.o %t/has-objc-symbol.o %t/has-objc-category.o %t/has-swift.o %t/wrong-arch.o --end-lib -ObjC
+# RUN: %lld -lSystem %t/test.o -o %t/test --start-lib %t/no-objc.o %t/has-objc-symbol.o %t/has-objc-category.o %t/has-swift.o %t/has-swift-proto.o %t/wrong-arch.o --end-lib -ObjC
 # RUN: llvm-objdump --section-headers --syms %t/test | FileCheck %s --check-prefix=OBJC
 
 # OBJC:       Sections:
 # OBJC-NEXT:  Idx Name            Size   VMA  Type
 # OBJC-NEXT:    0 __text          {{.*}}      TEXT
 # OBJC-NEXT:    1 __swift         {{.*}}      DATA
-# OBJC-NEXT:    2 __objc_catlist  {{.*}}      DATA
-# OBJC-NEXT:    3 has_objc_symbol {{.*}}      DATA
+# OBJC-NEXT:    2 __swift5_fieldmd{{.*}}      DATA
+# OBJC-NEXT:    3 __objc_catlist  {{.*}}      DATA
+# OBJC-NEXT:    4 has_objc_symbol {{.*}}      DATA
 # OBJC-EMPTY:
 # OBJC-NEXT:  SYMBOL TABLE:
 # OBJC-DAG:   g     F __TEXT,__text _main
 # OBJC-DAG:   g     F __TEXT,__text _OBJC_CLASS_$_MyObject
+# OBJC-DAG:   g     O __TEXT,__swift5_fieldmd $s7somelib4Blah_pMF
 
 # RUN: %lld -lSystem %t/test.o -o %t/test -L%t -lHasSomeObjC
 # RUN: llvm-objdump --section-headers --syms %t/test | FileCheck %s --check-prefix=NO-OBJC
@@ -93,6 +96,11 @@ _has_dup:
 .section __TEXT,__swift
 .quad 0x1234
 
+#--- has-swift-proto.s
+.section __TEXT,__swift5_fieldmd
+.globl $s7somelib4Blah_pMF
+$s7somelib4Blah_pMF:
+
 #--- no-objc.s
 ## This archive member should not be pulled in by -ObjC since it does not
 ## contain any ObjC-related data.
diff --git a/lld/test/MachO/pagezero.s b/lld/test/MachO/pagezero.s
new file mode 100644
index 0000000000000..2924fd1ddae70
--- /dev/null
+++ b/lld/test/MachO/pagezero.s
@@ -0,0 +1,37 @@
+# REQUIRES: x86, aarch64
+# RUN: rm -rf %t; mkdir %t
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %s -o %t/x86_64.o
+# RUN: llvm-mc -filetype=obj -triple=arm64_32-apple-darwin %s -o %t/arm64_32.o
+
+# RUN: %lld -lSystem -arch x86_64 -o %t/x86_64 %t/x86_64.o -pagezero_size 100000
+# RUN: llvm-readobj --macho-segment %t/x86_64 | FileCheck %s -D#VMSIZE=0x100000 -D#SIZE=72
+
+# RUN: %lld-watchos -lSystem -arch arm64_32 -o %t/arm64_32 %t/arm64_32.o -pagezero_size 100000
+# RUN: llvm-readobj --macho-segment %t/arm64_32 | FileCheck %s -D#VMSIZE=0x100000 -D#SIZE=56
+
+# RUN: %lld -lSystem -arch x86_64 -o %t/zero %t/x86_64.o -pagezero_size 0
+# RUN: llvm-readobj --macho-segment %t/zero | FileCheck %s --check-prefix=CHECK-ZERO -D#VMSIZE=0x1000 -D#SIZE=152
+
+# RUN: %no_fatal_warnings_lld -lSystem -arch x86_64 -o %t/x86_64-misalign %t/x86_64.o -pagezero_size 1001 2>&1 | FileCheck %s --check-prefix=LINK -D#SIZE=0x1000
+# RUN: llvm-readobj --macho-segment %t/x86_64-misalign | FileCheck %s -D#VMSIZE=0x1000 -D#SIZE=72
+
+# RUN: %no_fatal_warnings_lld-watchos -lSystem -arch arm64_32 -o %t/arm64_32-misalign-4K %t/arm64_32.o -pagezero_size 1001 2>&1 | FileCheck %s --check-prefix=LINK -D#SIZE=0x0
+# RUN: llvm-readobj --macho-segment %t/arm64_32-misalign-4K | FileCheck %s --check-prefix=CHECK-ZERO -D#VMSIZE=0x4000 -D#SIZE=124
+
+# RUN: %no_fatal_warnings_lld-watchos -lSystem -arch arm64_32 -o %t/arm64_32-misalign-16K %t/arm64_32.o -pagezero_size 4001 2>&1 | FileCheck %s --check-prefix=LINK -D#SIZE=0x4000
+# RUN: llvm-readobj --macho-segment %t/arm64_32-misalign-16K | FileCheck %s -D#VMSIZE=0x4000 -D#SIZE=56
+
+# LINK: warning: __PAGEZERO size is not page aligned, rounding down to 0x[[#%x,SIZE]]
+
+# CHECK:        Name: __PAGEZERO
+# CHECK-NEXT:   Size: [[#%d,SIZE]]
+# CHECK-NEXT:   vmaddr: 0x0
+# CHECK-NEXT:   vmsize: 0x[[#%x,VMSIZE]]
+
+# CHECK-ZERO:        Name: __TEXT
+# CHECK-ZERO-NEXT:   Size: [[#%d,SIZE]]
+# CHECK-ZERO-NEXT:   vmaddr: 0x0
+# CHECK-ZERO-NEXT:   vmsize: 0x[[#%x,VMSIZE]]
+
+.globl _main
+_main:
diff --git a/lld/test/MachO/platform-version.s b/lld/test/MachO/platform-version.s
index 0bfc46930c5b2..047aea02fcde3 100644
--- a/lld/test/MachO/platform-version.s
+++ b/lld/test/MachO/platform-version.s
@@ -5,61 +5,74 @@
 ### with bad version strings, so we use *-NOT patterns to ensure that
 ### no "malformed platform" diagnostic appears in those cases.
 
-# RUN: not %lld -o %t %t.o 2>&1 \
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version \
 # RUN:    | FileCheck --check-prefix=FAIL-MISSING %s
-# RUN: not %lld -o %t %t.o 2>&1 \
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version wtf \
 # RUN:    | FileCheck --check-prefix=FAIL-MISSING %s
-# RUN: not %lld -o %t %t.o 2>&1 \
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version lolz 1.2.3.4.5 \
 # RUN:    | FileCheck --check-prefix=FAIL-MISSING %s
 # FAIL-MISSING: -platform_version: missing argument
 # FAIL-MISSING-NOT: malformed platform: {{.*}}
 # FAIL-MISSING-NOT: malformed {{minimum|sdk}} version: {{.*}}
 
-# RUN: not %lld -o %t %t.o 2>&1 \
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version macOS -lfoo 2 \
 # RUN:     | FileCheck --check-prefix=FAIL-MALFORM %s
-# RUN: not %lld -o %t %t.o 2>&1 \
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version iOS 1 2.a \
 # RUN:     | FileCheck --check-prefix=FAIL-MALFORM %s
-# RUN: not %lld -o %t %t.o 2>&1 \
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version tvOS 1.2.3.4.5 10 \
 # RUN:     | FileCheck --check-prefix=FAIL-MALFORM %s
-# RUN: not %lld -o %t %t.o 2>&1 \
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version watchOS 10 1.2.3.4.5 \
 # RUN:     | FileCheck --check-prefix=FAIL-MALFORM %s
 # FAIL-MALFORM-NOT: malformed platform: {{.*}}
 # FAIL-MALFORM: malformed {{minimum|sdk}} version: {{.*}}
 
-# RUN: %lld -o %t %t.o 2>&1 \
+# RUN: %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version bridgeOS 1 5
-# RUN: %lld -o %t %t.o 2>&1 \
+# RUN: %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version "Mac Catalyst" 1.2 5.6
-# RUN: %lld -o %t %t.o 2>&1 \
+# RUN: %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version "iOS Simulator" 1.2.3 5.6.7
-# RUN: %lld -o %t %t.o 2>&1 \
+# RUN: %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version tvOS-Simulator 1.2.3.4 5.6.7.8
-# RUN: %lld -o %t %t.o 2>&1 \
+# RUN: %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version watchOS-Simulator 1 5
-# RUN: %lld -o %t %t.o 2>&1 \
+# RUN: %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version 1 1 5
-# RUN: %lld -o %t %t.o 2>&1 \
+# RUN: %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version 9 1 5
 
-# RUN: not %lld -o %t %t.o 2>&1 \
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version wtf 1 5 \
 # RUN:     | FileCheck --check-prefix=FAIL-PLATFORM %s
-# RUN: not %lld -o %t %t.o 2>&1 \
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version 0 1 5 \
 # RUN:     | FileCheck --check-prefix=FAIL-PLATFORM %s
-# RUN: not %lld -o %t %t.o 2>&1 \
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
 # RUN:        -platform_version 11 1 5 \
 # RUN:     | FileCheck --check-prefix=FAIL-PLATFORM %s
 # FAIL-PLATFORM: malformed platform: {{.*}}
 # FAIL-PLATFORM-NOT: malformed {{minimum|sdk}} version: {{.*}}
 
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o -fatal_warnings 2>&1 \
+# RUN:        -platform_version iOS 14.0 15.0 \
+# RUN:        -platform_version macos 12.0 12.0 \
+# RUN:     | FileCheck --check-prefix=FAIL-TODO %s
+# FAIL-TODO: lld supports writing zippered outputs only for macos and mac-catalyst
+
+# RUN: not %no-arg-lld -arch x86_64 -o %t %t.o 2>&1 \
+# RUN:        -platform_version bridgeOS 1 5 \
+# RUN:        -platform_version 'mac catalyst' 14.0 15.0 \
+# RUN:        -platform_version macos 12.0 12.0 \
+# RUN:     | FileCheck --check-prefix=FAIL-TOOMANY %s
+# FAIL-TOOMANY: must specify -platform_version at most twice
+
 .text
 .global _main
 _main:
diff --git a/lld/test/MachO/stabs-icf.s b/lld/test/MachO/stabs-icf.s
new file mode 100644
index 0000000000000..61588eb4a3ebf
--- /dev/null
+++ b/lld/test/MachO/stabs-icf.s
@@ -0,0 +1,73 @@
+# REQUIRES: x86
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %s -o %t.o
+
+# RUN: %lld -lSystem --icf=all %t.o -o %t
+# RUN: dsymutil -s %t | FileCheck %s -DDIR=%t -DSRC_PATH=%t.o
+
+# This should include no N_FUN entry for _bar2 (which is ICF'd into _bar),
+# but it does include a SECT EXT entry.
+# CHECK:      (N_SO         ) 00      0000   0000000000000000   '/tmp{{[/\\]}}test.cpp'
+# CHECK-NEXT: (N_OSO        ) 03      0001   {{.*}} '[[SRC_PATH]]'
+# CHECK-NEXT: (N_FUN        ) 01      0000   [[#%.16x,MAIN:]]   '_main'
+# CHECK-NEXT: (N_FUN        ) 00      0000   000000000000000b{{$}}
+# CHECK-NEXT: (N_FUN        ) 01      0000   [[#%.16x,BAR:]]    '_bar'
+# CHECK-NEXT: (N_FUN        ) 00      0000   0000000000000001{{$}}
+# CHECK-NEXT: (N_SO         ) 01      0000   0000000000000000{{$}}
+# CHECK-DAG:  (     SECT EXT) 01      0000   [[#MAIN]]           '_main'
+# CHECK-DAG:  (     SECT EXT) 01      0000   [[#BAR]]           '_bar'
+# CHECK-DAG:  (     SECT EXT) 01      0000   [[#BAR]]          '_bar2'
+# CHECK-DAG:  (       {{.*}}) {{[0-9]+}}                 0010   {{[0-9a-f]+}}      '__mh_execute_header'
+# CHECK-DAG:  (       {{.*}}) {{[0-9]+}}                 0100   0000000000000000   'dyld_stub_binder'
+# CHECK-EMPTY:
+
+.text
+.globl _bar, _bar2, _main
+
+.subsections_via_symbols
+
+_bar:
+  ret
+
+_bar2:
+  ret
+
+_main:
+Lfunc_begin0:
+  call _bar
+  call _bar2
+  ret
+Lfunc_end0:
+
+.section  __DWARF,__debug_str,regular,debug
+  .asciz  "test.cpp"             ## string offset=0
+  .asciz  "/tmp"                 ## string offset=9
+.section  __DWARF,__debug_abbrev,regular,debug
+Lsection_abbrev:
+  .byte  1                       ## Abbreviation Code
+  .byte  17                      ## DW_TAG_compile_unit
+  .byte  1                       ## DW_CHILDREN_yes
+  .byte  3                       ## DW_AT_name
+  .byte  14                      ## DW_FORM_strp
+  .byte  27                      ## DW_AT_comp_dir
+  .byte  14                      ## DW_FORM_strp
+  .byte  17                      ## DW_AT_low_pc
+  .byte  1                       ## DW_FORM_addr
+  .byte  18                      ## DW_AT_high_pc
+  .byte  6                       ## DW_FORM_data4
+  .byte  0                       ## EOM(1)
+.section  __DWARF,__debug_info,regular,debug
+.set Lset0, Ldebug_info_end0-Ldebug_info_start0 ## Length of Unit
+  .long  Lset0
+Ldebug_info_start0:
+  .short  4                       ## DWARF version number
+.set Lset1, Lsection_abbrev-Lsection_abbrev ## Offset Into Abbrev. Section
+  .long  Lset1
+  .byte  8                       ## Address Size (in bytes)
+  .byte  1                       ## Abbrev [1] 0xb:0x48 DW_TAG_compile_unit
+  .long  0                       ## DW_AT_name
+  .long  9                       ## DW_AT_comp_dir
+  .quad  Lfunc_begin0            ## DW_AT_low_pc
+.set Lset3, Lfunc_end0-Lfunc_begin0     ## DW_AT_high_pc
+  .long  Lset3
+  .byte  0                       ## End Of Children Mark
+Ldebug_info_end0:
diff --git a/lld/test/MachO/tapi-link-by-arch.s b/lld/test/MachO/tapi-link-by-arch.s
index 61e397a621d81..d78b2ea83c1e3 100644
--- a/lld/test/MachO/tapi-link-by-arch.s
+++ b/lld/test/MachO/tapi-link-by-arch.s
@@ -2,15 +2,15 @@
 
 # RUN: mkdir -p %t
 # RUN: llvm-mc -filetype obj -triple arm64-apple-ios14.4 %s -o %t/arm64-ios.o
-# RUN: not %lld -dylib -arch arm64 -platform_version ios 14.4 15.0 -o /dev/null \
+# RUN: not %no-arg-lld -dylib -arch arm64 -platform_version ios 14.4 15.0 -o /dev/null \
 # RUN:   -lSystem %S/Inputs/libStubLink.tbd %t/arm64-ios.o 2>&1 | FileCheck %s
 
 # RUN: llvm-mc -filetype obj -triple x86_64-apple-iossimulator14.4 %s -o %t/x86_64-sim.o
-# RUN: not %lld -dylib -arch x86_64 -platform_version ios-simulator 14.4 15.0 -o /dev/null \
+# RUN: not %no-arg-lld -dylib -arch x86_64 -platform_version ios-simulator 14.4 15.0 -o /dev/null \
 # RUN:   -lSystem %S/Inputs/libStubLink.tbd %t/x86_64-sim.o 2>&1 | FileCheck %s
 
 # RUN: llvm-mc -filetype obj -triple arm64-apple-iossimulator14.4 %s -o %t/arm64-sim.o
-# RUN: %lld -dylib -arch arm64 -platform_version ios-simulator 14.4 15.0 -o \
+# RUN: %no-arg-lld -dylib -arch arm64 -platform_version ios-simulator 14.4 15.0 -o \
 # RUN:   /dev/null %S/Inputs/libStubLink.tbd %t/arm64-sim.o
 
 # CHECK: error: undefined symbol: _arm64_sim_only
diff --git a/lld/test/MachO/tools/generate-cfi-funcs.py b/lld/test/MachO/tools/generate-cfi-funcs.py
index a91eab3eeac6b..c8af2c4876f4a 100755
--- a/lld/test/MachO/tools/generate-cfi-funcs.py
+++ b/lld/test/MachO/tools/generate-cfi-funcs.py
@@ -24,9 +24,6 @@ def print_function(name):
   have_lsda = (random.random() < lsda_odds)
   frame_size = random.randint(4, 64) * 16
   frame_offset = -random.randint(0, (frame_size/16 - 4)) * 16
-  reg_count = random.randint(0, 5)
-  reg_combo = random.randint(0, factorial(reg_count) - 1)
-  regs_saved = saved_regs_combined[reg_count][reg_combo]
   global func_size_low, func_size_high
   func_size = random.randint(func_size_low, func_size_high) * 0x10
   func_size_high += 1
@@ -34,13 +31,13 @@ def print_function(name):
     func_size_low += 1
 
   print("""\
-### %s regs=%d frame=%d lsda=%s size=%d
+### %s frame=%d lsda=%s size=%d
     .section __TEXT,__text,regular,pure_instructions
     .p2align 4, 0x90
     .globl %s
 %s:
     .cfi_startproc""" % (
-        name, reg_count, frame_size, have_lsda, func_size, name, name))
+        name, frame_size, have_lsda, func_size, name, name))
   if have_lsda:
     global lsda_n
     lsda_n += 1
@@ -53,8 +50,6 @@ def print_function(name):
     .cfi_offset %%rbp, %d
     movq %%rsp, %%rbp
     .cfi_def_cfa_register %%rbp""" % (frame_size, frame_offset + 6*8))
-  for i in range(reg_count):
-    print(".cfi_offset %s, %d" % (regs_saved[i], frame_offset+(i*8)))
   print("""\
     .fill %d
     popq %%rbp
diff --git a/lld/test/MachO/uuid.s b/lld/test/MachO/uuid.s
index b4486fe63ecfb..ff38f4bda524c 100644
--- a/lld/test/MachO/uuid.s
+++ b/lld/test/MachO/uuid.s
@@ -1,8 +1,22 @@
 # REQUIRES: x86
-# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %s -o %t.o
-# RUN: %lld -lSystem %t.o -o %t
-# RUN: llvm-dwarfdump --uuid %t | FileCheck %s
-# CHECK: 4C4C44{{([[:xdigit:]]{2})}}-5555-{{([[:xdigit:]]{4})}}-A1{{([[:xdigit:]]{2})}}-{{([[:xdigit:]]{12})}} (x86_64)
+# RUN: rm -rf %t && mkdir -p %t
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin %s -o %t/test.o
+# RUN: %lld -lSystem %t/test.o -o %t/a
+# RUN: %lld -lSystem %t/test.o -o %t/b
+# RUN: llvm-dwarfdump --uuid %t/a | awk '{print $2}' > %t/uuida
+# RUN: llvm-dwarfdump --uuid %t/b | awk '{print $2}' > %t/uuidb
+# RUN: FileCheck %s < %t/uuida
+# RUN: FileCheck %s < %t/uuidb
+# RUN: not cmp %t/uuida %t/uuidb
+
+## Ensure -final_output is used for universal binaries, which may be linked with
+## temporary output file names
+# RUN: %lld -lSystem %t/test.o -o %t/c -final_output %t/a
+# RUN: llvm-dwarfdump --uuid %t/c | awk '{print $2}' > %t/uuidc
+# RUN: cmp %t/uuida %t/uuidc
+
+
+# CHECK: 4C4C44{{([[:xdigit:]]{2})}}-5555-{{([[:xdigit:]]{4})}}-A1{{([[:xdigit:]]{2})}}-{{([[:xdigit:]]{12})}}
 
 .globl _main
 _main:
diff --git a/lld/test/MachO/weak-definition-gc.s b/lld/test/MachO/weak-definition-gc.s
index e1d5cb44ddb0e..15c3b88c25461 100644
--- a/lld/test/MachO/weak-definition-gc.s
+++ b/lld/test/MachO/weak-definition-gc.s
@@ -66,15 +66,19 @@
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin19.0.0 %t/weak-aligned-1.s -o %t/weak-aligned-1.o
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin19.0.0 %t/weak-aligned-2.s -o %t/weak-aligned-2.o
 # RUN: %lld -o %t/out -lSystem %t/weak-aligned-1.o %t/weak-aligned-2.o
-# RUN: llvm-objdump --syms --section=__const --full-contents %t/out | FileCheck --check-prefix=ALIGN %s
-# ALIGN:      SYMBOL TABLE:
-# ALIGN-DAG:  [[#%x, ADDR:]]       l     O __DATA_CONST,__const _weak1
-# ALIGN-DAG:  {{0*}}[[#ADDR+ 0x4]] l     O __DATA_CONST,__const _weak3
-# ALIGN-DAG:  {{0*}}[[#ADDR+ 0x8]] l     O __DATA_CONST,__const _weak2
-# ALIGN-DAG:  {{0*}}[[#ADDR+0x10]] g     O __DATA_CONST,__const _aligned
-# ALIGN:      Contents of section __DATA_CONST,__const:
-# ALIGN-NEXT: {{0*}}[[#ADDR]]      11111111 33333333 22222222 00000000
-# ALIGN-NEXT: {{0*}}[[#ADDR+0x10]] 81818181 81818181 82828282 82828282
+# RUN: llvm-objdump --syms --section=__const --full-contents %t/out | FileCheck --check-prefixes=ALIGN,ALIGN2 %s
+# RUN: %lld -o %t/out -lSystem %t/weak-aligned-1.o %t/weak-aligned-2.o -dead_strip
+# RUN: llvm-objdump --syms --section=__const --full-contents %t/out | FileCheck --check-prefixes=ALIGN,ALIGN3 %s
+# ALIGN:       SYMBOL TABLE:
+# ALIGN-DAG:   [[#%x, ADDR:]]       l     O __DATA_CONST,__const _weak1
+# ALIGN2-DAG:  {{0*}}[[#ADDR+ 0x4]] l     O __DATA_CONST,__const _weak3
+# ALIGN3-DAG:  {{0*}}[[#ADDR+ 0x4]] l     O __DATA_CONST,__const _weak2
+# ALIGN2-DAG:  {{0*}}[[#ADDR+ 0x8]] l     O __DATA_CONST,__const _weak2
+# ALIGN-DAG:   {{0*}}[[#ADDR+0x10]] g     O __DATA_CONST,__const _aligned
+# ALIGN:       Contents of section __DATA_CONST,__const:
+# ALIGN2-NEXT: {{0*}}[[#ADDR]]      11111111 33333333 22222222 00000000
+# ALIGN3-NEXT: {{0*}}[[#ADDR]]      11111111 22222222 00000000 00000000
+# ALIGN-NEXT:  {{0*}}[[#ADDR+0x10]] 81818181 81818181 82828282 82828282
 
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin19.0.0 %t/weak-def.s -o %t/weak-def.o
 # RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin19.0.0 %t/strong-def.s -o %t/strong-def.o
diff --git a/lld/test/MachO/why-live.s b/lld/test/MachO/why-live.s
new file mode 100644
index 0000000000000..40d94e9da25c6
--- /dev/null
+++ b/lld/test/MachO/why-live.s
@@ -0,0 +1,64 @@
+# REQUIRES: x86
+
+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-macos %s -o %t.o
+# RUN: %lld -lSystem -dead_strip -why_live _foo -why_live _undef -U _undef \
+# RUN:   -why_live _support -why_live _support_refs_dylib_fun \
+# RUN:   -why_live _abs %t.o -o /dev/null 2>&1 | FileCheck %s
+
+## Due to an implementation detail, LLD is not able to report -why_live info for
+## absolute symbols. (ld64 has the same shortcoming.)
+# CHECK-NOT:   _abs
+# CHECK:       _foo from {{.*}}why-live.s.tmp.o
+# CHECK-NEXT:    _quux from {{.*}}why-live.s.tmp.o
+# CHECK-NEXT:  _undef from {{.*}}why-live.s.tmp.o
+# CHECK-NEXT:    _main from {{.*}}why-live.s.tmp.o
+## Our handling of live_support sections can be improved... we should print the
+## dylib symbol that keeps _support_refs_dylib_fun alive, instead of printing
+## the live_support symbol's name itself. (ld64 seems to have the same issue.)
+# CHECK-NEXT: _support_refs_dylib_fun from {{.*}}why-live.s.tmp.o
+# CHECK-NEXT:   _support_refs_dylib_fun from {{.*}}why-live.s.tmp.o
+## Again, this can be improved: we shouldn't be printing _support twice. (ld64
+## seems to have the same issue.)
+# CHECK-NEXT:  _support from {{.*}}why-live.s.tmp.o
+# CHECK-NEXT:    _support from {{.*}}why-live.s.tmp.o
+# CHECK-NEXT:      _foo from {{.*}}why-live.s.tmp.o
+# CHECK-EMPTY:
+
+.text
+_foo:
+  retq
+
+_bar:
+  retq
+
+_baz:
+  callq _foo
+  retq
+
+.no_dead_strip _quux
+_quux:
+  callq _foo
+  retq
+
+.globl _main
+_main:
+  callq _foo
+  callq _baz
+  callq _undef
+  callq ___isnan
+  retq
+
+.globl _abs
+_abs = 0x1000
+
+.section __TEXT,support,regular,live_support
+_support:
+  callq _foo
+  callq _abs
+  retq
+
+_support_refs_dylib_fun:
+  callq ___isnan
+  retq
+
+.subsections_via_symbols
diff --git a/lld/test/MachO/zippered.yaml b/lld/test/MachO/zippered.yaml
index 0b7c520b6b2e3..75a43c41a750d 100644
--- a/lld/test/MachO/zippered.yaml
+++ b/lld/test/MachO/zippered.yaml
@@ -5,12 +5,62 @@
 # RUN: echo "" | llvm-mc -filetype=obj -triple=x86_64-apple-ios13.15.0-macabi -o %t/test_maccatalyst.o
 # RUN: echo "" | llvm-mc -filetype=obj -triple=x86_64-apple-ios13.15.0 -o %t/test_ios.o
 
+## Test linking against a zippered dylib.
 # RUN: %lld -lSystem -dylib %t/test.dylib %t/test_macos.o -o /dev/null
-# RUN: %lld -lSystem -dylib -platform_version mac-catalyst 13.15.0 14.0 %t/test.dylib %t/test_maccatalyst.o -o /dev/null
+# RUN: %no-arg-lld -syslibroot %S/Inputs/MacOSX.sdk -lSystem -dylib -arch x86_64 -platform_version mac-catalyst 13.15.0 14.0 %t/test.dylib %t/test_maccatalyst.o -o /dev/null
 
-# RUN: not %lld -lSystem -dylib -platform_version ios 13.15.0 14.0 %t/test.dylib %t/test_ios.o -o /dev/null 2>&1 | FileCheck %s
+# RUN: %no-arg-lld -syslibroot %S/Inputs/MacOSX.sdk -lSystem -dylib -arch x86_64 -platform_version mac-catalyst 13.15.0 14.0 %t/test_maccatalyst.o -o /dev/null -framework MacOnly-Indirect
+
+# RUN: not %no-arg-lld -syslibroot %S/Inputs/MacOSX.sdk -lSystem -dylib -arch x86_64 -platform_version mac-catalyst 13.15.0 14.0 %t/test_maccatalyst.o -o /dev/null -framework MacOnly 2>&1 | FileCheck --check-prefix=INCOMPATIBLE %s
+# INCOMPATIBLE: System/Library/Frameworks{{[\\/]}}MacOnly.framework{{[\\/]}}MacOnly.tbd(MacOnly.dylib) is incompatible with x86_64 (macCatalyst)
+
+# RUN: not %no-arg-lld -syslibroot %S/Inputs/MacOSX.sdk -lSystem -dylib -arch x86_64 -platform_version ios 13.15.0 14.0 %t/test.dylib %t/test_ios.o -o /dev/null 2>&1 | FileCheck %s
 # CHECK: test.dylib has platform macOS/macCatalyst, which is different from target platform iOS
 
+## Test creating a zippered dylib.
+# RUN: %no-arg-lld -syslibroot %S/Inputs/MacOSX.sdk -lSystem -dylib -arch x86_64 -platform_version macos 12.0 13.0 -platform_version mac-catalyst 13.15.0 14.0 %t/test.dylib %t/test_macos.o -o %t/test_zippered.dylib
+# RUN: llvm-otool -l %t/test_zippered.dylib | FileCheck --check-prefix=ZIPPERED %s
+# ZIPPERED:           cmd LC_BUILD_VERSION
+# ZIPPERED-NEXT:  cmdsize
+# ZIPPERED-NEXT: platform 1
+# ZIPPERED-NEXT:      sdk 13.0
+# ZIPPERED-NEXT:    minos 12.0
+# ZIPPERED-NEXT:   ntools 1
+# ZIPPERED-NEXT:     tool
+# ZIPPERED-NEXT:  version
+# ZIPPERED-NEXT: Load command
+# ZIPPERED-NEXT:      cmd LC_BUILD_VERSION
+# ZIPPERED-NEXT:  cmdsize
+# ZIPPERED-NEXT: platform 6
+# ZIPPERED-NEXT:      sdk 14.0
+# ZIPPERED-NEXT:    minos 13.15
+# ZIPPERED-NEXT:   ntools 1
+# ZIPPERED-NEXT:     tool
+# ZIPPERED-NEXT:  version
+
+# RUN: %no-arg-lld -syslibroot %S/Inputs/MacOSX.sdk -lSystem -dylib -arch x86_64 -platform_version macos 10.8 13.0 -platform_version mac-catalyst 13.15.0 14.0 %t/test.dylib %t/test_macos.o -o %t/test_zippered.dylib
+# RUN: llvm-otool -l %t/test_zippered.dylib | FileCheck --check-prefix=ZIPPERED-OLD %s
+# ZIPPERED-OLD:           cmd LC_VERSION_MIN_MACOSX
+# ZIPPERED-OLD-NEXT:  cmdsize
+# ZIPPERED-OLD-NEXT:  version 10.8
+# ZIPPERED-OLD-NEXT:      sdk 13.0
+# ZIPPERED-OLD-NEXT: Load command
+# ZIPPERED-OLD-NEXT:      cmd LC_BUILD_VERSION
+# ZIPPERED-OLD-NEXT:  cmdsize
+# ZIPPERED-OLD-NEXT: platform 6
+# ZIPPERED-OLD-NEXT:      sdk 14.0
+# ZIPPERED-OLD-NEXT:    minos 13.15
+# ZIPPERED-OLD-NEXT:   ntools 1
+# ZIPPERED-OLD-NEXT:     tool
+# ZIPPERED-OLD-NEXT:  version
+
+# RUN: not %no-arg-lld -syslibroot %S/Inputs/MacOSX.sdk -lSystem -arch x86_64 -platform_version macos 10.8 13.0 -platform_version mac-catalyst 13.15.0 14.0 %t/test.dylib %t/test_macos.o -o %t/test_zippered.dylib 2>&1 | FileCheck --check-prefix=ZIPPERED-EXE %s
+# ZIPPERED-EXE: writing zippered outputs only valid for -dylib and -bundle
+
+## Reject .o files which only have the secondary platform.
+# RUN: not %no-arg-lld -syslibroot %S/Inputs/MacOSX.sdk -lSystem -dylib -arch x86_64 -platform_version macos 12.0 13.0 -platform_version mac-catalyst 13.15.0 14.0 %t/test.dylib %t/test_maccatalyst.o -o %t/test_zippered.dylib 2>&1 | FileCheck --check-prefix=CAT %s
+# CAT: test_maccatalyst.o has platform macCatalyst, which is different from target platform macOS
+
 --- !mach-o
 FileHeader:
   magic:           0xFEEDFACF
diff --git a/llvm/include/llvm/ADT/ArrayRef.h b/llvm/include/llvm/ADT/ArrayRef.h
index b6896395dae8a..9af4232414e57 100644
--- a/llvm/include/llvm/ADT/ArrayRef.h
+++ b/llvm/include/llvm/ADT/ArrayRef.h
@@ -25,6 +25,7 @@
 #include <vector>
 
 namespace llvm {
+  template<typename T> class LLVM_NODISCARD MutableArrayRef;
 
   /// ArrayRef - Represent a constant reference to an array (0 or more elements
   /// consecutively in memory), i.e. a start pointer and a length.  It allows
@@ -175,10 +176,10 @@ namespace llvm {
     }
 
     // copy - Allocate copy in Allocator and return ArrayRef<T> to it.
-    template <typename Allocator> ArrayRef<T> copy(Allocator &A) {
+    template <typename Allocator> MutableArrayRef<T> copy(Allocator &A) {
       T *Buff = A.template Allocate<T>(Length);
       std::uninitialized_copy(begin(), end(), Buff);
-      return ArrayRef<T>(Buff, Length);
+      return MutableArrayRef<T>(Buff, Length);
     }
 
     /// equals - Check for element-wise equality.
diff --git a/llvm/include/llvm/CodeGen/MachineBasicBlock.h b/llvm/include/llvm/CodeGen/MachineBasicBlock.h
index 638b6732a5435..c3e39b60a0304 100644
--- a/llvm/include/llvm/CodeGen/MachineBasicBlock.h
+++ b/llvm/include/llvm/CodeGen/MachineBasicBlock.h
@@ -110,10 +110,10 @@ class MachineBasicBlock
 private:
   using Instructions = ilist<MachineInstr, ilist_sentinel_tracking<true>>;
 
-  Instructions Insts;
   const BasicBlock *BB;
   int Number;
   MachineFunction *xParent;
+  Instructions Insts;
 
   /// Keep track of the predecessor / successor basic blocks.
   std::vector<MachineBasicBlock *> Predecessors;
diff --git a/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h b/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h
index d4960ab8b0bbf..f705d91cf9c3a 100644
--- a/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h
+++ b/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h
@@ -139,10 +139,19 @@ class ThreadSafeModule {
   /// Locks the associated ThreadSafeContext and calls the given function
   /// on the contained Module.
   template <typename Func> decltype(auto) withModuleDo(Func &&F) const {
+    assert(M && "Can not call on null module");
     auto Lock = TSCtx.getLock();
     return F(*M);
   }
 
+  /// Locks the associated ThreadSafeContext and calls the given function,
+  /// passing the contained std::unique_ptr<Module>. The given function should
+  /// consume the Module.
+  template <typename Func> decltype(auto) consumingModuleDo(Func &&F) {
+    auto Lock = TSCtx.getLock();
+    return F(std::move(M));
+  }
+
   /// Get a raw pointer to the contained module without locking the context.
   Module *getModuleUnlocked() { return M.get(); }
 
diff --git a/llvm/include/llvm/IR/IntrinsicsPowerPC.td b/llvm/include/llvm/IR/IntrinsicsPowerPC.td
index b01fa10763b83..6e5b9cbd9a449 100644
--- a/llvm/include/llvm/IR/IntrinsicsPowerPC.td
+++ b/llvm/include/llvm/IR/IntrinsicsPowerPC.td
@@ -1459,7 +1459,11 @@ def int_ppc_tsuspend : GCCBuiltin<"__builtin_tsuspend">,
 def int_ppc_ttest : GCCBuiltin<"__builtin_ttest">,
       Intrinsic<[llvm_i64_ty], [], []>;
 
-def int_ppc_cfence : Intrinsic<[], [llvm_anyint_ty], []>;
+// We currently use llvm.ppc.cfence in the context of atomic load which
+// in LLVM IR requires its type to be one of integer, pointer and
+// float point type. So llvm_any_ty here refers to type mentioned above.
+// Backend is supposed to lower these types to appropriate MVTs.
+def int_ppc_cfence : Intrinsic<[], [llvm_any_ty], []>;
 
 // PowerPC set FPSCR Intrinsic Definitions.
 def int_ppc_setrnd : GCCBuiltin<"__builtin_setrnd">,
diff --git a/llvm/lib/Analysis/LazyValueInfo.cpp b/llvm/lib/Analysis/LazyValueInfo.cpp
index e311b40ab25c1..30f3d47e2cfbe 100644
--- a/llvm/lib/Analysis/LazyValueInfo.cpp
+++ b/llvm/lib/Analysis/LazyValueInfo.cpp
@@ -1169,11 +1169,17 @@ static ValueLatticeElement getValueFromOverflowCondition(
   return ValueLatticeElement::getRange(NWR);
 }
 
+// Tracks a Value * condition and whether we're interested in it or its inverse
+typedef PointerIntPair<Value *, 1, bool> CondValue;
+
 static Optional<ValueLatticeElement>
-getValueFromConditionImpl(Value *Val, Value *Cond, bool isTrueDest,
-                          bool isRevisit,
-                          SmallDenseMap<Value *, ValueLatticeElement> &Visited,
-                          SmallVectorImpl<Value *> &Worklist) {
+getValueFromConditionImpl(
+    Value *Val, CondValue CondVal, bool isRevisit,
+    SmallDenseMap<CondValue, ValueLatticeElement> &Visited,
+    SmallVectorImpl<CondValue> &Worklist) {
+
+  Value *Cond = CondVal.getPointer();
+  bool isTrueDest = CondVal.getInt();
   if (!isRevisit) {
     if (ICmpInst *ICI = dyn_cast<ICmpInst>(Cond))
       return getValueFromICmpCondition(Val, ICI, isTrueDest);
@@ -1184,6 +1190,17 @@ getValueFromConditionImpl(Value *Val, Value *Cond, bool isTrueDest,
           return getValueFromOverflowCondition(Val, WO, isTrueDest);
   }
 
+  Value *N;
+  if (match(Cond, m_Not(m_Value(N)))) {
+    CondValue NKey(N, !isTrueDest);
+    auto NV = Visited.find(NKey);
+    if (NV == Visited.end()) {
+      Worklist.push_back(NKey);
+      return None;
+    }
+    return NV->second;
+  }
+
   Value *L, *R;
   bool IsAnd;
   if (match(Cond, m_LogicalAnd(m_Value(L), m_Value(R))))
@@ -1193,13 +1210,13 @@ getValueFromConditionImpl(Value *Val, Value *Cond, bool isTrueDest,
   else
     return ValueLatticeElement::getOverdefined();
 
-  auto LV = Visited.find(L);
-  auto RV = Visited.find(R);
+  auto LV = Visited.find(CondValue(L, isTrueDest));
+  auto RV = Visited.find(CondValue(R, isTrueDest));
 
   // if (L && R) -> intersect L and R
-  // if (!(L || R)) -> intersect L and R
+  // if (!(L || R)) -> intersect !L and !R
   // if (L || R) -> union L and R
-  // if (!(L && R)) -> union L and R
+  // if (!(L && R)) -> union !L and !R
   if ((isTrueDest ^ IsAnd) && (LV != Visited.end())) {
     ValueLatticeElement V = LV->second;
     if (V.isOverdefined())
@@ -1213,9 +1230,9 @@ getValueFromConditionImpl(Value *Val, Value *Cond, bool isTrueDest,
   if (LV == Visited.end() || RV == Visited.end()) {
     assert(!isRevisit);
     if (LV == Visited.end())
-      Worklist.push_back(L);
+      Worklist.push_back(CondValue(L, isTrueDest));
     if (RV == Visited.end())
-      Worklist.push_back(R);
+      Worklist.push_back(CondValue(R, isTrueDest));
     return None;
   }
 
@@ -1225,12 +1242,13 @@ getValueFromConditionImpl(Value *Val, Value *Cond, bool isTrueDest,
 ValueLatticeElement getValueFromCondition(Value *Val, Value *Cond,
                                           bool isTrueDest) {
   assert(Cond && "precondition");
-  SmallDenseMap<Value*, ValueLatticeElement> Visited;
-  SmallVector<Value *> Worklist;
+  SmallDenseMap<CondValue, ValueLatticeElement> Visited;
+  SmallVector<CondValue> Worklist;
 
-  Worklist.push_back(Cond);
+  CondValue CondKey(Cond, isTrueDest);
+  Worklist.push_back(CondKey);
   do {
-    Value *CurrentCond = Worklist.back();
+    CondValue CurrentCond = Worklist.back();
     // Insert an Overdefined placeholder into the set to prevent
     // infinite recursion if there exists IRs that use not
     // dominated by its def as in this example:
@@ -1240,14 +1258,14 @@ ValueLatticeElement getValueFromCondition(Value *Val, Value *Cond,
         Visited.try_emplace(CurrentCond, ValueLatticeElement::getOverdefined());
     bool isRevisit = !Iter.second;
     Optional<ValueLatticeElement> Result = getValueFromConditionImpl(
-        Val, CurrentCond, isTrueDest, isRevisit, Visited, Worklist);
+        Val, CurrentCond, isRevisit, Visited, Worklist);
     if (Result) {
       Visited[CurrentCond] = *Result;
       Worklist.pop_back();
     }
   } while (!Worklist.empty());
 
-  auto Result = Visited.find(Cond);
+  auto Result = Visited.find(CondKey);
   assert(Result != Visited.end());
   return Result->second;
 }
diff --git a/llvm/lib/CodeGen/CodeGenPrepare.cpp b/llvm/lib/CodeGen/CodeGenPrepare.cpp
index c888adeafca5d..328412821f20d 100644
--- a/llvm/lib/CodeGen/CodeGenPrepare.cpp
+++ b/llvm/lib/CodeGen/CodeGenPrepare.cpp
@@ -5205,18 +5205,29 @@ bool CodeGenPrepare::optimizeMemoryInst(Instruction *MemoryInst, Value *Addr,
   WeakTrackingVH SunkAddrVH = SunkAddrs[Addr];
 
   Value * SunkAddr = SunkAddrVH.pointsToAliveValue() ? SunkAddrVH : nullptr;
+  Type *IntPtrTy = DL->getIntPtrType(Addr->getType());
   if (SunkAddr) {
     LLVM_DEBUG(dbgs() << "CGP: Reusing nonlocal addrmode: " << AddrMode
                       << " for " << *MemoryInst << "\n");
-    if (SunkAddr->getType() != Addr->getType())
-      SunkAddr = Builder.CreatePointerCast(SunkAddr, Addr->getType());
+    if (SunkAddr->getType() != Addr->getType()) {
+      // Even though we only considered no-op addrspacecasts,
+      // semantically-meaningful conversions may still be present due to
+      // ptrtoint/inttoptr sequences.
+      if (SunkAddr->getType()->getPointerAddressSpace() !=
+              Addr->getType()->getPointerAddressSpace() &&
+          !DL->isNonIntegralPointerType(Addr->getType())) {
+        SunkAddr = Builder.CreatePtrToInt(SunkAddr, IntPtrTy, "sunkaddr");
+        SunkAddr =
+            Builder.CreateIntToPtr(SunkAddr, Addr->getType(), "sunkaddr");
+      } else
+        SunkAddr = Builder.CreatePointerCast(SunkAddr, Addr->getType());
+    }
   } else if (AddrSinkUsingGEPs || (!AddrSinkUsingGEPs.getNumOccurrences() &&
                                    SubtargetInfo->addrSinkUsingGEPs())) {
     // By default, we use the GEP-based method when AA is used later. This
     // prevents new inttoptr/ptrtoint pairs from degrading AA capabilities.
     LLVM_DEBUG(dbgs() << "CGP: SINKING nonlocal addrmode: " << AddrMode
                       << " for " << *MemoryInst << "\n");
-    Type *IntPtrTy = DL->getIntPtrType(Addr->getType());
     Value *ResultPtr = nullptr, *ResultIndex = nullptr;
 
     // First, find the pointer.
@@ -5345,8 +5356,19 @@ bool CodeGenPrepare::optimizeMemoryInst(Instruction *MemoryInst, Value *Addr,
                 : Builder.CreateGEP(I8Ty, ResultPtr, ResultIndex, "sunkaddr");
       }
 
-      if (SunkAddr->getType() != Addr->getType())
-        SunkAddr = Builder.CreatePointerCast(SunkAddr, Addr->getType());
+      if (SunkAddr->getType() != Addr->getType()) {
+        // Even though we only considered no-op addrspacecasts,
+        // semantically-meaningful conversions may still be present due to
+        // ptrtoint/inttoptr sequences.
+        if (SunkAddr->getType()->getPointerAddressSpace() !=
+                Addr->getType()->getPointerAddressSpace() &&
+            !DL->isNonIntegralPointerType(Addr->getType())) {
+          SunkAddr = Builder.CreatePtrToInt(SunkAddr, IntPtrTy, "sunkaddr");
+          SunkAddr =
+              Builder.CreateIntToPtr(SunkAddr, Addr->getType(), "sunkaddr");
+        } else
+          SunkAddr = Builder.CreatePointerCast(SunkAddr, Addr->getType());
+      }
     }
   } else {
     // We'd require a ptrtoint/inttoptr down the line, which we can't do for
diff --git a/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp b/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
index ec297579090ef..b4ab70d215223 100644
--- a/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
+++ b/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
@@ -22989,6 +22989,7 @@ bool DAGCombiner::SimplifySelectOps(SDNode *TheSelect, SDValue LHS,
         !TLI.isOperationLegalOrCustom(TheSelect->getOpcode(),
                                       LLD->getBasePtr().getValueType()))
       return false;
+    return false;
 
     // The loads must not depend on one another.
     if (LLD->isPredecessorOf(RLD) || RLD->isPredecessorOf(LLD))
diff --git a/llvm/lib/MC/MCObjectFileInfo.cpp b/llvm/lib/MC/MCObjectFileInfo.cpp
index b7890e7f0937b..e13fcba436083 100644
--- a/llvm/lib/MC/MCObjectFileInfo.cpp
+++ b/llvm/lib/MC/MCObjectFileInfo.cpp
@@ -58,9 +58,10 @@ void MCObjectFileInfo::initMachOMCObjectFileInfo(const Triple &T) {
           MachO::S_ATTR_STRIP_STATIC_SYMS | MachO::S_ATTR_LIVE_SUPPORT,
       SectionKind::getReadOnly());
 
-  if (T.isOSDarwin() &&
-      (T.getArch() == Triple::aarch64 || T.getArch() == Triple::aarch64_32))
-    SupportsCompactUnwindWithoutEHFrame = true;
+  // Disabled for now, since we need to emit EH Frames for stack unwinding in the JIT
+  // if (T.isOSDarwin() &&
+  //     (T.getArch() == Triple::aarch64 || T.getArch() == Triple::aarch64_32))
+  //   SupportsCompactUnwindWithoutEHFrame = true;
 
   if (T.isWatchABI())
     OmitDwarfIfHaveCompactUnwind = true;
diff --git a/llvm/lib/MC/WinCOFFObjectWriter.cpp b/llvm/lib/MC/WinCOFFObjectWriter.cpp
index aba2ad3155356..e2de61cd02640 100644
--- a/llvm/lib/MC/WinCOFFObjectWriter.cpp
+++ b/llvm/lib/MC/WinCOFFObjectWriter.cpp
@@ -172,6 +172,7 @@ class WinCOFFObjectWriter : public MCObjectWriter {
     Strings.clear();
     SectionMap.clear();
     SymbolMap.clear();
+    WeakDefaults.clear();
     MCObjectWriter::reset();
   }
 
@@ -686,14 +687,12 @@ void WinCOFFObjectWriter::executePostLayoutBinding(MCAssembler &Asm,
 bool WinCOFFObjectWriter::isSymbolRefDifferenceFullyResolvedImpl(
     const MCAssembler &Asm, const MCSymbol &SymA, const MCFragment &FB,
     bool InSet, bool IsPCRel) const {
-  // Don't drop relocations between functions, even if they are in the same text
-  // section. Multiple Visual C++ linker features depend on having the
-  // relocations present. The /INCREMENTAL flag will cause these relocations to
-  // point to thunks, and the /GUARD:CF flag assumes that it can use relocations
-  // to approximate the set of all address taken functions. LLD's implementation
-  // of /GUARD:CF also relies on the existance of these relocations.
+  // MS LINK expects to be able to replace all references to a function with a
+  // thunk to implement their /INCREMENTAL feature.  Make sure we don't optimize
+  // away any relocations to functions.
   uint16_t Type = cast<MCSymbolCOFF>(SymA).getType();
-  if ((Type >> COFF::SCT_COMPLEX_TYPE_SHIFT) == COFF::IMAGE_SYM_DTYPE_FUNCTION)
+  if (Asm.isIncrementalLinkerCompatible() &&
+      (Type >> COFF::SCT_COMPLEX_TYPE_SHIFT) == COFF::IMAGE_SYM_DTYPE_FUNCTION)
     return false;
   return MCObjectWriter::isSymbolRefDifferenceFullyResolvedImpl(Asm, SymA, FB,
                                                                 InSet, IsPCRel);
diff --git a/llvm/lib/Passes/StandardInstrumentations.cpp b/llvm/lib/Passes/StandardInstrumentations.cpp
index c42b1cb26f138..8482eae1cc4b2 100644
--- a/llvm/lib/Passes/StandardInstrumentations.cpp
+++ b/llvm/lib/Passes/StandardInstrumentations.cpp
@@ -811,8 +811,7 @@ void PrintIRInstrumentation::printAfterPass(StringRef PassID, Any IR) {
 }
 
 void PrintIRInstrumentation::printAfterPassInvalidated(StringRef PassID) {
-  StringRef PassName = PIC->getPassNameForClassName(PassID);
-  if (!shouldPrintAfterPass(PassName))
+  if (!shouldPrintAfterPass(PassID))
     return;
 
   if (isIgnored(PassID))
diff --git a/llvm/lib/Target/AArch64/AArch64FastISel.cpp b/llvm/lib/Target/AArch64/AArch64FastISel.cpp
index dc5e6807945d7..a80c08b94948e 100644
--- a/llvm/lib/Target/AArch64/AArch64FastISel.cpp
+++ b/llvm/lib/Target/AArch64/AArch64FastISel.cpp
@@ -4504,23 +4504,6 @@ bool AArch64FastISel::selectIntExt(const Instruction *I) {
 
   // Try to optimize already sign-/zero-extended values from function arguments.
   bool IsZExt = isa<ZExtInst>(I);
-  if (const auto *Arg = dyn_cast<Argument>(I->getOperand(0))) {
-    if ((IsZExt && Arg->hasZExtAttr()) || (!IsZExt && Arg->hasSExtAttr())) {
-      if (RetVT == MVT::i64 && SrcVT != MVT::i64) {
-        Register ResultReg = createResultReg(&AArch64::GPR64RegClass);
-        BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
-                TII.get(AArch64::SUBREG_TO_REG), ResultReg)
-            .addImm(0)
-            .addReg(SrcReg)
-            .addImm(AArch64::sub_32);
-        SrcReg = ResultReg;
-      }
-
-      updateValueMap(I, SrcReg);
-      return true;
-    }
-  }
-
   unsigned ResultReg = emitIntExt(SrcVT, SrcReg, RetVT, IsZExt);
   if (!ResultReg)
     return false;
diff --git a/llvm/lib/Target/PowerPC/CMakeLists.txt b/llvm/lib/Target/PowerPC/CMakeLists.txt
index 195eebf30862e..3273fb720c7ae 100644
--- a/llvm/lib/Target/PowerPC/CMakeLists.txt
+++ b/llvm/lib/Target/PowerPC/CMakeLists.txt
@@ -27,6 +27,7 @@ add_llvm_target(PowerPCCodeGen
   PPCCallingConv.cpp
   PPCCCState.cpp
   PPCCTRLoops.cpp
+  PPCCTRLoopsVerify.cpp
   PPCExpandAtomicPseudoInsts.cpp
   PPCHazardRecognizers.cpp
   PPCInstrInfo.cpp
diff --git a/llvm/lib/Target/PowerPC/PPC.h b/llvm/lib/Target/PowerPC/PPC.h
index 7235a878e38bd..0a16455105f3e 100644
--- a/llvm/lib/Target/PowerPC/PPC.h
+++ b/llvm/lib/Target/PowerPC/PPC.h
@@ -33,7 +33,6 @@ class MCInst;
 class MCOperand;
 class ModulePass;
 
-FunctionPass *createPPCCTRLoops();
 #ifndef NDEBUG
   FunctionPass *createPPCCTRLoopsVerify();
 #endif
@@ -53,12 +52,12 @@ FunctionPass *createPPCCTRLoops();
   FunctionPass *createPPCExpandISELPass();
   FunctionPass *createPPCPreEmitPeepholePass();
   FunctionPass *createPPCExpandAtomicPseudoPass();
+  FunctionPass *createPPCCTRLoopsPass();
   void LowerPPCMachineInstrToMCInst(const MachineInstr *MI, MCInst &OutMI,
                                     AsmPrinter &AP);
   bool LowerPPCMachineOperandToMCOperand(const MachineOperand &MO,
                                          MCOperand &OutMO, AsmPrinter &AP);
 
-  void initializePPCCTRLoopsPass(PassRegistry&);
 #ifndef NDEBUG
   void initializePPCCTRLoopsVerifyPass(PassRegistry&);
 #endif
@@ -77,6 +76,7 @@ FunctionPass *createPPCCTRLoops();
   void initializePPCTLSDynamicCallPass(PassRegistry &);
   void initializePPCMIPeepholePass(PassRegistry&);
   void initializePPCExpandAtomicPseudoPass(PassRegistry &);
+  void initializePPCCTRLoopsPass(PassRegistry &);
 
   extern char &PPCVSXFMAMutateID;
 
diff --git a/llvm/lib/Target/PowerPC/PPCCTRLoops.cpp b/llvm/lib/Target/PowerPC/PPCCTRLoops.cpp
index b1f5bdd885cd4..cb0519c8fe7bb 100644
--- a/llvm/lib/Target/PowerPC/PPCCTRLoops.cpp
+++ b/llvm/lib/Target/PowerPC/PPCCTRLoops.cpp
@@ -1,4 +1,4 @@
-//===-- PPCCTRLoops.cpp - Verify CTR loops -----------------===//
+//===-- PPCCTRLoops.cpp - Generate CTR loops ------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,31 +6,38 @@
 //
 //===----------------------------------------------------------------------===//
 //
-// This pass verifies that all bdnz/bdz instructions are dominated by a loop
-// mtctr before any other instructions that might clobber the ctr register.
+// This pass generates machine instructions for the CTR loops related pseudos:
+// 1: MTCTRloop/DecreaseCTRloop
+// 2: MTCTR8loop/DecreaseCTR8loop
+//
+// If a CTR loop can be generated:
+// 1: MTCTRloop/MTCTR8loop will be converted to "mtctr"
+// 2: DecreaseCTRloop/DecreaseCTR8loop will be converted to "bdnz/bdz" and
+//    its user branch instruction can be deleted.
+//
+// If a CTR loop can not be generated due to clobber of CTR:
+// 1: MTCTRloop/MTCTR8loop can be deleted.
+// 2: DecreaseCTRloop/DecreaseCTR8loop will be converted to "addi -1" and
+//    a "cmplwi/cmpldi".
+//
+// This pass runs just before register allocation, because we don't want
+// register allocator to allocate register for DecreaseCTRloop if a CTR can be
+// generated or if a CTR loop can not be generated, we don't have any condition
+// register for the new added "cmplwi/cmpldi".
 //
 //===----------------------------------------------------------------------===//
 
-// CTR loops are produced by the HardwareLoops pass and this pass is simply a
-// verification that no invalid CTR loops are produced. As such, it isn't
-// something that needs to be run (or even defined) for Release builds so the
-// entire file is guarded by NDEBUG.
-#ifndef NDEBUG
-#include <vector>
-
-#include "MCTargetDesc/PPCMCTargetDesc.h"
 #include "PPC.h"
-#include "llvm/ADT/SmallSet.h"
-#include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/ilist_iterator.h"
+#include "PPCInstrInfo.h"
+#include "PPCSubtarget.h"
+#include "llvm/ADT/Statistic.h"
 #include "llvm/CodeGen/MachineBasicBlock.h"
-#include "llvm/CodeGen/MachineDominators.h"
 #include "llvm/CodeGen/MachineFunction.h"
 #include "llvm/CodeGen/MachineFunctionPass.h"
 #include "llvm/CodeGen/MachineInstr.h"
-#include "llvm/CodeGen/MachineInstrBundleIterator.h"
+#include "llvm/CodeGen/MachineLoopInfo.h"
 #include "llvm/CodeGen/MachineOperand.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
 #include "llvm/CodeGen/Register.h"
 #include "llvm/InitializePasses.h"
 #include "llvm/Pass.h"
@@ -38,148 +45,307 @@
 #include "llvm/Support/CodeGen.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/GenericDomTreeConstruction.h"
-#include "llvm/Support/Printable.h"
-#include "llvm/Support/raw_ostream.h"
+#include <cassert>
 
 using namespace llvm;
 
-#define DEBUG_TYPE "ppc-ctrloops-verify"
+#define DEBUG_TYPE "ppc-ctrloops"
+
+STATISTIC(NumCTRLoops, "Number of CTR loops generated");
+STATISTIC(NumNormalLoops, "Number of normal compare + branch loops generated");
 
 namespace {
+class PPCCTRLoops : public MachineFunctionPass {
+public:
+  static char ID;
 
-  struct PPCCTRLoopsVerify : public MachineFunctionPass {
-  public:
-    static char ID;
+  PPCCTRLoops() : MachineFunctionPass(ID) {
+    initializePPCCTRLoopsPass(*PassRegistry::getPassRegistry());
+  }
 
-    PPCCTRLoopsVerify() : MachineFunctionPass(ID) {
-      initializePPCCTRLoopsVerifyPass(*PassRegistry::getPassRegistry());
-    }
+  void getAnalysisUsage(AnalysisUsage &AU) const override {
+    AU.addRequired<MachineLoopInfo>();
+    MachineFunctionPass::getAnalysisUsage(AU);
+  }
 
-    void getAnalysisUsage(AnalysisUsage &AU) const override {
-      AU.addRequired<MachineDominatorTree>();
-      MachineFunctionPass::getAnalysisUsage(AU);
-    }
+  bool runOnMachineFunction(MachineFunction &MF) override;
 
-    bool runOnMachineFunction(MachineFunction &MF) override;
+private:
+  const PPCInstrInfo *TII = nullptr;
+  MachineRegisterInfo *MRI = nullptr;
 
-  private:
-    MachineDominatorTree *MDT;
-  };
+  bool processLoop(MachineLoop *ML);
+  bool isCTRClobber(MachineInstr *MI, bool CheckReads) const;
+  void expandNormalLoops(MachineLoop *ML, MachineInstr *Start,
+                         MachineInstr *Dec);
+  void expandCTRLoops(MachineLoop *ML, MachineInstr *Start, MachineInstr *Dec);
+};
+} // namespace
+
+char PPCCTRLoops::ID = 0;
+
+INITIALIZE_PASS_BEGIN(PPCCTRLoops, DEBUG_TYPE, "PowerPC CTR loops generation",
+                      false, false)
+INITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)
+INITIALIZE_PASS_END(PPCCTRLoops, DEBUG_TYPE, "PowerPC CTR loops generation",
+                    false, false)
 
-  char PPCCTRLoopsVerify::ID = 0;
-} // end anonymous namespace
+FunctionPass *llvm::createPPCCTRLoopsPass() { return new PPCCTRLoops(); }
 
-INITIALIZE_PASS_BEGIN(PPCCTRLoopsVerify, "ppc-ctr-loops-verify",
-                      "PowerPC CTR Loops Verify", false, false)
-INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)
-INITIALIZE_PASS_END(PPCCTRLoopsVerify, "ppc-ctr-loops-verify",
-                    "PowerPC CTR Loops Verify", false, false)
+bool PPCCTRLoops::runOnMachineFunction(MachineFunction &MF) {
+  bool Changed = false;
 
-FunctionPass *llvm::createPPCCTRLoopsVerify() {
-  return new PPCCTRLoopsVerify();
+  auto &MLI = getAnalysis<MachineLoopInfo>();
+  TII = static_cast<const PPCInstrInfo *>(MF.getSubtarget().getInstrInfo());
+  MRI = &MF.getRegInfo();
+
+  for (auto ML : MLI) {
+    if (ML->isOutermost())
+      Changed |= processLoop(ML);
+  }
+
+  return Changed;
 }
 
-static bool clobbersCTR(const MachineInstr &MI) {
-  for (const MachineOperand &MO : MI.operands()) {
-    if (MO.isReg()) {
-      if (MO.isDef() && (MO.getReg() == PPC::CTR || MO.getReg() == PPC::CTR8))
-        return true;
-    } else if (MO.isRegMask()) {
-      if (MO.clobbersPhysReg(PPC::CTR) || MO.clobbersPhysReg(PPC::CTR8))
-        return true;
-    }
+bool PPCCTRLoops::isCTRClobber(MachineInstr *MI, bool CheckReads) const {
+  if (!CheckReads) {
+    // If we are only checking for defs, that is we are going to find
+    // definitions before MTCTRloop, for this case:
+    // CTR defination inside the callee of a call instruction will not impact
+    // the defination of MTCTRloop, so we can use definesRegister() for the
+    // check, no need to check the regmask.
+    return (MI->definesRegister(PPC::CTR) &&
+            !MI->registerDefIsDead(PPC::CTR)) ||
+           (MI->definesRegister(PPC::CTR8) &&
+            !MI->registerDefIsDead(PPC::CTR8));
   }
 
+  if ((MI->modifiesRegister(PPC::CTR) && !MI->registerDefIsDead(PPC::CTR)) ||
+      (MI->modifiesRegister(PPC::CTR8) && !MI->registerDefIsDead(PPC::CTR8)))
+    return true;
+
+  if (MI->getDesc().isCall())
+    return true;
+
+  // We define the CTR in the loop preheader, so if there is any CTR reader in
+  // the loop, we also can not use CTR loop form.
+  if (MI->readsRegister(PPC::CTR) || MI->readsRegister(PPC::CTR8))
+    return true;
+
   return false;
 }
 
-static bool verifyCTRBranch(MachineBasicBlock *MBB,
-                            MachineBasicBlock::iterator I) {
-  MachineBasicBlock::iterator BI = I;
-  SmallSet<MachineBasicBlock *, 16>   Visited;
-  SmallVector<MachineBasicBlock *, 8> Preds;
-  bool CheckPreds;
-
-  if (I == MBB->begin()) {
-    Visited.insert(MBB);
-    goto queue_preds;
-  } else
-    --I;
-
-check_block:
-  Visited.insert(MBB);
-  if (I == MBB->end())
-    goto queue_preds;
-
-  CheckPreds = true;
-  for (MachineBasicBlock::iterator IE = MBB->begin();; --I) {
-    unsigned Opc = I->getOpcode();
-    if (Opc == PPC::MTCTRloop || Opc == PPC::MTCTR8loop) {
-      CheckPreds = false;
+bool PPCCTRLoops::processLoop(MachineLoop *ML) {
+  bool Changed = false;
+
+  // Align with HardwareLoop pass, process inner loops first.
+  for (auto I = ML->begin(), E = ML->end(); I != E; ++I)
+    Changed |= processLoop(*I);
+
+  // If any inner loop is changed, outter loop must be without hardware loop
+  // intrinsics.
+  if (Changed)
+    return true;
+
+  auto IsLoopStart = [](MachineInstr &MI) {
+    return MI.getOpcode() == PPC::MTCTRloop ||
+           MI.getOpcode() == PPC::MTCTR8loop;
+  };
+
+  auto SearchForStart =
+      [&IsLoopStart](MachineBasicBlock *MBB) -> MachineInstr * {
+    for (auto &MI : *MBB) {
+      if (IsLoopStart(MI))
+        return &MI;
+    }
+    return nullptr;
+  };
+
+  MachineInstr *Start = nullptr;
+  MachineInstr *Dec = nullptr;
+  bool InvalidCTRLoop = false;
+
+  MachineBasicBlock *Preheader = ML->getLoopPreheader();
+  // If there is no preheader for this loop, there must be no MTCTRloop
+  // either.
+  if (!Preheader)
+    return false;
+
+  Start = SearchForStart(Preheader);
+  // This is not a CTR loop candidate.
+  if (!Start)
+    return false;
+
+  // If CTR is live to the preheader, we can not redefine the CTR register.
+  if (Preheader->isLiveIn(PPC::CTR) || Preheader->isLiveIn(PPC::CTR8))
+    InvalidCTRLoop = true;
+
+  // Make sure there is also no CTR clobber in the block preheader between the
+  // begin and MTCTR.
+  for (MachineBasicBlock::reverse_instr_iterator I =
+           std::next(Start->getReverseIterator());
+       I != Preheader->instr_rend(); ++I)
+    // Only check the definitions of CTR. If there is non-dead definition for
+    // the CTR, we conservatively don't generate a CTR loop.
+    if (isCTRClobber(&*I, /* CheckReads */ false)) {
+      InvalidCTRLoop = true;
       break;
     }
 
-    if (I != BI && clobbersCTR(*I)) {
-      LLVM_DEBUG(dbgs() << printMBBReference(*MBB) << " (" << MBB->getFullName()
-                        << ") instruction " << *I
-                        << " clobbers CTR, invalidating "
-                        << printMBBReference(*BI->getParent()) << " ("
-                        << BI->getParent()->getFullName() << ") instruction "
-                        << *BI << "\n");
-      return false;
+  // Make sure there is also no CTR clobber/user in the block preheader between
+  // MTCTR and the end.
+  for (MachineBasicBlock::instr_iterator I = std::next(Start->getIterator());
+       I != Preheader->instr_end(); ++I)
+    if (isCTRClobber(&*I, /* CheckReads */ true)) {
+      InvalidCTRLoop = true;
+      break;
     }
 
-    if (I == IE)
+  // Find the CTR loop components and decide whether or not to fall back to a
+  // normal loop.
+  for (auto *MBB : reverse(ML->getBlocks())) {
+    for (auto &MI : *MBB) {
+      if (MI.getOpcode() == PPC::DecreaseCTRloop ||
+          MI.getOpcode() == PPC::DecreaseCTR8loop)
+        Dec = &MI;
+      else if (!InvalidCTRLoop)
+        // If any instruction clobber CTR, then we can not generate a CTR loop.
+        InvalidCTRLoop |= isCTRClobber(&MI, /* CheckReads */ true);
+    }
+    if (Dec && InvalidCTRLoop)
       break;
   }
 
-  if (!CheckPreds && Preds.empty())
-    return true;
-
-  if (CheckPreds) {
-queue_preds:
-    if (MachineFunction::iterator(MBB) == MBB->getParent()->begin()) {
-      LLVM_DEBUG(dbgs() << "Unable to find a MTCTR instruction for "
-                        << printMBBReference(*BI->getParent()) << " ("
-                        << BI->getParent()->getFullName() << ") instruction "
-                        << *BI << "\n");
-      return false;
-    }
+  assert(Dec && "CTR loop is not complete!");
 
-    append_range(Preds, MBB->predecessors());
+  if (InvalidCTRLoop) {
+    expandNormalLoops(ML, Start, Dec);
+    ++NumNormalLoops;
+  }
+  else {
+    expandCTRLoops(ML, Start, Dec);
+    ++NumCTRLoops;
   }
+  return true;
+}
+
+void PPCCTRLoops::expandNormalLoops(MachineLoop *ML, MachineInstr *Start,
+                                    MachineInstr *Dec) {
+  bool Is64Bit =
+      Start->getParent()->getParent()->getSubtarget<PPCSubtarget>().isPPC64();
+
+  MachineBasicBlock *Preheader = Start->getParent();
+  MachineBasicBlock *Exiting = Dec->getParent();
+  assert((Preheader && Exiting) &&
+         "Preheader and exiting should exist for CTR loop!");
+
+  assert(Dec->getOperand(1).getImm() == 1 &&
+         "Loop decrement stride must be 1");
+
+  unsigned ADDIOpcode = Is64Bit ? PPC::ADDI8 : PPC::ADDI;
+  unsigned CMPOpcode = Is64Bit ? PPC::CMPLDI : PPC::CMPLWI;
 
-  do {
-    MBB = Preds.pop_back_val();
-    if (!Visited.count(MBB)) {
-      I = MBB->getLastNonDebugInstr();
-      goto check_block;
+  Register PHIDef =
+      MRI->createVirtualRegister(Is64Bit ? &PPC::G8RC_and_G8RC_NOX0RegClass
+                                         : &PPC::GPRC_and_GPRC_NOR0RegClass);
+
+  Start->getParent()->getParent()->getProperties().reset(
+      MachineFunctionProperties::Property::NoPHIs);
+
+  // Generate "PHI" in the header block.
+  auto PHIMIB = BuildMI(*ML->getHeader(), ML->getHeader()->getFirstNonPHI(),
+                        DebugLoc(), TII->get(TargetOpcode::PHI), PHIDef);
+  PHIMIB.addReg(Start->getOperand(0).getReg()).addMBB(Preheader);
+
+  Register ADDIDef =
+      MRI->createVirtualRegister(Is64Bit ? &PPC::G8RC_and_G8RC_NOX0RegClass
+                                         : &PPC::GPRC_and_GPRC_NOR0RegClass);
+  // Generate "addi -1" in the exiting block.
+  BuildMI(*Exiting, Dec, Dec->getDebugLoc(), TII->get(ADDIOpcode), ADDIDef)
+      .addReg(PHIDef)
+      .addImm(-1);
+
+  // Add other inputs for the PHI node.
+  if (ML->isLoopLatch(Exiting)) {
+    // There must be only two predecessors for the loop header, one is the
+    // Preheader and the other one is loop latch Exiting. In hardware loop
+    // insertion pass, the block containing DecreaseCTRloop must dominate all
+    // loop latches. So there must be only one latch.
+    assert(ML->getHeader()->pred_size() == 2 &&
+           "Loop header predecessor is not right!");
+    PHIMIB.addReg(ADDIDef).addMBB(Exiting);
+  } else {
+    // If the block containing DecreaseCTRloop is not a loop latch, we can use
+    // ADDIDef as the value for all other blocks for the PHI. In hardware loop
+    // insertion pass, the block containing DecreaseCTRloop must dominate all
+    // loop latches.
+    for (MachineBasicBlock *P : ML->getHeader()->predecessors()) {
+      if (ML->contains(P)) {
+        assert(ML->isLoopLatch(P) &&
+               "Loop's header in-loop predecessor is not loop latch!");
+        PHIMIB.addReg(ADDIDef).addMBB(P);
+      } else
+        assert(P == Preheader &&
+               "CTR loop should not be generated for irreducible loop!");
     }
-  } while (!Preds.empty());
+  }
 
-  return true;
+  // Generate the compare in the exiting block.
+  Register CMPDef = MRI->createVirtualRegister(&PPC::CRRCRegClass);
+  auto CMPMIB =
+      BuildMI(*Exiting, Dec, Dec->getDebugLoc(), TII->get(CMPOpcode), CMPDef)
+          .addReg(ADDIDef)
+          .addImm(0);
+
+  BuildMI(*Exiting, Dec, Dec->getDebugLoc(), TII->get(TargetOpcode::COPY),
+          Dec->getOperand(0).getReg())
+      .addReg(CMPMIB->getOperand(0).getReg(), 0, PPC::sub_gt);
+
+  // Remove the pseudo instructions.
+  Start->eraseFromParent();
+  Dec->eraseFromParent();
 }
 
-bool PPCCTRLoopsVerify::runOnMachineFunction(MachineFunction &MF) {
-  MDT = &getAnalysis<MachineDominatorTree>();
-
-  // Verify that all bdnz/bdz instructions are dominated by a loop mtctr before
-  // any other instructions that might clobber the ctr register.
-  for (MachineBasicBlock &MBB : MF) {
-    if (!MDT->isReachableFromEntry(&MBB))
-      continue;
-
-    for (MachineBasicBlock::iterator MII = MBB.getFirstTerminator(),
-      MIIE = MBB.end(); MII != MIIE; ++MII) {
-      unsigned Opc = MII->getOpcode();
-      if (Opc == PPC::BDNZ8 || Opc == PPC::BDNZ ||
-          Opc == PPC::BDZ8  || Opc == PPC::BDZ)
-        if (!verifyCTRBranch(&MBB, MII))
-          llvm_unreachable("Invalid PPC CTR loop!");
-    }
+void PPCCTRLoops::expandCTRLoops(MachineLoop *ML, MachineInstr *Start,
+                                 MachineInstr *Dec) {
+  bool Is64Bit =
+      Start->getParent()->getParent()->getSubtarget<PPCSubtarget>().isPPC64();
+
+  MachineBasicBlock *Preheader = Start->getParent();
+  MachineBasicBlock *Exiting = Dec->getParent();
+  assert((Preheader && Exiting) &&
+         "Preheader and exiting should exist for CTR loop!");
+
+  assert(Dec->getOperand(1).getImm() == 1 && "Loop decrement must be 1!");
+
+  unsigned BDNZOpcode = Is64Bit ? PPC::BDNZ8 : PPC::BDNZ;
+  unsigned BDZOpcode = Is64Bit ? PPC::BDZ8 : PPC::BDZ;
+  auto BrInstr = MRI->use_instr_begin(Dec->getOperand(0).getReg());
+  assert(MRI->hasOneUse(Dec->getOperand(0).getReg()) &&
+         "There should be only one user for loop decrement pseudo!");
+
+  unsigned Opcode = 0;
+  switch (BrInstr->getOpcode()) {
+  case PPC::BC:
+    Opcode = BDNZOpcode;
+    (void) ML;
+    assert(ML->contains(BrInstr->getOperand(1).getMBB()) &&
+           "Invalid ctr loop!");
+    break;
+  case PPC::BCn:
+    Opcode = BDZOpcode;
+    assert(!ML->contains(BrInstr->getOperand(1).getMBB()) &&
+           "Invalid ctr loop!");
+    break;
+  default:
+    llvm_unreachable("Unhandled branch user for DecreaseCTRloop.");
   }
 
-  return false;
+  // Generate "bdnz/bdz" in the exiting block just before the terminator.
+  BuildMI(*Exiting, &*BrInstr, BrInstr->getDebugLoc(), TII->get(Opcode))
+      .addMBB(BrInstr->getOperand(1).getMBB());
+
+  // Remove the pseudo instructions.
+  BrInstr->eraseFromParent();
+  Dec->eraseFromParent();
 }
-#endif // NDEBUG
diff --git a/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp b/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp
new file mode 100644
index 0000000000000..b1f5bdd885cd4
--- /dev/null
+++ b/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp
@@ -0,0 +1,185 @@
+//===-- PPCCTRLoops.cpp - Verify CTR loops -----------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass verifies that all bdnz/bdz instructions are dominated by a loop
+// mtctr before any other instructions that might clobber the ctr register.
+//
+//===----------------------------------------------------------------------===//
+
+// CTR loops are produced by the HardwareLoops pass and this pass is simply a
+// verification that no invalid CTR loops are produced. As such, it isn't
+// something that needs to be run (or even defined) for Release builds so the
+// entire file is guarded by NDEBUG.
+#ifndef NDEBUG
+#include <vector>
+
+#include "MCTargetDesc/PPCMCTargetDesc.h"
+#include "PPC.h"
+#include "llvm/ADT/SmallSet.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/ilist_iterator.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/MachineDominators.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/CodeGen/MachineInstrBundleIterator.h"
+#include "llvm/CodeGen/MachineOperand.h"
+#include "llvm/CodeGen/Register.h"
+#include "llvm/InitializePasses.h"
+#include "llvm/Pass.h"
+#include "llvm/PassRegistry.h"
+#include "llvm/Support/CodeGen.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/GenericDomTreeConstruction.h"
+#include "llvm/Support/Printable.h"
+#include "llvm/Support/raw_ostream.h"
+
+using namespace llvm;
+
+#define DEBUG_TYPE "ppc-ctrloops-verify"
+
+namespace {
+
+  struct PPCCTRLoopsVerify : public MachineFunctionPass {
+  public:
+    static char ID;
+
+    PPCCTRLoopsVerify() : MachineFunctionPass(ID) {
+      initializePPCCTRLoopsVerifyPass(*PassRegistry::getPassRegistry());
+    }
+
+    void getAnalysisUsage(AnalysisUsage &AU) const override {
+      AU.addRequired<MachineDominatorTree>();
+      MachineFunctionPass::getAnalysisUsage(AU);
+    }
+
+    bool runOnMachineFunction(MachineFunction &MF) override;
+
+  private:
+    MachineDominatorTree *MDT;
+  };
+
+  char PPCCTRLoopsVerify::ID = 0;
+} // end anonymous namespace
+
+INITIALIZE_PASS_BEGIN(PPCCTRLoopsVerify, "ppc-ctr-loops-verify",
+                      "PowerPC CTR Loops Verify", false, false)
+INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)
+INITIALIZE_PASS_END(PPCCTRLoopsVerify, "ppc-ctr-loops-verify",
+                    "PowerPC CTR Loops Verify", false, false)
+
+FunctionPass *llvm::createPPCCTRLoopsVerify() {
+  return new PPCCTRLoopsVerify();
+}
+
+static bool clobbersCTR(const MachineInstr &MI) {
+  for (const MachineOperand &MO : MI.operands()) {
+    if (MO.isReg()) {
+      if (MO.isDef() && (MO.getReg() == PPC::CTR || MO.getReg() == PPC::CTR8))
+        return true;
+    } else if (MO.isRegMask()) {
+      if (MO.clobbersPhysReg(PPC::CTR) || MO.clobbersPhysReg(PPC::CTR8))
+        return true;
+    }
+  }
+
+  return false;
+}
+
+static bool verifyCTRBranch(MachineBasicBlock *MBB,
+                            MachineBasicBlock::iterator I) {
+  MachineBasicBlock::iterator BI = I;
+  SmallSet<MachineBasicBlock *, 16>   Visited;
+  SmallVector<MachineBasicBlock *, 8> Preds;
+  bool CheckPreds;
+
+  if (I == MBB->begin()) {
+    Visited.insert(MBB);
+    goto queue_preds;
+  } else
+    --I;
+
+check_block:
+  Visited.insert(MBB);
+  if (I == MBB->end())
+    goto queue_preds;
+
+  CheckPreds = true;
+  for (MachineBasicBlock::iterator IE = MBB->begin();; --I) {
+    unsigned Opc = I->getOpcode();
+    if (Opc == PPC::MTCTRloop || Opc == PPC::MTCTR8loop) {
+      CheckPreds = false;
+      break;
+    }
+
+    if (I != BI && clobbersCTR(*I)) {
+      LLVM_DEBUG(dbgs() << printMBBReference(*MBB) << " (" << MBB->getFullName()
+                        << ") instruction " << *I
+                        << " clobbers CTR, invalidating "
+                        << printMBBReference(*BI->getParent()) << " ("
+                        << BI->getParent()->getFullName() << ") instruction "
+                        << *BI << "\n");
+      return false;
+    }
+
+    if (I == IE)
+      break;
+  }
+
+  if (!CheckPreds && Preds.empty())
+    return true;
+
+  if (CheckPreds) {
+queue_preds:
+    if (MachineFunction::iterator(MBB) == MBB->getParent()->begin()) {
+      LLVM_DEBUG(dbgs() << "Unable to find a MTCTR instruction for "
+                        << printMBBReference(*BI->getParent()) << " ("
+                        << BI->getParent()->getFullName() << ") instruction "
+                        << *BI << "\n");
+      return false;
+    }
+
+    append_range(Preds, MBB->predecessors());
+  }
+
+  do {
+    MBB = Preds.pop_back_val();
+    if (!Visited.count(MBB)) {
+      I = MBB->getLastNonDebugInstr();
+      goto check_block;
+    }
+  } while (!Preds.empty());
+
+  return true;
+}
+
+bool PPCCTRLoopsVerify::runOnMachineFunction(MachineFunction &MF) {
+  MDT = &getAnalysis<MachineDominatorTree>();
+
+  // Verify that all bdnz/bdz instructions are dominated by a loop mtctr before
+  // any other instructions that might clobber the ctr register.
+  for (MachineBasicBlock &MBB : MF) {
+    if (!MDT->isReachableFromEntry(&MBB))
+      continue;
+
+    for (MachineBasicBlock::iterator MII = MBB.getFirstTerminator(),
+      MIIE = MBB.end(); MII != MIIE; ++MII) {
+      unsigned Opc = MII->getOpcode();
+      if (Opc == PPC::BDNZ8 || Opc == PPC::BDNZ ||
+          Opc == PPC::BDZ8  || Opc == PPC::BDZ)
+        if (!verifyCTRBranch(&MBB, MII))
+          llvm_unreachable("Invalid PPC CTR loop!");
+    }
+  }
+
+  return false;
+}
+#endif // NDEBUG
diff --git a/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp b/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
index fdcf6e7e80f24..e1ccce9f44d50 100644
--- a/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
+++ b/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
@@ -416,6 +416,7 @@ namespace {
 private:
     bool trySETCC(SDNode *N);
     bool tryFoldSWTestBRCC(SDNode *N);
+    bool trySelectLoopCountIntrinsic(SDNode *N);
     bool tryAsSingleRLDICL(SDNode *N);
     bool tryAsSingleRLDICR(SDNode *N);
     bool tryAsSingleRLWINM(SDNode *N);
@@ -4716,6 +4717,59 @@ bool PPCDAGToDAGISel::tryFoldSWTestBRCC(SDNode *N) {
   return false;
 }
 
+bool PPCDAGToDAGISel::trySelectLoopCountIntrinsic(SDNode *N) {
+  // Sometimes the promoted value of the intrinsic is ANDed by some non-zero
+  // value, for example when crbits is disabled. If so, select the
+  // loop_decrement intrinsics now.
+  ISD::CondCode CC = cast<CondCodeSDNode>(N->getOperand(1))->get();
+  SDValue LHS = N->getOperand(2), RHS = N->getOperand(3);
+
+  if (LHS.getOpcode() != ISD::AND || !isa<ConstantSDNode>(LHS.getOperand(1)) ||
+      isNullConstant(LHS.getOperand(1)))
+    return false;
+
+  if (LHS.getOperand(0).getOpcode() != ISD::INTRINSIC_W_CHAIN ||
+      cast<ConstantSDNode>(LHS.getOperand(0).getOperand(1))->getZExtValue() !=
+          Intrinsic::loop_decrement)
+    return false;
+
+  if (!isa<ConstantSDNode>(RHS))
+    return false;
+
+  assert((CC == ISD::SETEQ || CC == ISD::SETNE) &&
+         "Counter decrement comparison is not EQ or NE");
+
+  SDValue OldDecrement = LHS.getOperand(0);
+  assert(OldDecrement.hasOneUse() && "loop decrement has more than one use!");
+
+  SDLoc DecrementLoc(OldDecrement);
+  SDValue ChainInput = OldDecrement.getOperand(0);
+  SDValue DecrementOps[] = {Subtarget->isPPC64() ? getI64Imm(1, DecrementLoc)
+                                                 : getI32Imm(1, DecrementLoc)};
+  unsigned DecrementOpcode =
+      Subtarget->isPPC64() ? PPC::DecreaseCTR8loop : PPC::DecreaseCTRloop;
+  SDNode *NewDecrement = CurDAG->getMachineNode(DecrementOpcode, DecrementLoc,
+                                                MVT::i1, DecrementOps);
+
+  unsigned Val = cast<ConstantSDNode>(RHS)->getZExtValue();
+  bool IsBranchOnTrue = (CC == ISD::SETEQ && Val) || (CC == ISD::SETNE && !Val);
+  unsigned Opcode = IsBranchOnTrue ? PPC::BC : PPC::BCn;
+
+  ReplaceUses(LHS.getValue(0), LHS.getOperand(1));
+  CurDAG->RemoveDeadNode(LHS.getNode());
+
+  // Mark the old loop_decrement intrinsic as dead.
+  ReplaceUses(OldDecrement.getValue(1), ChainInput);
+  CurDAG->RemoveDeadNode(OldDecrement.getNode());
+
+  SDValue Chain = CurDAG->getNode(ISD::TokenFactor, SDLoc(N), MVT::Other,
+                                  ChainInput, N->getOperand(0));
+
+  CurDAG->SelectNodeTo(N, Opcode, MVT::Other, SDValue(NewDecrement, 0),
+                       N->getOperand(4), Chain);
+  return true;
+}
+
 bool PPCDAGToDAGISel::tryAsSingleRLWINM(SDNode *N) {
   assert(N->getOpcode() == ISD::AND && "ISD::AND SDNode expected");
   unsigned Imm;
@@ -5722,6 +5776,8 @@ void PPCDAGToDAGISel::Select(SDNode *N) {
   case ISD::BR_CC: {
     if (tryFoldSWTestBRCC(N))
       return;
+    if (trySelectLoopCountIntrinsic(N))
+      return;
     ISD::CondCode CC = cast<CondCodeSDNode>(N->getOperand(1))->get();
     unsigned PCC =
         getPredicateForSetCC(CC, N->getOperand(2).getValueType(), Subtarget);
diff --git a/llvm/lib/Target/PowerPC/PPCISelLowering.cpp b/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
index 6c9d43ad8c03f..e2a6c290e1cdb 100644
--- a/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
+++ b/llvm/lib/Target/PowerPC/PPCISelLowering.cpp
@@ -15615,25 +15615,6 @@ SDValue PPCTargetLowering::PerformDAGCombine(SDNode *N,
         return SDValue(VCMPrecNode, 0);
     }
     break;
-  case ISD::BRCOND: {
-    SDValue Cond = N->getOperand(1);
-    SDValue Target = N->getOperand(2);
-
-    if (Cond.getOpcode() == ISD::INTRINSIC_W_CHAIN &&
-        cast<ConstantSDNode>(Cond.getOperand(1))->getZExtValue() ==
-          Intrinsic::loop_decrement) {
-
-      // We now need to make the intrinsic dead (it cannot be instruction
-      // selected).
-      DAG.ReplaceAllUsesOfValueWith(Cond.getValue(1), Cond.getOperand(0));
-      assert(Cond.getNode()->hasOneUse() &&
-             "Counter decrement has more than one use");
-
-      return DAG.getNode(PPCISD::BDNZ, dl, MVT::Other,
-                         N->getOperand(0), Target);
-    }
-  }
-  break;
   case ISD::BR_CC: {
     // If this is a branch on an altivec predicate comparison, lower this so
     // that we don't have to do a MFOCRF: instead, branch directly on CR6.  This
@@ -15642,37 +15623,6 @@ SDValue PPCTargetLowering::PerformDAGCombine(SDNode *N,
     ISD::CondCode CC = cast<CondCodeSDNode>(N->getOperand(1))->get();
     SDValue LHS = N->getOperand(2), RHS = N->getOperand(3);
 
-    // Sometimes the promoted value of the intrinsic is ANDed by some non-zero
-    // value. If so, pass-through the AND to get to the intrinsic.
-    if (LHS.getOpcode() == ISD::AND &&
-        LHS.getOperand(0).getOpcode() == ISD::INTRINSIC_W_CHAIN &&
-        cast<ConstantSDNode>(LHS.getOperand(0).getOperand(1))->getZExtValue() ==
-          Intrinsic::loop_decrement &&
-        isa<ConstantSDNode>(LHS.getOperand(1)) &&
-        !isNullConstant(LHS.getOperand(1)))
-      LHS = LHS.getOperand(0);
-
-    if (LHS.getOpcode() == ISD::INTRINSIC_W_CHAIN &&
-        cast<ConstantSDNode>(LHS.getOperand(1))->getZExtValue() ==
-          Intrinsic::loop_decrement &&
-        isa<ConstantSDNode>(RHS)) {
-      assert((CC == ISD::SETEQ || CC == ISD::SETNE) &&
-             "Counter decrement comparison is not EQ or NE");
-
-      unsigned Val = cast<ConstantSDNode>(RHS)->getZExtValue();
-      bool isBDNZ = (CC == ISD::SETEQ && Val) ||
-                    (CC == ISD::SETNE && !Val);
-
-      // We now need to make the intrinsic dead (it cannot be instruction
-      // selected).
-      DAG.ReplaceAllUsesOfValueWith(LHS.getValue(1), LHS.getOperand(0));
-      assert(LHS.getNode()->hasOneUse() &&
-             "Counter decrement has more than one use");
-
-      return DAG.getNode(isBDNZ ? PPCISD::BDNZ : PPCISD::BDZ, dl, MVT::Other,
-                         N->getOperand(0), N->getOperand(4));
-    }
-
     int CompareOpc;
     bool isDot;
 
diff --git a/llvm/lib/Target/PowerPC/PPCInstr64Bit.td b/llvm/lib/Target/PowerPC/PPCInstr64Bit.td
index eae8e36e475e9..5ecf61901e2b8 100644
--- a/llvm/lib/Target/PowerPC/PPCInstr64Bit.td
+++ b/llvm/lib/Target/PowerPC/PPCInstr64Bit.td
@@ -580,6 +580,10 @@ def MTCTR8loop : XFXForm_7_ext<31, 467, 9, (outs), (ins g8rc:$rS),
                  PPC970_DGroup_First, PPC970_Unit_FXU;
 }
 
+let hasSideEffects = 1, hasNoSchedulingInfo = 1, Uses = [CTR8], Defs = [CTR8] in
+def DecreaseCTR8loop : PPCEmitTimePseudo<(outs crbitrc:$rT), (ins i64imm:$stride),
+                                        "#DecreaseCTR8loop", [(set i1:$rT, (int_loop_decrement (i64 imm:$stride)))]>;
+
 let Pattern = [(set i64:$rT, readcyclecounter)] in
 def MFTB8 : XFXForm_1_ext<31, 339, 268, (outs g8rc:$rT), (ins),
                           "mfspr $rT, 268", IIC_SprMFTB>,
diff --git a/llvm/lib/Target/PowerPC/PPCInstrInfo.td b/llvm/lib/Target/PowerPC/PPCInstrInfo.td
index 53e73e33b003b..30124481753db 100644
--- a/llvm/lib/Target/PowerPC/PPCInstrInfo.td
+++ b/llvm/lib/Target/PowerPC/PPCInstrInfo.td
@@ -3056,6 +3056,10 @@ def MTCTRloop : XFXForm_7_ext<31, 467, 9, (outs), (ins gprc:$rS),
                 PPC970_DGroup_First, PPC970_Unit_FXU;
 }
 
+let hasSideEffects = 1, hasNoSchedulingInfo = 1, Uses = [CTR], Defs = [CTR] in
+def DecreaseCTRloop : PPCEmitTimePseudo<(outs crbitrc:$rT), (ins i32imm:$stride),
+                                       "#DecreaseCTRloop", [(set i1:$rT, (int_loop_decrement (i32 imm:$stride)))]>;
+
 let hasSideEffects = 0 in {
 let Defs = [LR] in {
 def MTLR  : XFXForm_7_ext<31, 467, 8, (outs), (ins gprc:$rS),
diff --git a/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp b/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
index 3eff00fc3c05f..16c0f9240c208 100644
--- a/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
+++ b/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
@@ -125,6 +125,7 @@ extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializePowerPCTarget() {
   initializePPCLowerMASSVEntriesPass(PR);
   initializePPCExpandAtomicPseudoPass(PR);
   initializeGlobalISel(PR);
+  initializePPCCTRLoopsPass(PR);
 }
 
 static bool isLittleEndianTriple(const Triple &T) {
@@ -522,6 +523,16 @@ void PPCPassConfig::addPreRegAlloc() {
   if (EnableExtraTOCRegDeps)
     addPass(createPPCTOCRegDepsPass());
 
+  // Run CTR loops pass before MachinePipeliner pass.
+  // MachinePipeliner will pipeline all instructions before the terminator, but
+  // we don't want DecreaseCTRPseudo to be pipelined.
+  // Note we may lose some MachinePipeliner opportunities if we run CTR loops
+  // generation pass before MachinePipeliner and the loop is converted back to
+  // a normal loop. We can revisit this later for running PPCCTRLoops after
+  // MachinePipeliner and handling DecreaseCTRPseudo in MachinePipeliner pass.
+  if (getOptLevel() != CodeGenOpt::None)
+    addPass(createPPCCTRLoopsPass());
+
   if (getOptLevel() != CodeGenOpt::None)
     addPass(&MachinePipelinerID);
 }
diff --git a/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp b/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
index c51acdf52f14d..12c72e483742f 100644
--- a/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
+++ b/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
@@ -1978,7 +1978,7 @@ struct MemorySanitizerVisitor : public InstVisitor<MemorySanitizerVisitor> {
     IRBuilder<> IRB(&I);
     Value *Addr = I.getOperand(0);
     Value *Val = I.getOperand(1);
-    Value *ShadowPtr = getShadowOriginPtr(Addr, IRB, Val->getType(), Align(1),
+    Value *ShadowPtr = getShadowOriginPtr(Addr, IRB, getShadowTy(Val), Align(1),
                                           /*isStore*/ true)
                            .first;
 
@@ -3945,7 +3945,8 @@ struct MemorySanitizerVisitor : public InstVisitor<MemorySanitizerVisitor> {
     uint64_t TypeSize = DL.getTypeAllocSize(I.getAllocatedType());
     Value *Len = ConstantInt::get(MS.IntptrTy, TypeSize);
     if (I.isArrayAllocation())
-      Len = IRB.CreateMul(Len, I.getArraySize());
+      Len = IRB.CreateMul(Len,
+                          IRB.CreateZExtOrTrunc(I.getArraySize(), MS.IntptrTy));
 
     if (MS.CompileKernel)
       poisonAllocaKmsan(I, IRB, Len);
diff --git a/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp b/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
index 180012198c42c..54eac4d857f15 100644
--- a/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
+++ b/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
@@ -430,7 +430,9 @@ static bool shouldInstrumentReadWriteFromAddress(const Module *M, Value *Addr) {
   // with them.
   if (Addr) {
     Type *PtrTy = cast<PointerType>(Addr->getType()->getScalarType());
-    if (PtrTy->getPointerAddressSpace() != 0)
+    auto AS = PtrTy->getPointerAddressSpace();
+    // Allow for custom addresspaces
+    if (AS != 0 && AS < 10)
       return false;
   }
 
diff --git a/llvm/lib/Transforms/Scalar/LICM.cpp b/llvm/lib/Transforms/Scalar/LICM.cpp
index 6372ce19f8eec..073c4c8c1ac9d 100644
--- a/llvm/lib/Transforms/Scalar/LICM.cpp
+++ b/llvm/lib/Transforms/Scalar/LICM.cpp
@@ -159,7 +159,8 @@ static bool pointerInvalidatedByLoop(MemoryLocation MemLoc,
                                      AAResults *AA);
 static bool pointerInvalidatedByLoopWithMSSA(MemorySSA *MSSA, MemoryUse *MU,
                                              Loop *CurLoop, Instruction &I,
-                                             SinkAndHoistLICMFlags &Flags);
+                                             SinkAndHoistLICMFlags &Flags,
+                                             bool InvariantGroup);
 static bool pointerInvalidatedByBlockWithMSSA(BasicBlock &BB, MemorySSA &MSSA,
                                               MemoryUse &MU);
 static Instruction *cloneInstructionInExitBlock(
@@ -1165,13 +1166,14 @@ bool llvm::canSinkOrHoistInst(Instruction &I, AAResults *AA, DominatorTree *DT,
     if (isLoadInvariantInLoop(LI, DT, CurLoop))
       return true;
 
-    bool Invalidated;
+    bool InvariantGroup = LI->hasMetadata(LLVMContext::MD_invariant_group);
+
+    bool Invalidated = pointerInvalidatedByLoopWithMSSA(
+          MSSA, cast<MemoryUse>(MSSA->getMemoryAccess(LI)), CurLoop, I, *Flags,
+          InvariantGroup);
     if (CurAST)
-      Invalidated = pointerInvalidatedByLoop(MemoryLocation::get(LI), CurAST,
+      Invalidated &= pointerInvalidatedByLoop(MemoryLocation::get(LI), CurAST,
                                              CurLoop, AA);
-    else
-      Invalidated = pointerInvalidatedByLoopWithMSSA(
-          MSSA, cast<MemoryUse>(MSSA->getMemoryAccess(LI)), CurLoop, I, *Flags);
     // Check loop-invariant address because this may also be a sinkable load
     // whose address is not necessarily loop-invariant.
     if (ORE && Invalidated && CurLoop->isLoopInvariant(LI->getPointerOperand()))
@@ -1227,7 +1229,7 @@ bool llvm::canSinkOrHoistInst(Instruction &I, AAResults *AA, DominatorTree *DT,
             else
               Invalidated = pointerInvalidatedByLoopWithMSSA(
                   MSSA, cast<MemoryUse>(MSSA->getMemoryAccess(CI)), CurLoop, I,
-                  *Flags);
+                  *Flags, false);
             if (Invalidated)
               return false;
           }
@@ -2301,7 +2303,8 @@ static bool pointerInvalidatedByLoop(MemoryLocation MemLoc,
 
 bool pointerInvalidatedByLoopWithMSSA(MemorySSA *MSSA, MemoryUse *MU,
                                       Loop *CurLoop, Instruction &I,
-                                      SinkAndHoistLICMFlags &Flags) {
+                                      SinkAndHoistLICMFlags &Flags,
+                                      bool InvariantGroup) {
   // For hoisting, use the walker to determine safety
   if (!Flags.getIsSink()) {
     MemoryAccess *Source;
@@ -2312,8 +2315,10 @@ bool pointerInvalidatedByLoopWithMSSA(MemorySSA *MSSA, MemoryUse *MU,
       Source = MSSA->getSkipSelfWalker()->getClobberingMemoryAccess(MU);
       Flags.incrementClobberingCalls();
     }
+
     return !MSSA->isLiveOnEntryDef(Source) &&
-           CurLoop->contains(Source->getBlock());
+           CurLoop->contains(Source->getBlock()) &&
+           !(InvariantGroup && Source->getBlock() == CurLoop->getHeader() && isa<MemoryPhi>(Source));
   }
 
   // For sinking, we'd need to check all Defs below this use. The getClobbering
diff --git a/llvm/lib/Transforms/Utils/SimplifyCFG.cpp b/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
index 8c4e1b381b4d4..0003cf59dd5ef 100644
--- a/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
+++ b/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
@@ -439,7 +439,8 @@ static bool dominatesMergePoint(Value *V, BasicBlock *BB,
 static ConstantInt *GetConstantInt(Value *V, const DataLayout &DL) {
   // Normal constant int.
   ConstantInt *CI = dyn_cast<ConstantInt>(V);
-  if (CI || !isa<Constant>(V) || !V->getType()->isPointerTy())
+  if (CI || !isa<Constant>(V) || !V->getType()->isPointerTy() ||
+      DL.isNonIntegralPointerType(V->getType()))
     return CI;
 
   // This is some kind of pointer constant. Turn it into a pointer-sized
diff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
index 46ff0994e04e7..e629598ad36b7 100644
--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
@@ -4892,6 +4892,27 @@ bool LoopVectorizationCostModel::interleavedAccessCanBeWidened(
   if (hasIrregularType(ScalarTy, DL))
     return false;
 
+  // If the group involves a non-integral pointer, we may not be able to
+  // losslessly cast all values to a common type.
+  unsigned InterleaveFactor = Group->getFactor();
+  bool ScalarNI = DL.isNonIntegralPointerType(ScalarTy);
+  for (unsigned i = 0; i < InterleaveFactor; i++) {
+    Instruction *Member = Group->getMember(i);
+    if (!Member)
+      continue;
+    auto *MemberTy = getLoadStoreType(Member);
+    bool MemberNI = DL.isNonIntegralPointerType(MemberTy);
+    // Don't coerce non-integral pointers to integers or vice versa.
+    if (MemberNI != ScalarNI) {
+      // TODO: Consider adding special nullptr value case here
+      return false;
+    } else if (MemberNI && ScalarNI &&
+               ScalarTy->getPointerAddressSpace() !=
+               MemberTy->getPointerAddressSpace()) {
+      return false;
+    }
+  }
+
   // Check if masking is required.
   // A Group may need masking for one of two reasons: it resides in a block that
   // needs predication, or it was decided to use masking to deal with gaps
diff --git a/llvm/test/CodeGen/PowerPC/O3-pipeline.ll b/llvm/test/CodeGen/PowerPC/O3-pipeline.ll
index d64947f5f97a2..5aba1f1654594 100644
--- a/llvm/test/CodeGen/PowerPC/O3-pipeline.ll
+++ b/llvm/test/CodeGen/PowerPC/O3-pipeline.ll
@@ -129,6 +129,9 @@
 ; CHECK-NEXT:       PowerPC TOC Register Dependencies
 ; CHECK-NEXT:       MachineDominator Tree Construction
 ; CHECK-NEXT:       Machine Natural Loop Construction
+; CHECK-NEXT:       PowerPC CTR loops generation
+; CHECK-NEXT:       MachineDominator Tree Construction
+; CHECK-NEXT:       Machine Natural Loop Construction
 ; CHECK-NEXT:       Slot index numbering
 ; CHECK-NEXT:       Live Interval Analysis
 ; CHECK-NEXT:       Lazy Machine Block Frequency Analysis
diff --git a/llvm/test/CodeGen/PowerPC/ctrloops-pseudo.ll b/llvm/test/CodeGen/PowerPC/ctrloops-pseudo.ll
new file mode 100644
index 0000000000000..9890830194e22
--- /dev/null
+++ b/llvm/test/CodeGen/PowerPC/ctrloops-pseudo.ll
@@ -0,0 +1,461 @@
+; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
+; RUN: llc -verify-machineinstrs -stop-after=finalize-isel -mtriple=powerpc64-ibm-aix-xcoff \
+; RUN:   -mcpu=pwr4 < %s | FileCheck -check-prefix=AIX64 %s
+; RUN: llc -verify-machineinstrs -stop-after=finalize-isel -mtriple=powerpc-ibm-aix-xcoff \
+; RUN:   -mcpu=pwr4 < %s | FileCheck -check-prefix=AIX32 %s
+; RUN: llc -verify-machineinstrs -stop-after=finalize-isel -mtriple=powerpc64le-unknown-linux-gnu \
+; RUN:   -mcpu=pwr8 < %s | FileCheck -check-prefix=LE64 %s
+
+;; This file is copied from test/CodeGen/PowerPC/ctrloops.ll.
+;; In this file, we are testing the CTR loops form after ISEL.
+
+@a = common global i32 0, align 4
+
+define void @test1(i32 %c) nounwind {
+  ; AIX64-LABEL: name: test1
+  ; AIX64: bb.0.entry:
+  ; AIX64-NEXT:   successors: %bb.1(0x80000000)
+  ; AIX64-NEXT:   liveins: $x3
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT:   [[COPY:%[0-9]+]]:g8rc = COPY $x3
+  ; AIX64-NEXT:   [[COPY1:%[0-9]+]]:gprc = COPY [[COPY]].sub_32
+  ; AIX64-NEXT:   [[LI8_:%[0-9]+]]:g8rc = LI8 2048
+  ; AIX64-NEXT:   MTCTR8loop killed [[LI8_]], implicit-def dead $ctr8
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT: bb.1.for.body:
+  ; AIX64-NEXT:   successors: %bb.1(0x7c000000), %bb.2(0x04000000)
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT:   [[LDtoc:%[0-9]+]]:g8rc_and_g8rc_nox0 = LDtoc @a, $x2 :: (load (s64) from got)
+  ; AIX64-NEXT:   [[LWZ:%[0-9]+]]:gprc = LWZ 0, [[LDtoc]] :: (volatile dereferenceable load (s32) from @a)
+  ; AIX64-NEXT:   [[ADD4_:%[0-9]+]]:gprc = nsw ADD4 killed [[LWZ]], [[COPY1]]
+  ; AIX64-NEXT:   STW killed [[ADD4_]], 0, [[LDtoc]] :: (volatile store (s32) into @a)
+  ; AIX64-NEXT:   [[DecreaseCTR8loop:%[0-9]+]]:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+  ; AIX64-NEXT:   BC killed [[DecreaseCTR8loop]], %bb.1
+  ; AIX64-NEXT:   B %bb.2
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT: bb.2.for.end:
+  ; AIX64-NEXT:   BLR8 implicit $lr8, implicit $rm
+  ; AIX32-LABEL: name: test1
+  ; AIX32: bb.0.entry:
+  ; AIX32-NEXT:   successors: %bb.1(0x80000000)
+  ; AIX32-NEXT:   liveins: $r3
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT:   [[COPY:%[0-9]+]]:gprc = COPY $r3
+  ; AIX32-NEXT:   [[LI:%[0-9]+]]:gprc = LI 2048
+  ; AIX32-NEXT:   MTCTRloop killed [[LI]], implicit-def dead $ctr
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT: bb.1.for.body:
+  ; AIX32-NEXT:   successors: %bb.1(0x7c000000), %bb.2(0x04000000)
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT:   [[LWZtoc:%[0-9]+]]:gprc_and_gprc_nor0 = LWZtoc @a, $r2 :: (load (s32) from got)
+  ; AIX32-NEXT:   [[LWZ:%[0-9]+]]:gprc = LWZ 0, [[LWZtoc]] :: (volatile dereferenceable load (s32) from @a)
+  ; AIX32-NEXT:   [[ADD4_:%[0-9]+]]:gprc = nsw ADD4 killed [[LWZ]], [[COPY]]
+  ; AIX32-NEXT:   STW killed [[ADD4_]], 0, [[LWZtoc]] :: (volatile store (s32) into @a)
+  ; AIX32-NEXT:   [[DecreaseCTRloop:%[0-9]+]]:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+  ; AIX32-NEXT:   BC killed [[DecreaseCTRloop]], %bb.1
+  ; AIX32-NEXT:   B %bb.2
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT: bb.2.for.end:
+  ; AIX32-NEXT:   BLR implicit $lr, implicit $rm
+  ; LE64-LABEL: name: test1
+  ; LE64: bb.0.entry:
+  ; LE64-NEXT:   successors: %bb.1(0x80000000)
+  ; LE64-NEXT:   liveins: $x3
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT:   [[COPY:%[0-9]+]]:g8rc = COPY $x3
+  ; LE64-NEXT:   [[COPY1:%[0-9]+]]:gprc = COPY [[COPY]].sub_32
+  ; LE64-NEXT:   [[LI8_:%[0-9]+]]:g8rc = LI8 2048
+  ; LE64-NEXT:   MTCTR8loop killed [[LI8_]], implicit-def dead $ctr8
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT: bb.1.for.body:
+  ; LE64-NEXT:   successors: %bb.1(0x7c000000), %bb.2(0x04000000)
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT:   [[ADDIStocHA8_:%[0-9]+]]:g8rc_and_g8rc_nox0 = ADDIStocHA8 $x2, @a
+  ; LE64-NEXT:   [[LDtocL:%[0-9]+]]:g8rc_and_g8rc_nox0 = LDtocL @a, killed [[ADDIStocHA8_]] :: (load (s64) from got)
+  ; LE64-NEXT:   [[LWZ:%[0-9]+]]:gprc = LWZ 0, [[LDtocL]] :: (volatile dereferenceable load (s32) from @a)
+  ; LE64-NEXT:   [[ADD4_:%[0-9]+]]:gprc = nsw ADD4 killed [[LWZ]], [[COPY1]]
+  ; LE64-NEXT:   STW killed [[ADD4_]], 0, [[LDtocL]] :: (volatile store (s32) into @a)
+  ; LE64-NEXT:   [[DecreaseCTR8loop:%[0-9]+]]:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+  ; LE64-NEXT:   BC killed [[DecreaseCTR8loop]], %bb.1
+  ; LE64-NEXT:   B %bb.2
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT: bb.2.for.end:
+  ; LE64-NEXT:   BLR8 implicit $lr8, implicit $rm
+entry:
+  br label %for.body
+
+for.body:                                         ; preds = %for.body, %entry
+  %i.01 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
+  %0 = load volatile i32, i32* @a, align 4
+  %add = add nsw i32 %0, %c
+  store volatile i32 %add, i32* @a, align 4
+  %inc = add nsw i32 %i.01, 1
+  %exitcond = icmp eq i32 %inc, 2048
+  br i1 %exitcond, label %for.end, label %for.body
+
+for.end:                                          ; preds = %for.body
+  ret void
+}
+
+define void @test2(i32 %c, i32 %d) nounwind {
+  ; AIX64-LABEL: name: test2
+  ; AIX64: bb.0.entry:
+  ; AIX64-NEXT:   successors: %bb.1(0x50000000), %bb.3(0x30000000)
+  ; AIX64-NEXT:   liveins: $x3, $x4
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT:   [[COPY:%[0-9]+]]:g8rc = COPY $x4
+  ; AIX64-NEXT:   [[COPY1:%[0-9]+]]:g8rc = COPY $x3
+  ; AIX64-NEXT:   [[COPY2:%[0-9]+]]:gprc = COPY [[COPY1]].sub_32
+  ; AIX64-NEXT:   [[COPY3:%[0-9]+]]:gprc_and_gprc_nor0 = COPY [[COPY]].sub_32
+  ; AIX64-NEXT:   [[CMPWI:%[0-9]+]]:crrc = CMPWI [[COPY3]], 1
+  ; AIX64-NEXT:   BCC 12, killed [[CMPWI]], %bb.3
+  ; AIX64-NEXT:   B %bb.1
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT: bb.1.for.body.preheader:
+  ; AIX64-NEXT:   successors: %bb.2(0x80000000)
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT:   [[ADDI:%[0-9]+]]:gprc = ADDI [[COPY3]], -1
+  ; AIX64-NEXT:   [[DEF:%[0-9]+]]:g8rc = IMPLICIT_DEF
+  ; AIX64-NEXT:   [[INSERT_SUBREG:%[0-9]+]]:g8rc = INSERT_SUBREG [[DEF]], killed [[ADDI]], %subreg.sub_32
+  ; AIX64-NEXT:   [[RLDICL:%[0-9]+]]:g8rc_and_g8rc_nox0 = RLDICL killed [[INSERT_SUBREG]], 0, 32
+  ; AIX64-NEXT:   [[ADDI8_:%[0-9]+]]:g8rc = nuw nsw ADDI8 killed [[RLDICL]], 1
+  ; AIX64-NEXT:   MTCTR8loop killed [[ADDI8_]], implicit-def dead $ctr8
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT: bb.2.for.body:
+  ; AIX64-NEXT:   successors: %bb.2(0x7c000000), %bb.3(0x04000000)
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT:   [[LDtoc:%[0-9]+]]:g8rc_and_g8rc_nox0 = LDtoc @a, $x2 :: (load (s64) from got)
+  ; AIX64-NEXT:   [[LWZ:%[0-9]+]]:gprc = LWZ 0, [[LDtoc]] :: (volatile dereferenceable load (s32) from @a)
+  ; AIX64-NEXT:   [[ADD4_:%[0-9]+]]:gprc = nsw ADD4 killed [[LWZ]], [[COPY2]]
+  ; AIX64-NEXT:   STW killed [[ADD4_]], 0, [[LDtoc]] :: (volatile store (s32) into @a)
+  ; AIX64-NEXT:   [[DecreaseCTR8loop:%[0-9]+]]:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+  ; AIX64-NEXT:   BC killed [[DecreaseCTR8loop]], %bb.2
+  ; AIX64-NEXT:   B %bb.3
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT: bb.3.for.end:
+  ; AIX64-NEXT:   BLR8 implicit $lr8, implicit $rm
+  ; AIX32-LABEL: name: test2
+  ; AIX32: bb.0.entry:
+  ; AIX32-NEXT:   successors: %bb.1(0x50000000), %bb.3(0x30000000)
+  ; AIX32-NEXT:   liveins: $r3, $r4
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT:   [[COPY:%[0-9]+]]:gprc = COPY $r4
+  ; AIX32-NEXT:   [[COPY1:%[0-9]+]]:gprc = COPY $r3
+  ; AIX32-NEXT:   [[CMPWI:%[0-9]+]]:crrc = CMPWI [[COPY]], 1
+  ; AIX32-NEXT:   BCC 12, killed [[CMPWI]], %bb.3
+  ; AIX32-NEXT:   B %bb.1
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT: bb.1.for.body.preheader:
+  ; AIX32-NEXT:   successors: %bb.2(0x80000000)
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT:   MTCTRloop [[COPY]], implicit-def dead $ctr
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT: bb.2.for.body:
+  ; AIX32-NEXT:   successors: %bb.2(0x7c000000), %bb.3(0x04000000)
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT:   [[LWZtoc:%[0-9]+]]:gprc_and_gprc_nor0 = LWZtoc @a, $r2 :: (load (s32) from got)
+  ; AIX32-NEXT:   [[LWZ:%[0-9]+]]:gprc = LWZ 0, [[LWZtoc]] :: (volatile dereferenceable load (s32) from @a)
+  ; AIX32-NEXT:   [[ADD4_:%[0-9]+]]:gprc = nsw ADD4 killed [[LWZ]], [[COPY1]]
+  ; AIX32-NEXT:   STW killed [[ADD4_]], 0, [[LWZtoc]] :: (volatile store (s32) into @a)
+  ; AIX32-NEXT:   [[DecreaseCTRloop:%[0-9]+]]:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+  ; AIX32-NEXT:   BC killed [[DecreaseCTRloop]], %bb.2
+  ; AIX32-NEXT:   B %bb.3
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT: bb.3.for.end:
+  ; AIX32-NEXT:   BLR implicit $lr, implicit $rm
+  ; LE64-LABEL: name: test2
+  ; LE64: bb.0.entry:
+  ; LE64-NEXT:   successors: %bb.1(0x50000000), %bb.3(0x30000000)
+  ; LE64-NEXT:   liveins: $x3, $x4
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT:   [[COPY:%[0-9]+]]:g8rc = COPY $x4
+  ; LE64-NEXT:   [[COPY1:%[0-9]+]]:g8rc = COPY $x3
+  ; LE64-NEXT:   [[COPY2:%[0-9]+]]:gprc = COPY [[COPY1]].sub_32
+  ; LE64-NEXT:   [[COPY3:%[0-9]+]]:gprc_and_gprc_nor0 = COPY [[COPY]].sub_32
+  ; LE64-NEXT:   [[CMPWI:%[0-9]+]]:crrc = CMPWI [[COPY3]], 1
+  ; LE64-NEXT:   BCC 12, killed [[CMPWI]], %bb.3
+  ; LE64-NEXT:   B %bb.1
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT: bb.1.for.body.preheader:
+  ; LE64-NEXT:   successors: %bb.2(0x80000000)
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT:   [[ADDI:%[0-9]+]]:gprc = ADDI [[COPY3]], -1
+  ; LE64-NEXT:   [[DEF:%[0-9]+]]:g8rc = IMPLICIT_DEF
+  ; LE64-NEXT:   [[INSERT_SUBREG:%[0-9]+]]:g8rc = INSERT_SUBREG [[DEF]], killed [[ADDI]], %subreg.sub_32
+  ; LE64-NEXT:   [[RLDICL:%[0-9]+]]:g8rc_and_g8rc_nox0 = RLDICL killed [[INSERT_SUBREG]], 0, 32
+  ; LE64-NEXT:   [[ADDI8_:%[0-9]+]]:g8rc = nuw nsw ADDI8 killed [[RLDICL]], 1
+  ; LE64-NEXT:   MTCTR8loop killed [[ADDI8_]], implicit-def dead $ctr8
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT: bb.2.for.body:
+  ; LE64-NEXT:   successors: %bb.2(0x7c000000), %bb.3(0x04000000)
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT:   [[ADDIStocHA8_:%[0-9]+]]:g8rc_and_g8rc_nox0 = ADDIStocHA8 $x2, @a
+  ; LE64-NEXT:   [[LDtocL:%[0-9]+]]:g8rc_and_g8rc_nox0 = LDtocL @a, killed [[ADDIStocHA8_]] :: (load (s64) from got)
+  ; LE64-NEXT:   [[LWZ:%[0-9]+]]:gprc = LWZ 0, [[LDtocL]] :: (volatile dereferenceable load (s32) from @a)
+  ; LE64-NEXT:   [[ADD4_:%[0-9]+]]:gprc = nsw ADD4 killed [[LWZ]], [[COPY2]]
+  ; LE64-NEXT:   STW killed [[ADD4_]], 0, [[LDtocL]] :: (volatile store (s32) into @a)
+  ; LE64-NEXT:   [[DecreaseCTR8loop:%[0-9]+]]:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+  ; LE64-NEXT:   BC killed [[DecreaseCTR8loop]], %bb.2
+  ; LE64-NEXT:   B %bb.3
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT: bb.3.for.end:
+  ; LE64-NEXT:   BLR8 implicit $lr8, implicit $rm
+entry:
+  %cmp1 = icmp sgt i32 %d, 0
+  br i1 %cmp1, label %for.body, label %for.end
+
+for.body:                                         ; preds = %entry, %for.body
+  %i.02 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
+  %0 = load volatile i32, i32* @a, align 4
+  %add = add nsw i32 %0, %c
+  store volatile i32 %add, i32* @a, align 4
+  %inc = add nsw i32 %i.02, 1
+  %exitcond = icmp eq i32 %inc, %d
+  br i1 %exitcond, label %for.end, label %for.body
+
+for.end:                                          ; preds = %for.body, %entry
+  ret void
+}
+
+define void @test3(i32 %c, i32 %d) nounwind {
+  ; AIX64-LABEL: name: test3
+  ; AIX64: bb.0.entry:
+  ; AIX64-NEXT:   successors: %bb.1(0x50000000), %bb.3(0x30000000)
+  ; AIX64-NEXT:   liveins: $x3, $x4
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT:   [[COPY:%[0-9]+]]:g8rc = COPY $x4
+  ; AIX64-NEXT:   [[COPY1:%[0-9]+]]:g8rc = COPY $x3
+  ; AIX64-NEXT:   [[COPY2:%[0-9]+]]:gprc = COPY [[COPY1]].sub_32
+  ; AIX64-NEXT:   [[COPY3:%[0-9]+]]:gprc_and_gprc_nor0 = COPY [[COPY]].sub_32
+  ; AIX64-NEXT:   [[CMPWI:%[0-9]+]]:crrc = CMPWI [[COPY3]], 1
+  ; AIX64-NEXT:   BCC 12, killed [[CMPWI]], %bb.3
+  ; AIX64-NEXT:   B %bb.1
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT: bb.1.for.body.preheader:
+  ; AIX64-NEXT:   successors: %bb.2(0x80000000)
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT:   [[ADDI:%[0-9]+]]:gprc = ADDI [[COPY3]], -1
+  ; AIX64-NEXT:   [[DEF:%[0-9]+]]:g8rc = IMPLICIT_DEF
+  ; AIX64-NEXT:   [[INSERT_SUBREG:%[0-9]+]]:g8rc = INSERT_SUBREG [[DEF]], killed [[ADDI]], %subreg.sub_32
+  ; AIX64-NEXT:   [[RLDICL:%[0-9]+]]:g8rc_and_g8rc_nox0 = RLDICL killed [[INSERT_SUBREG]], 0, 32
+  ; AIX64-NEXT:   [[ADDI8_:%[0-9]+]]:g8rc = nuw nsw ADDI8 killed [[RLDICL]], 1
+  ; AIX64-NEXT:   MTCTR8loop killed [[ADDI8_]], implicit-def dead $ctr8
+  ; AIX64-NEXT:   [[LI:%[0-9]+]]:gprc = LI 0
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT: bb.2.for.body:
+  ; AIX64-NEXT:   successors: %bb.2(0x7c000000), %bb.3(0x04000000)
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT:   [[PHI:%[0-9]+]]:gprc = PHI [[LI]], %bb.1, %1, %bb.2
+  ; AIX64-NEXT:   [[LDtoc:%[0-9]+]]:g8rc_and_g8rc_nox0 = LDtoc @a, $x2 :: (load (s64) from got)
+  ; AIX64-NEXT:   [[LWZ:%[0-9]+]]:gprc = LWZ 0, [[LDtoc]] :: (volatile dereferenceable load (s32) from @a)
+  ; AIX64-NEXT:   [[ADD4_:%[0-9]+]]:gprc = ADD4 [[PHI]], killed [[LWZ]]
+  ; AIX64-NEXT:   STW killed [[ADD4_]], 0, [[LDtoc]] :: (volatile store (s32) into @a)
+  ; AIX64-NEXT:   [[ADD4_1:%[0-9]+]]:gprc = ADD4 [[PHI]], [[COPY2]]
+  ; AIX64-NEXT:   [[DecreaseCTR8loop:%[0-9]+]]:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+  ; AIX64-NEXT:   BC killed [[DecreaseCTR8loop]], %bb.2
+  ; AIX64-NEXT:   B %bb.3
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT: bb.3.for.end:
+  ; AIX64-NEXT:   BLR8 implicit $lr8, implicit $rm
+  ; AIX32-LABEL: name: test3
+  ; AIX32: bb.0.entry:
+  ; AIX32-NEXT:   successors: %bb.1(0x50000000), %bb.3(0x30000000)
+  ; AIX32-NEXT:   liveins: $r3, $r4
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT:   [[COPY:%[0-9]+]]:gprc = COPY $r4
+  ; AIX32-NEXT:   [[COPY1:%[0-9]+]]:gprc = COPY $r3
+  ; AIX32-NEXT:   [[CMPWI:%[0-9]+]]:crrc = CMPWI [[COPY]], 1
+  ; AIX32-NEXT:   BCC 12, killed [[CMPWI]], %bb.3
+  ; AIX32-NEXT:   B %bb.1
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT: bb.1.for.body.preheader:
+  ; AIX32-NEXT:   successors: %bb.2(0x80000000)
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT:   MTCTRloop [[COPY]], implicit-def dead $ctr
+  ; AIX32-NEXT:   [[LI:%[0-9]+]]:gprc = LI 0
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT: bb.2.for.body:
+  ; AIX32-NEXT:   successors: %bb.2(0x7c000000), %bb.3(0x04000000)
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT:   [[PHI:%[0-9]+]]:gprc = PHI [[LI]], %bb.1, %1, %bb.2
+  ; AIX32-NEXT:   [[LWZtoc:%[0-9]+]]:gprc_and_gprc_nor0 = LWZtoc @a, $r2 :: (load (s32) from got)
+  ; AIX32-NEXT:   [[LWZ:%[0-9]+]]:gprc = LWZ 0, [[LWZtoc]] :: (volatile dereferenceable load (s32) from @a)
+  ; AIX32-NEXT:   [[ADD4_:%[0-9]+]]:gprc = ADD4 [[PHI]], killed [[LWZ]]
+  ; AIX32-NEXT:   STW killed [[ADD4_]], 0, [[LWZtoc]] :: (volatile store (s32) into @a)
+  ; AIX32-NEXT:   [[ADD4_1:%[0-9]+]]:gprc = ADD4 [[PHI]], [[COPY1]]
+  ; AIX32-NEXT:   [[DecreaseCTRloop:%[0-9]+]]:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+  ; AIX32-NEXT:   BC killed [[DecreaseCTRloop]], %bb.2
+  ; AIX32-NEXT:   B %bb.3
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT: bb.3.for.end:
+  ; AIX32-NEXT:   BLR implicit $lr, implicit $rm
+  ; LE64-LABEL: name: test3
+  ; LE64: bb.0.entry:
+  ; LE64-NEXT:   successors: %bb.1(0x50000000), %bb.3(0x30000000)
+  ; LE64-NEXT:   liveins: $x3, $x4
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT:   [[COPY:%[0-9]+]]:g8rc = COPY $x4
+  ; LE64-NEXT:   [[COPY1:%[0-9]+]]:g8rc = COPY $x3
+  ; LE64-NEXT:   [[COPY2:%[0-9]+]]:gprc = COPY [[COPY1]].sub_32
+  ; LE64-NEXT:   [[COPY3:%[0-9]+]]:gprc_and_gprc_nor0 = COPY [[COPY]].sub_32
+  ; LE64-NEXT:   [[CMPWI:%[0-9]+]]:crrc = CMPWI [[COPY3]], 1
+  ; LE64-NEXT:   BCC 12, killed [[CMPWI]], %bb.3
+  ; LE64-NEXT:   B %bb.1
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT: bb.1.for.body.preheader:
+  ; LE64-NEXT:   successors: %bb.2(0x80000000)
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT:   [[ADDI:%[0-9]+]]:gprc = ADDI [[COPY3]], -1
+  ; LE64-NEXT:   [[DEF:%[0-9]+]]:g8rc = IMPLICIT_DEF
+  ; LE64-NEXT:   [[INSERT_SUBREG:%[0-9]+]]:g8rc = INSERT_SUBREG [[DEF]], killed [[ADDI]], %subreg.sub_32
+  ; LE64-NEXT:   [[RLDICL:%[0-9]+]]:g8rc_and_g8rc_nox0 = RLDICL killed [[INSERT_SUBREG]], 0, 32
+  ; LE64-NEXT:   [[ADDI8_:%[0-9]+]]:g8rc = nuw nsw ADDI8 killed [[RLDICL]], 1
+  ; LE64-NEXT:   MTCTR8loop killed [[ADDI8_]], implicit-def dead $ctr8
+  ; LE64-NEXT:   [[LI:%[0-9]+]]:gprc = LI 0
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT: bb.2.for.body:
+  ; LE64-NEXT:   successors: %bb.2(0x7c000000), %bb.3(0x04000000)
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT:   [[PHI:%[0-9]+]]:gprc = PHI [[LI]], %bb.1, %1, %bb.2
+  ; LE64-NEXT:   [[ADDIStocHA8_:%[0-9]+]]:g8rc_and_g8rc_nox0 = ADDIStocHA8 $x2, @a
+  ; LE64-NEXT:   [[LDtocL:%[0-9]+]]:g8rc_and_g8rc_nox0 = LDtocL @a, killed [[ADDIStocHA8_]] :: (load (s64) from got)
+  ; LE64-NEXT:   [[LWZ:%[0-9]+]]:gprc = LWZ 0, [[LDtocL]] :: (volatile dereferenceable load (s32) from @a)
+  ; LE64-NEXT:   [[ADD4_:%[0-9]+]]:gprc = ADD4 [[PHI]], killed [[LWZ]]
+  ; LE64-NEXT:   STW killed [[ADD4_]], 0, [[LDtocL]] :: (volatile store (s32) into @a)
+  ; LE64-NEXT:   [[ADD4_1:%[0-9]+]]:gprc = ADD4 [[PHI]], [[COPY2]]
+  ; LE64-NEXT:   [[DecreaseCTR8loop:%[0-9]+]]:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+  ; LE64-NEXT:   BC killed [[DecreaseCTR8loop]], %bb.2
+  ; LE64-NEXT:   B %bb.3
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT: bb.3.for.end:
+  ; LE64-NEXT:   BLR8 implicit $lr8, implicit $rm
+entry:
+  %cmp1 = icmp sgt i32 %d, 0
+  br i1 %cmp1, label %for.body, label %for.end
+
+for.body:                                         ; preds = %entry, %for.body
+  %i.02 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
+  %mul = mul nsw i32 %i.02, %c
+  %0 = load volatile i32, i32* @a, align 4
+  %add = add nsw i32 %0, %mul
+  store volatile i32 %add, i32* @a, align 4
+  %inc = add nsw i32 %i.02, 1
+  %exitcond = icmp eq i32 %inc, %d
+  br i1 %exitcond, label %for.end, label %for.body
+
+for.end:                                          ; preds = %for.body, %entry
+  ret void
+}
+
+@tls_var = external thread_local global i8
+
+define i32 @test4(i32 %inp) {
+  ; AIX64-LABEL: name: test4
+  ; AIX64: bb.0.entry:
+  ; AIX64-NEXT:   successors: %bb.1(0x80000000)
+  ; AIX64-NEXT:   liveins: $x3
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT:   [[COPY:%[0-9]+]]:g8rc = COPY $x3
+  ; AIX64-NEXT:   [[COPY1:%[0-9]+]]:gprc_and_gprc_nor0 = COPY [[COPY]].sub_32
+  ; AIX64-NEXT:   [[CMPWI:%[0-9]+]]:crrc = CMPWI [[COPY1]], 1
+  ; AIX64-NEXT:   [[LI:%[0-9]+]]:gprc_and_gprc_nor0 = LI 1
+  ; AIX64-NEXT:   [[ISEL:%[0-9]+]]:gprc = ISEL [[COPY1]], [[LI]], [[CMPWI]].sub_lt
+  ; AIX64-NEXT:   [[SUBF:%[0-9]+]]:gprc = SUBF [[ISEL]], [[COPY1]]
+  ; AIX64-NEXT:   [[DEF:%[0-9]+]]:g8rc = IMPLICIT_DEF
+  ; AIX64-NEXT:   [[INSERT_SUBREG:%[0-9]+]]:g8rc = INSERT_SUBREG [[DEF]], killed [[SUBF]], %subreg.sub_32
+  ; AIX64-NEXT:   [[RLDICL:%[0-9]+]]:g8rc_and_g8rc_nox0 = RLDICL killed [[INSERT_SUBREG]], 0, 32
+  ; AIX64-NEXT:   [[ADDI8_:%[0-9]+]]:g8rc = nuw nsw ADDI8 killed [[RLDICL]], 1
+  ; AIX64-NEXT:   MTCTR8loop killed [[ADDI8_]], implicit-def dead $ctr8
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT: bb.1.for.body:
+  ; AIX64-NEXT:   successors: %bb.1(0x7c000000), %bb.2(0x04000000)
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT:   [[DecreaseCTR8loop:%[0-9]+]]:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+  ; AIX64-NEXT:   BC killed [[DecreaseCTR8loop]], %bb.1
+  ; AIX64-NEXT:   B %bb.2
+  ; AIX64-NEXT: {{  $}}
+  ; AIX64-NEXT: bb.2.return:
+  ; AIX64-NEXT:   [[LDtoc:%[0-9]+]]:g8rc = LDtoc target-flags(ppc-lo) @tls_var, $x2 :: (load (s64) from got)
+  ; AIX64-NEXT:   [[LDtoc1:%[0-9]+]]:g8rc = LDtoc target-flags(ppc-tlsgd) @tls_var, $x2 :: (load (s64) from got)
+  ; AIX64-NEXT:   [[TLSGDAIX8_:%[0-9]+]]:g8rc = TLSGDAIX8 killed [[LDtoc1]], killed [[LDtoc]]
+  ; AIX64-NEXT:   [[COPY2:%[0-9]+]]:gprc = COPY [[TLSGDAIX8_]].sub_32
+  ; AIX64-NEXT:   [[ADD4_:%[0-9]+]]:gprc = ADD4 killed [[COPY2]], [[ISEL]]
+  ; AIX64-NEXT:   [[DEF1:%[0-9]+]]:g8rc = IMPLICIT_DEF
+  ; AIX64-NEXT:   [[INSERT_SUBREG1:%[0-9]+]]:g8rc = INSERT_SUBREG [[DEF1]], killed [[ADD4_]], %subreg.sub_32
+  ; AIX64-NEXT:   $x3 = COPY [[INSERT_SUBREG1]]
+  ; AIX64-NEXT:   BLR8 implicit $lr8, implicit $rm, implicit $x3
+  ; AIX32-LABEL: name: test4
+  ; AIX32: bb.0.entry:
+  ; AIX32-NEXT:   successors: %bb.1(0x80000000)
+  ; AIX32-NEXT:   liveins: $r3
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT:   [[COPY:%[0-9]+]]:gprc_and_gprc_nor0 = COPY $r3
+  ; AIX32-NEXT:   [[CMPWI:%[0-9]+]]:crrc = CMPWI [[COPY]], 1
+  ; AIX32-NEXT:   [[LI:%[0-9]+]]:gprc_and_gprc_nor0 = LI 1
+  ; AIX32-NEXT:   [[ISEL:%[0-9]+]]:gprc = ISEL [[COPY]], [[LI]], [[CMPWI]].sub_lt
+  ; AIX32-NEXT:   [[SUBF:%[0-9]+]]:gprc_and_gprc_nor0 = SUBF [[ISEL]], [[COPY]]
+  ; AIX32-NEXT:   [[ADDI:%[0-9]+]]:gprc = ADDI killed [[SUBF]], 1
+  ; AIX32-NEXT:   MTCTRloop killed [[ADDI]], implicit-def dead $ctr
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT: bb.1.for.body:
+  ; AIX32-NEXT:   successors: %bb.1(0x7c000000), %bb.2(0x04000000)
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT:   [[DecreaseCTRloop:%[0-9]+]]:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+  ; AIX32-NEXT:   BC killed [[DecreaseCTRloop]], %bb.1
+  ; AIX32-NEXT:   B %bb.2
+  ; AIX32-NEXT: {{  $}}
+  ; AIX32-NEXT: bb.2.return:
+  ; AIX32-NEXT:   [[LWZtoc:%[0-9]+]]:gprc = LWZtoc target-flags(ppc-lo) @tls_var, $r2 :: (load (s32) from got)
+  ; AIX32-NEXT:   [[LWZtoc1:%[0-9]+]]:gprc = LWZtoc target-flags(ppc-tlsgd) @tls_var, $r2 :: (load (s32) from got)
+  ; AIX32-NEXT:   [[TLSGDAIX:%[0-9]+]]:gprc = TLSGDAIX killed [[LWZtoc1]], killed [[LWZtoc]]
+  ; AIX32-NEXT:   [[ADD4_:%[0-9]+]]:gprc = ADD4 killed [[TLSGDAIX]], [[ISEL]]
+  ; AIX32-NEXT:   $r3 = COPY [[ADD4_]]
+  ; AIX32-NEXT:   BLR implicit $lr, implicit $rm, implicit $r3
+  ; LE64-LABEL: name: test4
+  ; LE64: bb.0.entry:
+  ; LE64-NEXT:   successors: %bb.1(0x80000000)
+  ; LE64-NEXT:   liveins: $x3
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT:   [[COPY:%[0-9]+]]:g8rc = COPY $x3
+  ; LE64-NEXT:   [[COPY1:%[0-9]+]]:gprc_and_gprc_nor0 = COPY [[COPY]].sub_32
+  ; LE64-NEXT:   [[CMPWI:%[0-9]+]]:crrc = CMPWI [[COPY1]], 1
+  ; LE64-NEXT:   [[LI:%[0-9]+]]:gprc_and_gprc_nor0 = LI 1
+  ; LE64-NEXT:   [[ISEL:%[0-9]+]]:gprc = ISEL [[COPY1]], [[LI]], [[CMPWI]].sub_lt
+  ; LE64-NEXT:   [[SUBF:%[0-9]+]]:gprc = SUBF [[ISEL]], [[COPY1]]
+  ; LE64-NEXT:   [[DEF:%[0-9]+]]:g8rc = IMPLICIT_DEF
+  ; LE64-NEXT:   [[INSERT_SUBREG:%[0-9]+]]:g8rc = INSERT_SUBREG [[DEF]], killed [[SUBF]], %subreg.sub_32
+  ; LE64-NEXT:   [[RLDICL:%[0-9]+]]:g8rc_and_g8rc_nox0 = RLDICL killed [[INSERT_SUBREG]], 0, 32
+  ; LE64-NEXT:   [[ADDI8_:%[0-9]+]]:g8rc = nuw nsw ADDI8 killed [[RLDICL]], 1
+  ; LE64-NEXT:   MTCTR8loop killed [[ADDI8_]], implicit-def dead $ctr8
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT: bb.1.for.body:
+  ; LE64-NEXT:   successors: %bb.1(0x7c000000), %bb.2(0x04000000)
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT:   [[DecreaseCTR8loop:%[0-9]+]]:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+  ; LE64-NEXT:   BC killed [[DecreaseCTR8loop]], %bb.1
+  ; LE64-NEXT:   B %bb.2
+  ; LE64-NEXT: {{  $}}
+  ; LE64-NEXT: bb.2.return:
+  ; LE64-NEXT:   [[ADDISgotTprelHA:%[0-9]+]]:g8rc_and_g8rc_nox0 = ADDISgotTprelHA $x2, @tls_var
+  ; LE64-NEXT:   [[LDgotTprelL:%[0-9]+]]:g8rc_and_g8rc_nox0 = LDgotTprelL @tls_var, killed [[ADDISgotTprelHA]]
+  ; LE64-NEXT:   [[ADD8TLS:%[0-9]+]]:g8rc = ADD8TLS killed [[LDgotTprelL]], target-flags(ppc-tls) @tls_var
+  ; LE64-NEXT:   [[COPY2:%[0-9]+]]:gprc = COPY [[ADD8TLS]].sub_32
+  ; LE64-NEXT:   [[ADD4_:%[0-9]+]]:gprc = ADD4 killed [[COPY2]], [[ISEL]]
+  ; LE64-NEXT:   [[DEF1:%[0-9]+]]:g8rc = IMPLICIT_DEF
+  ; LE64-NEXT:   [[INSERT_SUBREG1:%[0-9]+]]:g8rc = INSERT_SUBREG [[DEF1]], killed [[ADD4_]], %subreg.sub_32
+  ; LE64-NEXT:   $x3 = COPY [[INSERT_SUBREG1]]
+  ; LE64-NEXT:   BLR8 implicit $lr8, implicit $rm, implicit $x3
+entry:
+  br label %for.body
+
+for.body:                                         ; preds = %for.body, %entry
+  %phi = phi i32 [ %dec, %for.body ], [ %inp, %entry ]
+  %load = ptrtoint i8* @tls_var to i32
+  %val = add i32 %load, %phi
+  %dec = add i32 %phi, -1
+  %cmp = icmp sgt i32 %phi, 1
+  br i1 %cmp, label %for.body, label %return
+
+return:                                           ; preds = %for.body
+  ret i32 %val
+}
diff --git a/llvm/test/CodeGen/PowerPC/ctrloops32.mir b/llvm/test/CodeGen/PowerPC/ctrloops32.mir
new file mode 100644
index 0000000000000..ffe62cf6a2f75
--- /dev/null
+++ b/llvm/test/CodeGen/PowerPC/ctrloops32.mir
@@ -0,0 +1,345 @@
+# RUN: llc -ppc-asm-full-reg-names -mtriple=powerpc-ibm-aix-xcoff \
+# RUN:   -run-pass=ppc-ctrloops %s -o - -verify-machineinstrs | FileCheck %s 
+
+---
+name:            test_success1
+# CHECK: test_success1
+
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:gprc = LI 2048
+    ; CHECK: MTCTRloop
+    ; CHECK: BDNZ
+    ; CHECK-NOT: ADDI
+    ; CHECK-NOT: CMPLWI
+    ; CHECK-NOT: BC
+    MTCTRloop killed %0:gprc, implicit-def dead $ctr
+
+  bb.1:
+
+    %1:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_fail_clobber
+# CHECK: test_fail_clobber
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:gprc = LI 2048
+    ; CHECK-NOT: MTCTRloop
+    ; CHECK-NOT: BDNZ
+    ; CHECK: ADDI
+    ; CHECK: CMPLWI
+    ; CHECK: BC
+    MTCTRloop killed %0:gprc, implicit-def dead $ctr
+
+  bb.1:
+
+    INLINEASM &"", 1 /* sideeffect attdialect */, 12 /* clobber */, implicit-def early-clobber $ctr
+    %1:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_fail_use_in_loop
+# CHECK: test_fail_use_in_loop
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:gprc = LI 2048
+    ; CHECK-NOT: MTCTRloop
+    ; CHECK-NOT: BDNZ
+    ; CHECK: ADDI
+    ; CHECK: CMPLWI
+    ; CHECK: BC
+    MTCTRloop killed %0:gprc, implicit-def dead $ctr
+
+  bb.1:
+
+    %1:gprc = MFCTR implicit $ctr
+    %2:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %2:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_fail_call_in_preheader_after_mtctr
+# CHECK: test_fail_call_in_preheader_after_mtctr
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:gprc = LI 2048
+    ; CHECK-NOT: MTCTR
+    ; CHECK-NOT: BDNZ
+    ; CHECK: ADDI
+    ; CHECK: CMPLWI
+    ; CHECK: BC
+    MTCTRloop killed %0:gprc, implicit-def dead $ctr
+    BL @test_fail_use_in_loop, csr_aix32, implicit-def dead $lr, implicit $rm
+
+  bb.1:
+
+    %1:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_succ_call_in_preheader_before_mtctr
+# CHECK: test_succ_call_in_preheader_before_mtctr
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:gprc = LI 2048
+    BL @test_fail_use_in_loop, csr_aix32, implicit-def dead $lr, implicit $rm
+    ; CHECK: MTCTR
+    ; CHECK: BDNZ
+    ; CHECK-NOT: ADDI
+    ; CHECK-NOT: CMPLWI
+    ; CHECK-NOT: BC
+    MTCTRloop killed %0:gprc, implicit-def dead $ctr
+
+  bb.1:
+
+    %1:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_fail_call_in_loop
+# CHECK: test_fail_call_in_loop
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:gprc = LI 2048
+    ; CHECK-NOT: MTCTR
+    ; CHECK-NOT: BDNZ
+    ; CHECK: ADDI
+    ; CHECK: CMPLWI
+    ; CHECK: BC
+    MTCTRloop killed %0:gprc, implicit-def dead $ctr
+
+  bb.1:
+
+    BL @test_fail_use_in_loop, csr_aix32, implicit-def dead $lr, implicit $rm
+    %1:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_fail_indirect_call_in_loop
+# CHECK: test_fail_indirect_call_in_loop
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+   liveins: $r3, $r4
+
+    %0:gprc = LI 2048
+    ; CHECK-NOT: MTCTR
+    ; CHECK-NOT: BDNZ
+    ; CHECK: ADDI
+    ; CHECK: CMPLWI
+    ; CHECK: BC
+    renamable %1:crrc = CMPLW killed renamable $r3, killed renamable $r4
+    renamable %2:crbitrc = COPY %1.sub_gt
+    MTLR %0:gprc, implicit-def $lr
+    MTCTRloop %0:gprc, implicit-def dead $ctr
+
+  bb.1:
+
+    BCLRL renamable %2, implicit $lr, implicit $rm
+    %3:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %3:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_fail_livein_preheader
+# CHECK: test_fail_livein_preheader
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+    liveins: $ctr
+
+    %0:gprc = LI 2048
+    ; CHECK-NOT: MTCTRloop
+    ; CHECK-NOT: BDNZ
+    ; CHECK: ADDI
+    ; CHECK: CMPLWI
+    ; CHECK: BC
+    MTCTRloop killed %0:gprc, implicit-def dead $ctr
+
+  bb.1:
+
+    %1:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_fail_def_preheader
+# CHECK: test_fail_def_preheader
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    INLINEASM &"", 1 /* sideeffect attdialect */, 12 /* clobber */, implicit-def early-clobber $ctr
+    %0:gprc = LI 2048
+    ; CHECK-NOT: MTCTRloop
+    ; CHECK-NOT: BDNZ
+    ; CHECK: ADDI
+    ; CHECK: CMPLWI
+    ; CHECK: BC
+    MTCTRloop killed %0:gprc, implicit-def dead $ctr
+
+  bb.1:
+
+    %1:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_success_only_use_preheader
+# CHECK: test_success_only_use_preheader
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:gprc = MFCTR implicit $ctr
+    %1:gprc = LI 2048
+    ; CHECK: MTCTRloop
+    ; CHECK: BDNZ
+    ; CHECK-NOT: ADDI
+    ; CHECK-NOT: CMPLWI
+    ; CHECK-NOT: BC
+    MTCTRloop killed %1:gprc, implicit-def dead $ctr
+
+  bb.1:
+
+    %2:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %2:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_fail_use_after_mtctr
+# CHECK: test_fail_use_after_mtctr
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:gprc = LI 2048
+    ; CHECK-NOT: MTCTRloop
+    ; CHECK-NOT: BDNZ
+    ; CHECK: ADDI
+    ; CHECK: CMPLWI
+    ; CHECK: BC
+    MTCTRloop killed %0:gprc, implicit-def dead $ctr
+    %1:gprc = MFCTR implicit $ctr
+
+  bb.1:
+
+    %2:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %2:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_fail_def_after_mtctr
+# CHECK: test_fail_def_after_mtctr
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:gprc = LI 2048
+    ; CHECK-NOT: MTCTRloop
+    ; CHECK-NOT: BDNZ
+    ; CHECK: ADDI
+    ; CHECK: CMPLWI
+    ; CHECK: BC
+    MTCTRloop killed %0:gprc, implicit-def dead $ctr
+    INLINEASM &"", 1 /* sideeffect attdialect */, 12 /* clobber */, implicit-def early-clobber $ctr
+
+  bb.1:
+
+    %2:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %2:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR implicit $lr, implicit $rm
+...
+---
+name:            test_success_def_after_loop
+# CHECK: test_success_def_after_loop
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:gprc = LI 2048
+    ; CHECK: MTCTRloop
+    ; CHECK: BDNZ
+    ; CHECK-NOT: ADDI
+    ; CHECK-NOT: CMPLWI
+    ; CHECK-NOT: BC
+    MTCTRloop killed %0:gprc, implicit-def dead $ctr
+
+  bb.1:
+
+    %2:crbitrc = DecreaseCTRloop 1, implicit-def dead $ctr, implicit $ctr
+    BC killed %2:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+    INLINEASM &"", 1 /* sideeffect attdialect */, 12 /* clobber */, implicit-def early-clobber $ctr
+
+    BLR implicit $lr, implicit $rm
+...
diff --git a/llvm/test/CodeGen/PowerPC/ctrloops64.mir b/llvm/test/CodeGen/PowerPC/ctrloops64.mir
new file mode 100644
index 0000000000000..8e50c555195b1
--- /dev/null
+++ b/llvm/test/CodeGen/PowerPC/ctrloops64.mir
@@ -0,0 +1,347 @@
+# RUN: llc -ppc-asm-full-reg-names -mtriple=powerpc64le-unknown-linux-gnu \
+# RUN:   -run-pass=ppc-ctrloops %s -o - -verify-machineinstrs | FileCheck %s
+# RUN: llc -ppc-asm-full-reg-names -mtriple=powerpc64-ibm-aix-xcoff \
+# RUN:   -run-pass=ppc-ctrloops %s -o - -verify-machineinstrs | FileCheck %s
+
+---
+name:            test_success1
+# CHECK: test_success1
+
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:g8rc = LI8 2048
+    ; CHECK: MTCTR8loop
+    ; CHECK: BDNZ8
+    ; CHECK-NOT: ADDI8
+    ; CHECK-NOT: CMPLDI
+    ; CHECK-NOT: BC
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+
+  bb.1:
+
+    %1:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_fail_clobber
+# CHECK: test_fail_clobber
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:g8rc = LI8 2048
+    ; CHECK-NOT: MTCTR8loop
+    ; CHECK-NOT: BDNZ8
+    ; CHECK: ADDI8
+    ; CHECK: CMPLDI
+    ; CHECK: BC
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+
+  bb.1:
+
+    INLINEASM &"", 1 /* sideeffect attdialect */, 12 /* clobber */, implicit-def early-clobber $ctr8
+    %1:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_fail_use_in_loop
+# CHECK: test_fail_use_in_loop
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:g8rc = LI8 2048
+    ; CHECK-NOT: MTCTR8loop
+    ; CHECK-NOT: BDNZ8
+    ; CHECK: ADDI8
+    ; CHECK: CMPLDI
+    ; CHECK: BC
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+
+  bb.1:
+
+    %1:g8rc = MFCTR8 implicit $ctr8
+    %2:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %2:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_fail_call_in_preheader_after_mtctr
+# CHECK: test_fail_call_in_preheader_after_mtctr
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:g8rc = LI8 2048
+    ; CHECK-NOT: MTCTR8
+    ; CHECK-NOT: BDNZ8
+    ; CHECK: ADDI8
+    ; CHECK: CMPLDI
+    ; CHECK: BC
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+    BL8 @test_fail_use_in_loop, csr_ppc64, implicit-def dead $lr8, implicit $rm
+
+  bb.1:
+
+    %1:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_succ_call_in_preheader_before_mtctr
+# CHECK: test_succ_call_in_preheader_before_mtctr
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:g8rc = LI8 2048
+    BL8 @test_fail_use_in_loop, csr_ppc64, implicit-def dead $lr8, implicit $rm
+    ; CHECK: MTCTR8
+    ; CHECK: BDNZ8
+    ; CHECK-NOT: ADDI8
+    ; CHECK-NOT: CMPLDI
+    ; CHECK-NOT: BC
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+
+  bb.1:
+
+    %1:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_fail_call_in_loop
+# CHECK: test_fail_call_in_loop
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:g8rc = LI8 2048
+    ; CHECK-NOT: MTCTR8
+    ; CHECK-NOT: BDNZ8
+    ; CHECK: ADDI8
+    ; CHECK: CMPLDI
+    ; CHECK: BC
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+
+  bb.1:
+
+    BL8 @test_fail_use_in_loop, csr_ppc64, implicit-def dead $lr8, implicit $rm
+    %1:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_fail_indirect_call_in_loop
+# CHECK: test_fail_indirect_call_in_loop
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+    liveins: $x3, $x4
+
+    %0:g8rc = LI8 2048
+    ; CHECK-NOT: MTCTR8
+    ; CHECK-NOT: BDNZ8
+    ; CHECK: ADDI8
+    ; CHECK: CMPLDI
+    ; CHECK: BC
+    renamable %1:crrc = CMPLD killed renamable $x3, killed renamable $x4
+    renamable %2:crbitrc = COPY %1.sub_gt
+    MTLR8 %0:g8rc, implicit-def $lr8
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+
+  bb.1:
+
+    BCLRL renamable %2, implicit $lr, implicit $rm
+    %3:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %3:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_fail_livein_preheader
+# CHECK: test_fail_livein_preheader
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+    liveins: $ctr8
+
+    %0:g8rc = LI8 2048
+    ; CHECK-NOT: MTCTR8loop
+    ; CHECK-NOT: BDNZ8
+    ; CHECK: ADDI8
+    ; CHECK: CMPLDI
+    ; CHECK: BC
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+
+  bb.1:
+
+    %1:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_fail_def_preheader
+# CHECK: test_fail_def_preheader
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    INLINEASM &"", 1 /* sideeffect attdialect */, 12 /* clobber */, implicit-def early-clobber $ctr8
+    %0:g8rc = LI8 2048
+    ; CHECK-NOT: MTCTR8loop
+    ; CHECK-NOT: BDNZ8
+    ; CHECK: ADDI8
+    ; CHECK: CMPLDI
+    ; CHECK: BC
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+
+  bb.1:
+
+    %1:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %1:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_success_only_use_preheader
+# CHECK: test_success_only_use_preheader
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:g8rc = MFCTR8 implicit $ctr8
+    %1:g8rc = LI8 2048
+    ; CHECK: MTCTR8loop
+    ; CHECK: BDNZ8
+    ; CHECK-NOT: ADDI8
+    ; CHECK-NOT: CMPLDI
+    ; CHECK-NOT: BC
+    MTCTR8loop killed %1:g8rc, implicit-def dead $ctr8
+
+  bb.1:
+
+    %2:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %2:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_fail_use_after_mtctr
+# CHECK: test_fail_use_after_mtctr
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:g8rc = LI8 2048
+    ; CHECK-NOT: MTCTR8loop
+    ; CHECK-NOT: BDNZ8
+    ; CHECK: ADDI8
+    ; CHECK: CMPLDI
+    ; CHECK: BC
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+    %1:g8rc = MFCTR8 implicit $ctr8
+
+  bb.1:
+
+    %2:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %2:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_fail_def_after_mtctr
+# CHECK: test_fail_def_after_mtctr
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:g8rc = LI8 2048
+    ; CHECK-NOT: MTCTR8loop
+    ; CHECK-NOT: BDNZ8
+    ; CHECK: ADDI8
+    ; CHECK: CMPLDI
+    ; CHECK: BC
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+    INLINEASM &"", 1 /* sideeffect attdialect */, 12 /* clobber */, implicit-def early-clobber $ctr8
+
+  bb.1:
+
+    %2:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %2:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+
+    BLR8 implicit $lr8, implicit $rm
+...
+---
+name:            test_success_def_after_loop
+# CHECK: test_success_def_after_loop
+tracksRegLiveness: true
+body:             |
+  bb.0.entry:
+
+    %0:g8rc = LI8 2048
+    ; CHECK: MTCTR8loop
+    ; CHECK: BDNZ8
+    ; CHECK-NOT: ADDI8
+    ; CHECK-NOT: CMPLDI
+    ; CHECK-NOT: BC
+    MTCTR8loop killed %0:g8rc, implicit-def dead $ctr8
+
+  bb.1:
+
+    %2:crbitrc = DecreaseCTR8loop 1, implicit-def dead $ctr8, implicit $ctr8
+    BC killed %2:crbitrc, %bb.1
+    B %bb.2
+
+  bb.2:
+    INLINEASM &"", 1 /* sideeffect attdialect */, 12 /* clobber */, implicit-def early-clobber $ctr8
+
+    BLR8 implicit $lr8, implicit $rm
+...
diff --git a/llvm/test/CodeGen/PowerPC/issue55983.ll b/llvm/test/CodeGen/PowerPC/issue55983.ll
new file mode 100644
index 0000000000000..7ebde001ada7f
--- /dev/null
+++ b/llvm/test/CodeGen/PowerPC/issue55983.ll
@@ -0,0 +1,66 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -opaque-pointers -mtriple=powerpc64le-unknown-unknown < %s | FileCheck %s
+; RUN: llc -opaque-pointers -mtriple=powerpc64-unknown-unknown < %s | FileCheck %s
+
+define void @foo() #0 {
+; CHECK-LABEL: foo:
+; CHECK:       # %bb.0: # %bb0
+; CHECK-NEXT:    bc 12, 20, .LBB0_2
+; CHECK-NEXT:  # %bb.1: # %bb1
+; CHECK-NEXT:    ld 3, 0(3)
+; CHECK-NEXT:    cmpd 7, 3, 3
+; CHECK-NEXT:    bne- 7, .+4
+; CHECK-NEXT:    isync
+; CHECK-NEXT:  .LBB0_2: # %bb2
+bb0:
+  br i1 undef, label %bb1, label %bb2
+
+bb1:
+  %0 = load atomic {}*, {}** undef acquire, align 8
+  unreachable
+
+bb2:
+  unreachable
+}
+
+define void @bar() #0 {
+; CHECK-LABEL: bar:
+; CHECK:       # %bb.0: # %bb0
+; CHECK-NEXT:    bc 12, 20, .LBB1_2
+; CHECK-NEXT:  # %bb.1: # %bb1
+; CHECK-NEXT:    ld 3, 0(3)
+; CHECK-NEXT:    cmpd 7, 3, 3
+; CHECK-NEXT:    bne- 7, .+4
+; CHECK-NEXT:    isync
+; CHECK-NEXT:  .LBB1_2: # %bb2
+bb0:
+  br i1 undef, label %bb1, label %bb2
+
+bb1:
+  %0 = load atomic ptr, ptr undef acquire, align 8
+  unreachable
+
+bb2:
+  unreachable
+}
+
+define void @foobar() {
+; CHECK-LABEL: foobar:
+; CHECK:       # %bb.0: # %top
+; CHECK-NEXT:    bc 4, 20, .LBB2_2
+; CHECK-NEXT:  # %bb.1: # %err86
+; CHECK-NEXT:  .LBB2_2: # %pass9
+; CHECK-NEXT:    ld 3, 0(3)
+; CHECK-NEXT:    cmpd 7, 3, 3
+; CHECK-NEXT:    bne- 7, .+4
+; CHECK-NEXT:    isync
+top:
+  br i1 undef, label %err86, label %pass9
+
+pass9:                                            ; preds = %top
+  %0 = load atomic {} addrspace(10)*, {} addrspace(10)* addrspace(11)* undef acquire, align 8
+  unreachable
+
+err86:                                            ; preds = %top
+  unreachable
+}
diff --git a/llvm/test/CodeGen/PowerPC/sms-phi.ll b/llvm/test/CodeGen/PowerPC/sms-phi.ll
index 3ddf78157d716..4e9031bced6f4 100644
--- a/llvm/test/CodeGen/PowerPC/sms-phi.ll
+++ b/llvm/test/CodeGen/PowerPC/sms-phi.ll
@@ -4,11 +4,11 @@
 ; RUN:       >/dev/null | FileCheck %s
 define dso_local void @sha512() #0 {
 ;CHECK: prolog:
-;CHECK:        %18:g8rc = ADD8 %24:g8rc, %23:g8rc
+;CHECK:        %{{[0-9]+}}:g8rc = ADD8 %{{[0-9]+}}:g8rc, %{{[0-9]+}}:g8rc
 ;CHECK: epilog:
-;CHECK:        %28:g8rc_and_g8rc_nox0 = PHI %6:g8rc_and_g8rc_nox0, %bb.3, %22:g8rc_and_g8rc_nox0, %bb.4
-;CHECK-NEXT:   %29:g8rc = PHI %12:g8rc, %bb.3, %16:g8rc, %bb.4
-;CHECK-NEXT:   %30:g8rc = PHI %15:g8rc, %bb.3, %19:g8rc, %bb.4
+;CHECK:        %{{[0-9]+}}:g8rc_and_g8rc_nox0 = PHI %{{[0-9]+}}:g8rc_and_g8rc_nox0, %bb.3, %{{[0-9]+}}:g8rc_and_g8rc_nox0, %bb.4
+;CHECK-NEXT:   %{{[0-9]+}}:g8rc = PHI %{{[0-9]+}}:g8rc, %bb.3, %{{[0-9]+}}:g8rc, %bb.4
+;CHECK-NEXT:   %{{[0-9]+}}:g8rc = PHI %{{[0-9]+}}:g8rc, %bb.3, %{{[0-9]+}}:g8rc, %bb.4
   br label %1
 
 1:                                                ; preds = %1, %0
diff --git a/llvm/test/Instrumentation/MemorySanitizer/alloca.ll b/llvm/test/Instrumentation/MemorySanitizer/alloca.ll
index 8264b00c5a0d5..0216f3d20e69b 100644
--- a/llvm/test/Instrumentation/MemorySanitizer/alloca.ll
+++ b/llvm/test/Instrumentation/MemorySanitizer/alloca.ll
@@ -61,6 +61,20 @@ entry:
 ; KMSAN: call void @__msan_poison_alloca(i8* {{.*}}, i64 20,
 ; CHECK: ret void
 
+define void @array32() sanitize_memory {
+entry:
+  %x = alloca i32, i32 5, align 4
+  ret void
+}
+
+; CHECK-LABEL: define void @array32(
+; INLINE: call void @llvm.memset.p0i8.i64(i8* align 4 {{.*}}, i8 -1, i64 20, i1 false)
+; CALL: call void @__msan_poison_stack(i8* {{.*}}, i64 20)
+; ORIGIN: call void @__msan_set_alloca_origin_with_descr(i8* {{.*}}, i64 20,
+; ORIGIN-LEAN: call void @__msan_set_alloca_origin_no_descr(i8* {{.*}}, i64 20,
+; KMSAN: call void @__msan_poison_alloca(i8* {{.*}}, i64 20,
+; CHECK: ret void
+
 define void @array_non_const(i64 %cnt) sanitize_memory {
 entry:
   %x = alloca i32, i64 %cnt, align 4
@@ -75,6 +89,22 @@ entry:
 ; KMSAN: call void @__msan_poison_alloca(i8* {{.*}}, i64 %[[A]],
 ; CHECK: ret void
 
+define void @array_non_const32(i32 %cnt) sanitize_memory {
+entry:
+  %x = alloca i32, i32 %cnt, align 4
+  ret void
+}
+
+; CHECK-LABEL: define void @array_non_const32(
+; CHECK: %[[Z:.*]] = zext i32 %cnt to i64
+; CHECK: %[[A:.*]] = mul i64 4, %[[Z]]
+; INLINE: call void @llvm.memset.p0i8.i64(i8* align 4 {{.*}}, i8 -1, i64 %[[A]], i1 false)
+; CALL: call void @__msan_poison_stack(i8* {{.*}}, i64 %[[A]])
+; ORIGIN: call void @__msan_set_alloca_origin_with_descr(i8* {{.*}}, i64 %[[A]],
+; ORIGIN-LEAN: call void @__msan_set_alloca_origin_no_descr(i8* {{.*}}, i64 %[[A]],
+; KMSAN: call void @__msan_poison_alloca(i8* {{.*}}, i64 %[[A]],
+; CHECK: ret void
+
 ; Check that the local is unpoisoned in the absence of sanitize_memory
 define void @unpoison_local() {
 entry:
diff --git a/llvm/test/Instrumentation/MemorySanitizer/atomics.ll b/llvm/test/Instrumentation/MemorySanitizer/atomics.ll
index f6d326e52eab2..82079252c6b47 100644
--- a/llvm/test/Instrumentation/MemorySanitizer/atomics.ll
+++ b/llvm/test/Instrumentation/MemorySanitizer/atomics.ll
@@ -25,6 +25,20 @@ entry:
 ; CHECK: store i32 0, {{.*}} @__msan_retval_tls
 ; CHECK: ret i32
 
+; atomicrmw xchg ptr: exactly the same as above
+
+define i32* @AtomicRmwXchgPtr(i32** %p, i32* %x) sanitize_memory {
+entry:
+  %0 = atomicrmw xchg i32** %p, i32* %x seq_cst
+  ret i32* %0
+}
+
+; CHECK-LABEL: @AtomicRmwXchgPtr
+; CHECK: store i64 0,
+; CHECK: atomicrmw xchg {{.*}} seq_cst
+; CHECK: store i64 0, {{.*}} @__msan_retval_tls
+; CHECK: ret i32*
+
 
 ; atomicrmw max: exactly the same as above
 
diff --git a/llvm/test/MC/COFF/diff.s b/llvm/test/MC/COFF/diff.s
index 90466b59d0252..640bf8189e039 100644
--- a/llvm/test/MC/COFF/diff.s
+++ b/llvm/test/MC/COFF/diff.s
@@ -1,14 +1,19 @@
 // RUN: llvm-mc -filetype=obj -triple i686-pc-mingw32 %s | llvm-readobj -S --sr --sd - | FileCheck %s
 
-// COFF resolves differences between labels in the same section, unless that
-// label is declared with function type.
-
 .section baz, "xr"
+	.def	X
+	.scl	2;
+	.type	32;
+	.endef
 	.globl	X
 X:
 	mov	Y-X+42,	%eax
 	retl
 
+	.def	Y
+	.scl	2;
+	.type	32;
+	.endef
 	.globl	Y
 Y:
 	retl
@@ -25,11 +30,6 @@ _foobar:                                # @foobar
 # %bb.0:
 	ret
 
-	.globl	_baz
-_baz:
-	calll	_foobar
-	retl
-
 	.data
 	.globl	_rust_crate             # @rust_crate
 	.align	4
@@ -39,15 +39,6 @@ _rust_crate:
 	.long	_foobar-_rust_crate
 	.long	_foobar-_rust_crate
 
-// Even though _baz and _foobar are in the same .text section, we keep the
-// relocation for compatibility with the VC linker's /guard:cf and /incremental
-// flags, even on mingw.
-
-// CHECK:        Name: .text
-// CHECK:        Relocations [
-// CHECK-NEXT:     0x12 IMAGE_REL_I386_REL32 _foobar
-// CHECK-NEXT:   ]
-
 // CHECK:        Name: .data
 // CHECK:        Relocations [
 // CHECK-NEXT:     0x4 IMAGE_REL_I386_DIR32 _foobar
diff --git a/llvm/test/MC/COFF/weak-uaf.ll b/llvm/test/MC/COFF/weak-uaf.ll
new file mode 100644
index 0000000000000..d0df144358c95
--- /dev/null
+++ b/llvm/test/MC/COFF/weak-uaf.ll
@@ -0,0 +1,12 @@
+; RUN: llc --compile-twice -mtriple=x86_64-pc-win32 -filetype=obj < %s
+
+; UAF when re-using the MCObjectWriter. does not leak into the output,
+; but should be detectable with --compile-twice under ASAN or so.
+
+define weak void @foo() nounwind {
+  ret void
+}
+
+define weak void @bar() nounwind {
+  ret void
+}
diff --git a/llvm/test/Other/loop-print-after-pass-invalidated.ll b/llvm/test/Other/loop-print-after-pass-invalidated.ll
new file mode 100644
index 0000000000000..63106f62ae132
--- /dev/null
+++ b/llvm/test/Other/loop-print-after-pass-invalidated.ll
@@ -0,0 +1,21 @@
+; RUN: opt < %s 2>&1 -disable-output \
+; RUN: 	   -passes='simple-loop-unswitch<nontrivial>' \
+; RUN:     -print-after=simple-loop-unswitch \
+; RUN:	   | FileCheck %s
+
+; CHECK: *** IR Dump After SimpleLoopUnswitchPass on for.cond ***
+; CHECK: *** IR Dump After SimpleLoopUnswitchPass on for.cond.us ***
+
+define void @loop(i1 %w)  {
+entry:
+  br label %for.cond
+; Loop:
+for.cond:                                         ; preds = %for.inc, %entry
+  br i1 %w, label %for.inc, label %if.then
+
+if.then:                                          ; preds = %for.cond
+  br label %for.inc
+
+for.inc:                                          ; preds = %if.then, %for.cond
+  br label %for.cond
+}
diff --git a/llvm/test/Transforms/AtomicExpand/PowerPC/issue55983.ll b/llvm/test/Transforms/AtomicExpand/PowerPC/issue55983.ll
new file mode 100644
index 0000000000000..50f222a2b7431
--- /dev/null
+++ b/llvm/test/Transforms/AtomicExpand/PowerPC/issue55983.ll
@@ -0,0 +1,71 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
+; RUN: opt -opaque-pointers -atomic-expand -S -mtriple=powerpc64le-unknown-unknown \
+; RUN:   %s | FileCheck %s
+; RUN: opt -opaque-pointers -atomic-expand -S -mtriple=powerpc64-unknown-unknown \
+; RUN:   %s | FileCheck %s
+
+define void @foo() #0 {
+; CHECK-LABEL: @foo(
+; CHECK-NEXT:  bb0:
+; CHECK-NEXT:    br i1 undef, label [[BB1:%.*]], label [[BB2:%.*]]
+; CHECK:       bb1:
+; CHECK-NEXT:    [[TMP0:%.*]] = load atomic ptr, ptr undef monotonic, align 8
+; CHECK-NEXT:    call void @llvm.ppc.cfence.p0(ptr [[TMP0]])
+; CHECK-NEXT:    unreachable
+; CHECK:       bb2:
+; CHECK-NEXT:    unreachable
+;
+bb0:
+  br i1 undef, label %bb1, label %bb2
+
+bb1:
+  %0 = load atomic {}*, {}** undef acquire, align 8
+  unreachable
+
+bb2:
+  unreachable
+}
+
+define void @bar() #0 {
+; CHECK-LABEL: @bar(
+; CHECK-NEXT:  bb0:
+; CHECK-NEXT:    br i1 undef, label [[BB1:%.*]], label [[BB2:%.*]]
+; CHECK:       bb1:
+; CHECK-NEXT:    [[TMP0:%.*]] = load atomic ptr, ptr undef monotonic, align 8
+; CHECK-NEXT:    call void @llvm.ppc.cfence.p0(ptr [[TMP0]])
+; CHECK-NEXT:    unreachable
+; CHECK:       bb2:
+; CHECK-NEXT:    unreachable
+;
+bb0:
+  br i1 undef, label %bb1, label %bb2
+
+bb1:
+  %0 = load atomic ptr, ptr undef acquire, align 8
+  unreachable
+
+bb2:
+  unreachable
+}
+
+define void @foobar() {
+; CHECK-LABEL: @foobar(
+; CHECK-NEXT:  top:
+; CHECK-NEXT:    br i1 undef, label [[ERR86:%.*]], label [[PASS9:%.*]]
+; CHECK:       pass9:
+; CHECK-NEXT:    [[TMP0:%.*]] = load atomic ptr addrspace(10), ptr addrspace(11) undef monotonic, align 8
+; CHECK-NEXT:    call void @llvm.ppc.cfence.p10(ptr addrspace(10) [[TMP0]])
+; CHECK-NEXT:    unreachable
+; CHECK:       err86:
+; CHECK-NEXT:    unreachable
+;
+top:
+  br i1 undef, label %err86, label %pass9
+
+pass9:                                            ; preds = %top
+  %0 = load atomic {} addrspace(10)*, {} addrspace(10)* addrspace(11)* undef acquire, align 8
+  unreachable
+
+err86:                                            ; preds = %top
+  unreachable
+}
diff --git a/llvm/test/Transforms/CodeGenPrepare/NVPTX/dont-introduce-addrspacecast.ll b/llvm/test/Transforms/CodeGenPrepare/NVPTX/dont-introduce-addrspacecast.ll
new file mode 100644
index 0000000000000..39e50241c9cc6
--- /dev/null
+++ b/llvm/test/Transforms/CodeGenPrepare/NVPTX/dont-introduce-addrspacecast.ll
@@ -0,0 +1,43 @@
+; RUN: opt -S -codegenprepare < %s | FileCheck %s
+
+target datalayout = "e-i64:64-v16:16-v32:32-n16:32:64"
+target triple = "nvptx64-nvidia-cuda"
+
+
+; ptrtoint/inttoptr combinations can introduce semantically-meaningful address space casts
+; which we can't sink into an addrspacecast
+
+; CHECK-LABEL: @test
+define void @test(i8* %input_ptr) {
+  ; CHECK-LABEL: l1:
+  ; CHECK-NOT: addrspacecast
+  %intptr = ptrtoint i8* %input_ptr to i64
+  %ptr = inttoptr i64 %intptr to i32 addrspace(3)*
+
+  br label %l1
+l1:
+
+  store atomic i32 1, i32 addrspace(3)* %ptr unordered, align 4
+  ret void
+}
+
+
+; we still should be able to look through multiple sequences of inttoptr/ptrtoint
+
+; CHECK-LABEL: @test2
+define void @test2(i8* %input_ptr) {
+  ; CHECK-LABEL: l2:
+  ; CHECK: bitcast
+  ; CHECK-NEXT: store
+  %intptr = ptrtoint i8* %input_ptr to i64
+  %ptr = inttoptr i64 %intptr to i32 addrspace(3)*
+
+  %intptr2 = ptrtoint i32 addrspace(3)* %ptr to i64
+  %ptr2 = inttoptr i64 %intptr2 to i32*
+
+  br label %l2
+l2:
+
+  store atomic i32 1, i32* %ptr2 unordered, align 4
+  ret void
+}
diff --git a/llvm/test/Transforms/CorrelatedValuePropagation/basic.ll b/llvm/test/Transforms/CorrelatedValuePropagation/basic.ll
index aa1d305f63bb6..84f5b22305941 100644
--- a/llvm/test/Transforms/CorrelatedValuePropagation/basic.ll
+++ b/llvm/test/Transforms/CorrelatedValuePropagation/basic.ll
@@ -1769,6 +1769,63 @@ define void @select_assume(i32 %a, i32 %b, i1 %c, i1* %p) {
 }
 
 
+define i1 @xor_neg_cond(i32 %a) {
+; CHECK-LABEL: @xor_neg_cond(
+; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[A:%.*]], 10
+; CHECK-NEXT:    [[XOR:%.*]] = xor i1 [[CMP1]], true
+; CHECK-NEXT:    br i1 [[XOR]], label [[EXIT:%.*]], label [[GUARD:%.*]]
+; CHECK:       guard:
+; CHECK-NEXT:    ret i1 true
+; CHECK:       exit:
+; CHECK-NEXT:    ret i1 false
+;
+  %cmp1 = icmp eq i32 %a, 10
+  %xor = xor i1 %cmp1, true
+  br i1 %xor, label %exit, label %guard
+
+guard:
+  %cmp2 = icmp eq i32 %a, 10
+  ret i1 %cmp2
+
+exit:
+  ret i1 false
+}
+
+define i1 @xor_approx(i32 %a) {
+; CHECK-LABEL: @xor_approx(
+; CHECK-NEXT:    [[CMP1:%.*]] = icmp ugt i32 [[A:%.*]], 2
+; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[A]], 5
+; CHECK-NEXT:    [[CMP3:%.*]] = icmp ugt i32 [[A]], 7
+; CHECK-NEXT:    [[CMP4:%.*]] = icmp ult i32 [[A]], 9
+; CHECK-NEXT:    [[AND1:%.*]] = and i1 [[CMP1]], [[CMP2]]
+; CHECK-NEXT:    [[AND2:%.*]] = and i1 [[CMP3]], [[CMP4]]
+; CHECK-NEXT:    [[OR:%.*]] = or i1 [[AND1]], [[AND2]]
+; CHECK-NEXT:    [[XOR:%.*]] = xor i1 [[OR]], true
+; CHECK-NEXT:    br i1 [[XOR]], label [[EXIT:%.*]], label [[GUARD:%.*]]
+; CHECK:       guard:
+; CHECK-NEXT:    [[CMP5:%.*]] = icmp eq i32 [[A]], 6
+; CHECK-NEXT:    ret i1 [[CMP5]]
+; CHECK:       exit:
+; CHECK-NEXT:    ret i1 false
+;
+  %cmp1 = icmp ugt i32 %a, 2
+  %cmp2 = icmp ult i32 %a, 5
+  %cmp3 = icmp ugt i32 %a, 7
+  %cmp4 = icmp ult i32 %a, 9
+  %and1 = and i1 %cmp1, %cmp2
+  %and2 = and i1 %cmp3, %cmp4
+  %or = or i1 %and1, %and2
+  %xor = xor i1 %or, true
+  br i1 %xor, label %exit, label %guard
+
+guard:
+  %cmp5 = icmp eq i32 %a, 6
+  ret i1 %cmp5
+
+exit:
+  ret i1 false
+}
+
 declare i32 @llvm.uadd.sat.i32(i32, i32)
 declare i32 @llvm.usub.sat.i32(i32, i32)
 declare i32 @llvm.sadd.sat.i32(i32, i32)
diff --git a/llvm/test/Transforms/LICM/invariant.group.ll b/llvm/test/Transforms/LICM/invariant.group.ll
new file mode 100644
index 0000000000000..fbd08cf78cc7a
--- /dev/null
+++ b/llvm/test/Transforms/LICM/invariant.group.ll
@@ -0,0 +1,69 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
+; RUN: opt -passes=licm < %s -S | FileCheck %s
+
+define void @test(i32* %arg, i32* %arg1) {
+; CHECK-LABEL: @test(
+; CHECK-NEXT:  bb2:
+; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32* [[ARG1:%.*]], align 4, !invariant.group !0
+; CHECK-NEXT:    br label [[BB5:%.*]]
+; CHECK:       bb5:
+; CHECK-NEXT:    [[TMP6:%.*]] = phi i64 [ 0, [[BB2:%.*]] ], [ [[TMP10:%.*]], [[BB5]] ]
+; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, i32* [[ARG:%.*]], i64 [[TMP6]]
+; CHECK-NEXT:    store i32 [[TMP3]], i32* [[TMP7]], align 8
+; CHECK-NEXT:    [[TMP10]] = add nuw nsw i64 [[TMP6]], 1
+; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[TMP10]], 200
+; CHECK-NEXT:    br i1 [[TMP11]], label [[BB12:%.*]], label [[BB5]]
+; CHECK:       bb12:
+; CHECK-NEXT:    ret void
+;
+bb2:                                              ; preds = %bb
+  br label %bb5
+
+bb5:                                              ; preds = %bb5, %bb2
+  %tmp6 = phi i64 [ 0, %bb2 ], [ %tmp10, %bb5 ]
+  %tmp3 = load i32, i32* %arg1, align 4, !invariant.group !0
+  %tmp7 = getelementptr inbounds i32, i32* %arg, i64 %tmp6
+  store i32 %tmp3, i32* %tmp7, align 8
+  %tmp10 = add nuw nsw i64 %tmp6, 1
+  %tmp11 = icmp eq i64 %tmp10, 200
+  br i1 %tmp11, label %bb12, label %bb5
+
+bb12:                                             ; preds = %bb5, %bb
+  ret void
+}
+
+
+define void @test_fail(i32* %arg, i32* %arg1) {
+; CHECK-LABEL: @test_fail(
+; CHECK-NEXT:  bb2:
+; CHECK-NEXT:    br label [[BB5:%.*]]
+; CHECK:       bb5:
+; CHECK-NEXT:    [[TMP6:%.*]] = phi i64 [ 0, [[BB2:%.*]] ], [ [[TMP10:%.*]], [[BB5]] ]
+; CHECK-NEXT:    store i32 3, i32* [[ARG1:%.*]], align 4
+; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32* [[ARG1]], align 4, !invariant.group !0
+; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, i32* [[ARG:%.*]], i64 [[TMP6]]
+; CHECK-NEXT:    store i32 [[TMP3]], i32* [[TMP7]], align 8
+; CHECK-NEXT:    [[TMP10]] = add nuw nsw i64 [[TMP6]], 1
+; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[TMP10]], 200
+; CHECK-NEXT:    br i1 [[TMP11]], label [[BB12:%.*]], label [[BB5]]
+; CHECK:       bb12:
+; CHECK-NEXT:    ret void
+;
+bb2:                                              ; preds = %bb
+  br label %bb5
+
+bb5:                                              ; preds = %bb5, %bb2
+  %tmp6 = phi i64 [ 0, %bb2 ], [ %tmp10, %bb5 ]
+  store i32 3, i32* %arg1
+  %tmp3 = load i32, i32* %arg1, align 4, !invariant.group !0
+  %tmp7 = getelementptr inbounds i32, i32* %arg, i64 %tmp6
+  store i32 %tmp3, i32* %tmp7, align 8
+  %tmp10 = add nuw nsw i64 %tmp6, 1
+  %tmp11 = icmp eq i64 %tmp10, 200
+  br i1 %tmp11, label %bb12, label %bb5
+
+bb12:                                             ; preds = %bb5, %bb
+  ret void
+}
+
+!0 = !{}
diff --git a/llvm/test/Transforms/LoopVectorize/X86/pr54634.ll b/llvm/test/Transforms/LoopVectorize/X86/pr54634.ll
new file mode 100644
index 0000000000000..5419efd454c73
--- /dev/null
+++ b/llvm/test/Transforms/LoopVectorize/X86/pr54634.ll
@@ -0,0 +1,155 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
+; RUN: opt -S -loop-vectorize < %s -mcpu=skylake | FileCheck %s
+target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:10:11:12:13"
+target triple = "x86_64-unknown-linux-gnu"
+
+@jlplt_ijl_alloc_array_1d_10294_got = external dso_local local_unnamed_addr global void ()*
+
+define {} addrspace(10)* @japi1_vect_42283({} addrspace(10)** nocapture readonly %0, i32 %1) local_unnamed_addr #0 {
+; CHECK-LABEL: @japi1_vect_42283(
+; CHECK-NEXT:  top:
+; CHECK-NEXT:    [[TMP2:%.*]] = sext i32 [[TMP1:%.*]] to i64
+; CHECK-NEXT:    [[TMP3:%.*]] = load atomic {} addrspace(10)* ({} addrspace(10)*, i64)*, {} addrspace(10)* ({} addrspace(10)*, i64)** bitcast (void ()** @jlplt_ijl_alloc_array_1d_10294_got to {} addrspace(10)* ({} addrspace(10)*, i64)**) unordered, align 8
+; CHECK-NEXT:    [[TMP4:%.*]] = tail call {} addrspace(10)* [[TMP3]]({} addrspace(10)* null, i64 0)
+; CHECK-NEXT:    [[TMP5:%.*]] = bitcast {} addrspace(10)** [[TMP0:%.*]] to { {} addrspace(10)*, i64 } addrspace(10)**
+; CHECK-NEXT:    [[TMP6:%.*]] = load { {} addrspace(10)*, i64 } addrspace(10)*, { {} addrspace(10)*, i64 } addrspace(10)** [[TMP5]], align 8, !tbaa [[TBAA0:![0-9]+]]
+; CHECK-NEXT:    [[TMP7:%.*]] = bitcast {} addrspace(10)* [[TMP4]] to { {} addrspace(10)*, i64 } addrspace(13)* addrspace(10)*
+; CHECK-NEXT:    [[TMP8:%.*]] = addrspacecast { {} addrspace(10)*, i64 } addrspace(13)* addrspace(10)* [[TMP7]] to { {} addrspace(10)*, i64 } addrspace(13)* addrspace(11)*
+; CHECK-NEXT:    [[TMP9:%.*]] = load { {} addrspace(10)*, i64 } addrspace(13)*, { {} addrspace(10)*, i64 } addrspace(13)* addrspace(11)* [[TMP8]], align 8, !tbaa [[TBAA5:![0-9]+]]
+; CHECK-NEXT:    [[TMP10:%.*]] = bitcast { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]] to i8 addrspace(13)*
+; CHECK-NEXT:    [[DOTELT:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(10)* [[TMP6]], i64 0, i32 0
+; CHECK-NEXT:    [[DOTUNPACK:%.*]] = load {} addrspace(10)*, {} addrspace(10)* addrspace(10)* [[DOTELT]], align 8, !tbaa [[TBAA8:![0-9]+]]
+; CHECK-NEXT:    [[DOTELT1:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(10)* [[TMP6]], i64 0, i32 1
+; CHECK-NEXT:    [[DOTUNPACK2:%.*]] = load i64, i64 addrspace(10)* [[DOTELT1]], align 8, !tbaa [[TBAA8]]
+; CHECK-NEXT:    [[TMP11:%.*]] = add nsw i64 [[TMP2]], 1
+; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[TMP11]], 16
+; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_SCEVCHECK:%.*]]
+; CHECK:       vector.scevcheck:
+; CHECK-NEXT:    [[MUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 16, i64 [[TMP2]])
+; CHECK-NEXT:    [[MUL_RESULT:%.*]] = extractvalue { i64, i1 } [[MUL]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW:%.*]] = extractvalue { i64, i1 } [[MUL]], 1
+; CHECK-NEXT:    [[TMP12:%.*]] = sub i64 0, [[MUL_RESULT]]
+; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr i8, i8 addrspace(13)* [[TMP10]], i64 [[MUL_RESULT]]
+; CHECK-NEXT:    [[TMP14:%.*]] = icmp ult i8 addrspace(13)* [[TMP13]], [[TMP10]]
+; CHECK-NEXT:    [[TMP15:%.*]] = or i1 [[TMP14]], [[MUL_OVERFLOW]]
+; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]], i64 0, i32 1
+; CHECK-NEXT:    [[SCEVGEP1:%.*]] = bitcast i64 addrspace(13)* [[SCEVGEP]] to { {} addrspace(10)*, i64 } addrspace(13)*
+; CHECK-NEXT:    [[MUL2:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 16, i64 [[TMP2]])
+; CHECK-NEXT:    [[MUL_RESULT3:%.*]] = extractvalue { i64, i1 } [[MUL2]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW4:%.*]] = extractvalue { i64, i1 } [[MUL2]], 1
+; CHECK-NEXT:    [[SCEVGEP15:%.*]] = bitcast { {} addrspace(10)*, i64 } addrspace(13)* [[SCEVGEP1]] to i8 addrspace(13)*
+; CHECK-NEXT:    [[TMP16:%.*]] = sub i64 0, [[MUL_RESULT3]]
+; CHECK-NEXT:    [[TMP17:%.*]] = getelementptr i8, i8 addrspace(13)* [[SCEVGEP15]], i64 [[MUL_RESULT3]]
+; CHECK-NEXT:    [[TMP18:%.*]] = icmp ult i8 addrspace(13)* [[TMP17]], [[SCEVGEP15]]
+; CHECK-NEXT:    [[TMP19:%.*]] = or i1 [[TMP18]], [[MUL_OVERFLOW4]]
+; CHECK-NEXT:    [[TMP20:%.*]] = or i1 [[TMP15]], [[TMP19]]
+; CHECK-NEXT:    br i1 [[TMP20]], label [[SCALAR_PH]], label [[VECTOR_PH:%.*]]
+; CHECK:       vector.ph:
+; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[TMP11]], 16
+; CHECK-NEXT:    [[N_VEC:%.*]] = sub i64 [[TMP11]], [[N_MOD_VF]]
+; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x {} addrspace(10)*> poison, {} addrspace(10)* [[DOTUNPACK]], i32 0
+; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x {} addrspace(10)*> [[BROADCAST_SPLATINSERT]], <4 x {} addrspace(10)*> poison, <4 x i32> zeroinitializer
+; CHECK-NEXT:    [[BROADCAST_SPLATINSERT9:%.*]] = insertelement <4 x {} addrspace(10)*> poison, {} addrspace(10)* [[DOTUNPACK]], i32 0
+; CHECK-NEXT:    [[BROADCAST_SPLAT10:%.*]] = shufflevector <4 x {} addrspace(10)*> [[BROADCAST_SPLATINSERT9]], <4 x {} addrspace(10)*> poison, <4 x i32> zeroinitializer
+; CHECK-NEXT:    [[BROADCAST_SPLATINSERT11:%.*]] = insertelement <4 x {} addrspace(10)*> poison, {} addrspace(10)* [[DOTUNPACK]], i32 0
+; CHECK-NEXT:    [[BROADCAST_SPLAT12:%.*]] = shufflevector <4 x {} addrspace(10)*> [[BROADCAST_SPLATINSERT11]], <4 x {} addrspace(10)*> poison, <4 x i32> zeroinitializer
+; CHECK-NEXT:    [[BROADCAST_SPLATINSERT13:%.*]] = insertelement <4 x {} addrspace(10)*> poison, {} addrspace(10)* [[DOTUNPACK]], i32 0
+; CHECK-NEXT:    [[BROADCAST_SPLAT14:%.*]] = shufflevector <4 x {} addrspace(10)*> [[BROADCAST_SPLATINSERT13]], <4 x {} addrspace(10)*> poison, <4 x i32> zeroinitializer
+; CHECK-NEXT:    [[BROADCAST_SPLATINSERT15:%.*]] = insertelement <4 x i64> poison, i64 [[DOTUNPACK2]], i32 0
+; CHECK-NEXT:    [[BROADCAST_SPLAT16:%.*]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT15]], <4 x i64> poison, <4 x i32> zeroinitializer
+; CHECK-NEXT:    [[BROADCAST_SPLATINSERT17:%.*]] = insertelement <4 x i64> poison, i64 [[DOTUNPACK2]], i32 0
+; CHECK-NEXT:    [[BROADCAST_SPLAT18:%.*]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT17]], <4 x i64> poison, <4 x i32> zeroinitializer
+; CHECK-NEXT:    [[BROADCAST_SPLATINSERT19:%.*]] = insertelement <4 x i64> poison, i64 [[DOTUNPACK2]], i32 0
+; CHECK-NEXT:    [[BROADCAST_SPLAT20:%.*]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT19]], <4 x i64> poison, <4 x i32> zeroinitializer
+; CHECK-NEXT:    [[BROADCAST_SPLATINSERT21:%.*]] = insertelement <4 x i64> poison, i64 [[DOTUNPACK2]], i32 0
+; CHECK-NEXT:    [[BROADCAST_SPLAT22:%.*]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT21]], <4 x i64> poison, <4 x i32> zeroinitializer
+; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
+; CHECK:       vector.body:
+; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
+; CHECK-NEXT:    [[VEC_IND:%.*]] = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
+; CHECK-NEXT:    [[STEP_ADD:%.*]] = add <4 x i64> [[VEC_IND]], <i64 4, i64 4, i64 4, i64 4>
+; CHECK-NEXT:    [[STEP_ADD6:%.*]] = add <4 x i64> [[STEP_ADD]], <i64 4, i64 4, i64 4, i64 4>
+; CHECK-NEXT:    [[STEP_ADD7:%.*]] = add <4 x i64> [[STEP_ADD6]], <i64 4, i64 4, i64 4, i64 4>
+; CHECK-NEXT:    [[TMP21:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]], <4 x i64> [[VEC_IND]], i32 0
+; CHECK-NEXT:    [[TMP22:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]], <4 x i64> [[STEP_ADD]], i32 0
+; CHECK-NEXT:    [[TMP23:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]], <4 x i64> [[STEP_ADD6]], i32 0
+; CHECK-NEXT:    [[TMP24:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]], <4 x i64> [[STEP_ADD7]], i32 0
+; CHECK-NEXT:    call void @llvm.masked.scatter.v4p10sl_s.v4p13p10sl_s(<4 x {} addrspace(10)*> [[BROADCAST_SPLAT]], <4 x {} addrspace(10)* addrspace(13)*> [[TMP21]], i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>), !tbaa [[TBAA10:![0-9]+]]
+; CHECK-NEXT:    call void @llvm.masked.scatter.v4p10sl_s.v4p13p10sl_s(<4 x {} addrspace(10)*> [[BROADCAST_SPLAT10]], <4 x {} addrspace(10)* addrspace(13)*> [[TMP22]], i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>), !tbaa [[TBAA10]]
+; CHECK-NEXT:    call void @llvm.masked.scatter.v4p10sl_s.v4p13p10sl_s(<4 x {} addrspace(10)*> [[BROADCAST_SPLAT12]], <4 x {} addrspace(10)* addrspace(13)*> [[TMP23]], i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>), !tbaa [[TBAA10]]
+; CHECK-NEXT:    call void @llvm.masked.scatter.v4p10sl_s.v4p13p10sl_s(<4 x {} addrspace(10)*> [[BROADCAST_SPLAT14]], <4 x {} addrspace(10)* addrspace(13)*> [[TMP24]], i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>), !tbaa [[TBAA10]]
+; CHECK-NEXT:    [[TMP25:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]], <4 x i64> [[VEC_IND]], i32 1
+; CHECK-NEXT:    [[TMP26:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]], <4 x i64> [[STEP_ADD]], i32 1
+; CHECK-NEXT:    [[TMP27:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]], <4 x i64> [[STEP_ADD6]], i32 1
+; CHECK-NEXT:    [[TMP28:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]], <4 x i64> [[STEP_ADD7]], i32 1
+; CHECK-NEXT:    call void @llvm.masked.scatter.v4i64.v4p13i64(<4 x i64> [[BROADCAST_SPLAT16]], <4 x i64 addrspace(13)*> [[TMP25]], i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>), !tbaa [[TBAA10]]
+; CHECK-NEXT:    call void @llvm.masked.scatter.v4i64.v4p13i64(<4 x i64> [[BROADCAST_SPLAT18]], <4 x i64 addrspace(13)*> [[TMP26]], i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>), !tbaa [[TBAA10]]
+; CHECK-NEXT:    call void @llvm.masked.scatter.v4i64.v4p13i64(<4 x i64> [[BROADCAST_SPLAT20]], <4 x i64 addrspace(13)*> [[TMP27]], i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>), !tbaa [[TBAA10]]
+; CHECK-NEXT:    call void @llvm.masked.scatter.v4i64.v4p13i64(<4 x i64> [[BROADCAST_SPLAT22]], <4 x i64 addrspace(13)*> [[TMP28]], i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>), !tbaa [[TBAA10]]
+; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 16
+; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <4 x i64> [[STEP_ADD7]], <i64 4, i64 4, i64 4, i64 4>
+; CHECK-NEXT:    [[TMP29:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
+; CHECK-NEXT:    br i1 [[TMP29]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP12:![0-9]+]]
+; CHECK:       middle.block:
+; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[TMP11]], [[N_VEC]]
+; CHECK-NEXT:    br i1 [[CMP_N]], label [[L44:%.*]], label [[SCALAR_PH]]
+; CHECK:       scalar.ph:
+; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[TOP:%.*]] ], [ 0, [[VECTOR_SCEVCHECK]] ]
+; CHECK-NEXT:    br label [[L26:%.*]]
+; CHECK:       L26:
+; CHECK-NEXT:    [[VALUE_PHI5:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[TMP30:%.*]], [[L26]] ]
+; CHECK-NEXT:    [[DOTREPACK:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]], i64 [[VALUE_PHI5]], i32 0
+; CHECK-NEXT:    store {} addrspace(10)* [[DOTUNPACK]], {} addrspace(10)* addrspace(13)* [[DOTREPACK]], align 8, !tbaa [[TBAA10]]
+; CHECK-NEXT:    [[DOTREPACK4:%.*]] = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* [[TMP9]], i64 [[VALUE_PHI5]], i32 1
+; CHECK-NEXT:    store i64 [[DOTUNPACK2]], i64 addrspace(13)* [[DOTREPACK4]], align 8, !tbaa [[TBAA10]]
+; CHECK-NEXT:    [[TMP30]] = add i64 [[VALUE_PHI5]], 1
+; CHECK-NEXT:    [[DOTNOT:%.*]] = icmp eq i64 [[VALUE_PHI5]], [[TMP2]]
+; CHECK-NEXT:    br i1 [[DOTNOT]], label [[L44]], label [[L26]], !llvm.loop [[LOOP14:![0-9]+]]
+; CHECK:       L44:
+; CHECK-NEXT:    ret {} addrspace(10)* null
+;
+top:
+  %2 = sext i32 %1 to i64
+  %3 = load atomic {} addrspace(10)* ({} addrspace(10)*, i64)*, {} addrspace(10)* ({} addrspace(10)*, i64)** bitcast (void ()** @jlplt_ijl_alloc_array_1d_10294_got to {} addrspace(10)* ({} addrspace(10)*, i64)**) unordered, align 8
+  %4 = tail call {} addrspace(10)* %3({} addrspace(10)* null, i64 0)
+  %5 = bitcast {} addrspace(10)** %0 to { {} addrspace(10)*, i64 } addrspace(10)**
+  %6 = load { {} addrspace(10)*, i64 } addrspace(10)*, { {} addrspace(10)*, i64 } addrspace(10)** %5, align 8, !tbaa !0
+  %7 = bitcast {} addrspace(10)* %4 to { {} addrspace(10)*, i64 } addrspace(13)* addrspace(10)*
+  %8 = addrspacecast { {} addrspace(10)*, i64 } addrspace(13)* addrspace(10)* %7 to { {} addrspace(10)*, i64 } addrspace(13)* addrspace(11)*
+  %9 = load { {} addrspace(10)*, i64 } addrspace(13)*, { {} addrspace(10)*, i64 } addrspace(13)* addrspace(11)* %8, align 8, !tbaa !5
+  %.elt = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(10)* %6, i64 0, i32 0
+  %.unpack = load {} addrspace(10)*, {} addrspace(10)* addrspace(10)* %.elt, align 8, !tbaa !8
+  %.elt1 = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(10)* %6, i64 0, i32 1
+  %.unpack2 = load i64, i64 addrspace(10)* %.elt1, align 8, !tbaa !8
+  br label %L26
+
+L26:                                              ; preds = %L26, %top
+  %value_phi5 = phi i64 [ 0, %top ], [ %10, %L26 ]
+  %.repack = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* %9, i64 %value_phi5, i32 0
+  store {} addrspace(10)* %.unpack, {} addrspace(10)* addrspace(13)* %.repack, align 8, !tbaa !10
+  %.repack4 = getelementptr inbounds { {} addrspace(10)*, i64 }, { {} addrspace(10)*, i64 } addrspace(13)* %9, i64 %value_phi5, i32 1
+  store i64 %.unpack2, i64 addrspace(13)* %.repack4, align 8, !tbaa !10
+  %10 = add i64 %value_phi5, 1
+  %.not = icmp eq i64 %value_phi5, %2
+  br i1 %.not, label %L44, label %L26
+
+L44:                                              ; preds = %L26
+  ret {} addrspace(10)* null
+}
+
+attributes #0 = { "target-cpu"="skylake-avx512" "target-features"="+xsaves,+xsavec,+prfchw,+lzcnt,+sahf,+pku,+avx512vl,+avx512bw,+avx512cd,+clwb,+clflushopt,+adx,+avx512dq,+avx512f,+bmi2,+avx2,+bmi,+fsgsbase,+f16c,+avx,+xsave,+aes,+popcnt,+movbe,+sse4.2,+sse4.1,+cx16,+fma,+ssse3,+pclmul,+sse3,-rdrnd,-rtm,-rdseed,-avx512ifma,-avx512pf,-avx512er,-sha,-prefetchwt1,-avx512vbmi,-waitpkg,-avx512vbmi2,-shstk,-gfni,-vaes,-vpclmulqdq,-avx512vnni,-avx512bitalg,-avx512vpopcntdq,-rdpid,-cldemote,-movdiri,-movdir64b,-enqcmd,-avx512vp2intersect,-serialize,-tsxldtrk,-pconfig,-amx-bf16,-amx-tile,-amx-int8,-sse4a,-xop,-lwp,-fma4,-tbm,-mwaitx,-xsaveopt,-clzero,-wbnoinvd,-avx512bf16,-ptwrite,+sse2,+mmx,+fxsr,+64bit,+cx8" }
+attributes #1 = { inaccessiblemem_or_argmemonly }
+attributes #2 = { allocsize(1) }
+
+!0 = !{!1, !1, i64 0}
+!1 = !{!"jtbaa_value", !2, i64 0}
+!2 = !{!"jtbaa_data", !3, i64 0}
+!3 = !{!"jtbaa", !4, i64 0}
+!4 = !{!"jtbaa"}
+!5 = !{!6, !6, i64 0}
+!6 = !{!"jtbaa_arrayptr", !7, i64 0}
+!7 = !{!"jtbaa_array", !3, i64 0}
+!8 = !{!9, !9, i64 0}
+!9 = !{!"jtbaa_immut", !1, i64 0}
+!10 = !{!11, !11, i64 0}
+!11 = !{!"jtbaa_arraybuf", !2, i64 0}
diff --git a/llvm/test/Transforms/MergeICmps/addressspaces.ll b/llvm/test/Transforms/MergeICmps/addressspaces.ll
new file mode 100644
index 0000000000000..9a74b4a5b2ca4
--- /dev/null
+++ b/llvm/test/Transforms/MergeICmps/addressspaces.ll
@@ -0,0 +1,67 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
+; RUN: opt < %s -mergeicmps -S | FileCheck %s
+
+source_filename = "=="
+target datalayout = "e-m:e-i64:64-n32:64"
+target triple = "powerpc64le-unknown-linux-gnu"
+
+define void @juliaAS([2 x [5 x i64]] addrspace(11)* nocapture nonnull readonly align 8 dereferenceable(80) %0, [2 x [5 x i64]] addrspace(11)* nocapture nonnull readonly align 8 dereferenceable(80) %1) {
+; CHECK-LABEL: @juliaAS(
+; CHECK-NEXT:  top:
+; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* [[TMP0:%.*]], i64 0, i64 1, i64 2
+; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* [[TMP0]], i64 0, i64 1, i64 3
+; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* [[TMP0]], i64 0, i64 1, i64 4
+; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* [[TMP1:%.*]], i64 0, i64 1, i64 2
+; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* [[TMP1]], i64 0, i64 1, i64 3
+; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* [[TMP1]], i64 0, i64 1, i64 4
+; CHECK-NEXT:    [[TMP8:%.*]] = load i64, i64 addrspace(11)* [[TMP2]], align 8
+; CHECK-NEXT:    [[TMP9:%.*]] = load i64, i64 addrspace(11)* [[TMP5]], align 8
+; CHECK-NEXT:    [[DOTNOT17:%.*]] = icmp eq i64 [[TMP8]], [[TMP9]]
+; CHECK-NEXT:    br i1 [[DOTNOT17]], label [[L70:%.*]], label [[L90:%.*]]
+; CHECK:       L70:
+; CHECK-NEXT:    [[TMP10:%.*]] = load i64, i64 addrspace(11)* [[TMP3]], align 8
+; CHECK-NEXT:    [[TMP11:%.*]] = load i64, i64 addrspace(11)* [[TMP6]], align 8
+; CHECK-NEXT:    [[DOTNOT18:%.*]] = icmp eq i64 [[TMP10]], [[TMP11]]
+; CHECK-NEXT:    br i1 [[DOTNOT18]], label [[L74:%.*]], label [[L90]]
+; CHECK:       L74:
+; CHECK-NEXT:    [[TMP12:%.*]] = load i64, i64 addrspace(11)* [[TMP4]], align 8
+; CHECK-NEXT:    [[TMP13:%.*]] = load i64, i64 addrspace(11)* [[TMP7]], align 8
+; CHECK-NEXT:    [[DOTNOT19:%.*]] = icmp eq i64 [[TMP12]], [[TMP13]]
+; CHECK-NEXT:    br label [[L90]]
+; CHECK:       L90:
+; CHECK-NEXT:    [[VALUE_PHI2_OFF0:%.*]] = phi i1 [ false, [[TOP:%.*]] ], [ [[DOTNOT19]], [[L74]] ], [ false, [[L70]] ]
+; CHECK-NEXT:    ret void
+;
+top:
+  %2 = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* %0, i64 0, i64 1, i64 2
+  %3 = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* %0, i64 0, i64 1, i64 3
+  %4 = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* %0, i64 0, i64 1, i64 4
+  %5 = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* %1, i64 0, i64 1, i64 2
+  %6 = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* %1, i64 0, i64 1, i64 3
+  %7 = getelementptr inbounds [2 x [5 x i64]], [2 x [5 x i64]] addrspace(11)* %1, i64 0, i64 1, i64 4
+  %8 = load i64, i64 addrspace(11)* %2, align 8
+  %9 = load i64, i64 addrspace(11)* %5, align 8
+  %.not17 = icmp eq i64 %8, %9
+  br i1 %.not17, label %L70, label %L90
+
+L70:                                              ; preds = %top
+  %10 = load i64, i64 addrspace(11)* %3, align 8
+  %11 = load i64, i64 addrspace(11)* %6, align 8
+  %.not18 = icmp eq i64 %10, %11
+  br i1 %.not18, label %L74, label %L90
+
+L74:                                              ; preds = %L70
+  %12 = load i64, i64 addrspace(11)* %4, align 8
+  %13 = load i64, i64 addrspace(11)* %7, align 8
+  %.not19 = icmp eq i64 %12, %13
+  br label %L90
+
+L90:                                              ; preds = %L74, %L70, %top
+  %value_phi2.off0 = phi i1 [ false, %top ], [ %.not19, %L74 ], [ false, %L70 ]
+  ret void
+}
+
+!llvm.module.flags = !{!0}
+
+!0 = !{i32 1, !"Debug Info Version", i32 3}
+
diff --git a/llvm/test/Transforms/SimplifyCFG/nonintegral.ll b/llvm/test/Transforms/SimplifyCFG/nonintegral.ll
new file mode 100644
index 0000000000000..00c295ddc5c6d
--- /dev/null
+++ b/llvm/test/Transforms/SimplifyCFG/nonintegral.ll
@@ -0,0 +1,29 @@
+; RUN: opt -simplifycfg -verify -S < %s | FileCheck %s
+; RUN: opt -passes=simplifycfg,verify -S < %s | FileCheck %s
+
+target datalayout = "ni:1"
+
+define void @test_01(i64 addrspace(1)* align 8 %ptr) local_unnamed_addr #0 {
+; CHECK-LABEL: @test_01(
+; CHECK-NOT:   ptrtoint
+; CHECK-NEXT:  icmp eq i64 addrspace(1)* %ptr, null
+; CHECK-NOT:   ptrtoint
+  %cond1 = icmp eq i64 addrspace(1)* %ptr, null
+  %cond2 = icmp eq i64 addrspace(1)* %ptr, null
+  br i1 %cond1, label %true1, label %false1
+
+true1:
+  br i1 %cond2, label %true2, label %false2
+
+false1:
+  store i64 1, i64 addrspace(1)* %ptr, align 8
+  br label %true1
+
+true2:
+  store i64 2, i64 addrspace(1)* %ptr, align 8
+  ret void
+
+false2:
+  store i64 3, i64 addrspace(1)* %ptr, align 8
+  ret void
+}
diff --git a/llvm/unittests/ExecutionEngine/Orc/ThreadSafeModuleTest.cpp b/llvm/unittests/ExecutionEngine/Orc/ThreadSafeModuleTest.cpp
index 1ffb06db65975..5b094e2edd58c 100644
--- a/llvm/unittests/ExecutionEngine/Orc/ThreadSafeModuleTest.cpp
+++ b/llvm/unittests/ExecutionEngine/Orc/ThreadSafeModuleTest.cpp
@@ -91,4 +91,28 @@ TEST(ThreadSafeModuleTest, ContextLockPreservesContext) {
   TSCtx = ThreadSafeContext();
 }
 
+TEST(ThreadSafeModuleTest, WithModuleDo) {
+  // Test non-const version of withModuleDo.
+  ThreadSafeContext TSCtx(std::make_unique<LLVMContext>());
+  ThreadSafeModule TSM(std::make_unique<Module>("M", *TSCtx.getContext()),
+                       TSCtx);
+  TSM.withModuleDo([](Module &M) {});
+}
+
+TEST(ThreadSafeModuleTest, WithModuleDoConst) {
+  // Test const version of withModuleDo.
+  ThreadSafeContext TSCtx(std::make_unique<LLVMContext>());
+  const ThreadSafeModule TSM(std::make_unique<Module>("M", *TSCtx.getContext()),
+                             TSCtx);
+  TSM.withModuleDo([](const Module &M) {});
+}
+
+TEST(ThreadSafeModuleTest, ConsumingModuleDo) {
+  // Test consumingModuleDo.
+  ThreadSafeContext TSCtx(std::make_unique<LLVMContext>());
+  ThreadSafeModule TSM(std::make_unique<Module>("M", *TSCtx.getContext()),
+                       TSCtx);
+  TSM.consumingModuleDo([](std::unique_ptr<Module> M) {});
+}
+
 } // end anonymous namespace
